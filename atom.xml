<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gugugu&#39;s blog</title>
  
  
  <link href="https://luoyongjia.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyongjia.github.io/"/>
  <updated>2021-03-26T05:23:46.212Z</updated>
  <id>https://luoyongjia.github.io/</id>
  
  <author>
    <name>罗咏佳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac配置Anaconda环境变量</title>
    <link href="https://luoyongjia.github.io/2021/03/26/Mac%E9%85%8D%E7%BD%AEAnaconda%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://luoyongjia.github.io/2021/03/26/Mac%E9%85%8D%E7%BD%AEAnaconda%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-03-26T05:15:34.000Z</published>
    <updated>2021-03-26T05:23:46.212Z</updated>
    
    <content type="html"><![CDATA[<p>因为好像就是这两年，macOS的系统大更新，把默认shell的bash改成了zsh。导致以前的一些配置环境变量的东西都没法儿用了。今天要开始看python的代码了，所以想着来把anaconda配一下。真的太久没用了，导致版本都……所以需要在终端配置一下，居然发现我的终端的conda, not found了。就来解决了一下。</p><h2 id="机器背景"><a href="#机器背景" class="headerlink" title="机器背景"></a>机器背景</h2><p>mbp2018, bash。</p><p>会发现，原来的<code>bash_profile</code>都不管用了<br>而且，anaconda的默认路径也更改了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>anaconda的路径: <code>/Users/USERNAME/opt/anaconda3/bin</code></p><p>bash配置文件路径：<code>/private/etc/bashrc</code></p><p>就，强制在bashrc文件里面加<code>export PATH=&quot;/Users/USERNAME/opt/anaconda3/bin:$PATH&quot;</code><br>即可。</p><p>暂时还没出现问题，后续再说吧。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://zhuanlan.zhihu.com/p/121086727">Mac 没有找到 conda命令</a><br><a href="https://discussionschinese.apple.com/thread/251633370">mac设置全局环境变量</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为好像就是这两年，macOS的系统大更新，把默认shell的bash改成了zsh。导致以前的一些配置环境变量的东西都没法儿用了。今天要开始看python的代码了，所以想着来把anaconda配一下。真的太久没用了，导致版本都……所以需要在终端配置一下，居然发现我的终端的c</summary>
      
    
    
    
    
    <category term="环境变量" scheme="https://luoyongjia.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】串</title>
    <link href="https://luoyongjia.github.io/2021/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2/"/>
    <id>https://luoyongjia.github.io/2021/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2/</id>
    <published>2021-03-18T02:08:37.000Z</published>
    <updated>2021-03-18T04:01:39.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>计算机上非数值的处理对象。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><strong>Copy(&amp;T, s)</strong> 就是copy操作，将一个地址里的东西取出来，存到新的字符串里面。<br><strong>length()</strong> 字符串的长度。<br><strong>Index(S, T)</strong> 定位t的初始位置。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h2><p>顺序存储结构，分配一个定长的空间存储字符串。</p><h2 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h2><p>是在程序运行的过程中，动态分配形成的。当程序请求一块空间之后，在堆空间中分配一块区域。不成功返回null。</p><h2 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h2><p>类似于链式存储。多个节点，每个节点里面放几个字符。空的用“#”补全。</p><h1 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h1><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>老暴力方法了，就两个字符串硬比，没什么技术水平。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>这才是重中之重！<br>为什么有这种方法呢，因为在暴力算法中重复了大量的比较，这种方法能够减少这种重复的出现。</p><h3 id="先来一个文字描述"><a href="#先来一个文字描述" class="headerlink" title="先来一个文字描述"></a>先来一个文字描述</h3><blockquote><p><strong>什么是next数组</strong><br>next数组就是匹配字串的每一位所在的最长前后缀相同的长度。<br><br><strong>如何构建呢？<br></strong></p><ol><li>我使用的是动态规划的方法。前后两个指针。前指针指向后缀的最后一个字符，后指针指向后缀的最后一个字符。比较这两个指针存的内容，<br></li><li>当前指针为0，且前指针与后指针内容不相等的时候，后指针所指下标next数组存为0<br></li><li>相同则后指针所在位置等于前指针前一位next数组存的数字+1<br></li><li>不同则将前指针移动到前指针前一位next数组存的数字地址再做比较，直到前指针到0。<br><br><strong>如何匹配<br></strong></li><li>正常匹配<br></li><li>当遇到两个字符不相等的时候，将母串与子串的next数组对应的前一位的内容做对比，相当于将子串移动到前一next位。这样就减少了前一next之前的那些重复的比较。</li></ol></blockquote><h3 id="再来一个代码"><a href="#再来一个代码" class="headerlink" title="再来一个代码"></a>再来一个代码</h3><p>代码再说吧，有时间再写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;计算机上非数值的处理对象。&lt;/p&gt;
&lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【TOEFL】 口语Task1、Task2</title>
    <link href="https://luoyongjia.github.io/2021/03/11/%E3%80%90TOEFL%E3%80%91-%E5%8F%A3%E8%AF%ADTask1%E3%80%81Task2/"/>
    <id>https://luoyongjia.github.io/2021/03/11/%E3%80%90TOEFL%E3%80%91-%E5%8F%A3%E8%AF%ADTask1%E3%80%81Task2/</id>
    <published>2021-03-11T02:28:33.000Z</published>
    <updated>2021-03-11T02:54:07.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="review"><a href="#review" class="headerlink" title="review"></a>review</h1><h2 id="口语的评分标准"><a href="#口语的评分标准" class="headerlink" title="口语的评分标准"></a>口语的评分标准</h2><ol><li>dilivery: 表达，语言表达是否准确</li><li>language use: 用词和语法是否恰当</li><li>topic development: <ol><li>独立：每个点都要有一定的展开</li><li>综合：文中或者是听力中的每个细节都要提到 </li></ol></li></ol><h1 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h1><p>主要是如何展开，想论据这样子。</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="立场"><a href="#立场" class="headerlink" title="立场"></a>立场</h4><p>不同的角色有不同的立场，从不同的立场去考虑这个问题。比如说，junk food AD，就有parents和children两个方面去考虑这个广告的影响。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>不同的角色有不同的特点。还是那个junk food的例子，可能children就有容易被影响的特点。</p><h3 id="其他名词"><a href="#其他名词" class="headerlink" title="其他名词"></a>其他名词</h3><p>分析有没有具体的细节、具体的功能、具体的表现。比如那题，现代科技代替图书馆的题，就可以分析现代科技的功能，分析图书馆的功能，从这些角度来答题。</p><h1 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>校方通知，学生建议</p><h2 id="阅读中的注意点"><a href="#阅读中的注意点" class="headerlink" title="阅读中的注意点"></a>阅读中的注意点</h2><ul><li>改变：正文标题，第一句话。</li><li>数字：如果文中有数字，一定要记下来，在答题中打出来显得十分细节</li><li>姓名：写信的学生的姓名，然后就是教授的名字</li><li>借口：一般会有两个接口，记个大概，因为有时候会让重复、总结文中的理由。学生的建议有时候会需要答。</li></ul><h2 id="答题模版"><a href="#答题模版" class="headerlink" title="答题模版"></a>答题模版</h2><ol><li>The university gives an announcement that/of do/doing …<br>Student xxx suggests/proposes the university to do …</li><li>agrees: feels happy with, infovor of <br>disagrees: feels sorry for</li><li>attrcting, enhence: 文中的理由和听力中的相同，就增强。不同就另说。</li></ol><h2 id="增长时间利器"><a href="#增长时间利器" class="headerlink" title="增长时间利器"></a>增长时间利器</h2><p>如果答完自己记录的细节还有5s多，那就来一句废话，就是关于第2个理由的废话，时间就够啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;review&quot;&gt;&lt;a href=&quot;#review&quot; class=&quot;headerlink&quot; title=&quot;review&quot;&gt;&lt;/a&gt;review&lt;/h1&gt;&lt;h2 id=&quot;口语的评分标准&quot;&gt;&lt;a href=&quot;#口语的评分标准&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="TOEFL" scheme="https://luoyongjia.github.io/categories/TOEFL/"/>
    
    
    <category term="口语" scheme="https://luoyongjia.github.io/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】栈和队列</title>
    <link href="https://luoyongjia.github.io/2021/03/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://luoyongjia.github.io/2021/03/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-03-10T12:51:00.000Z</published>
    <updated>2021-03-11T02:26:17.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是线性表的应用和推广。是受限的线性表。栈，就是“先进后出”。就像一个只有一个出口的桶，先进去的人只能等后进去的人走了才能出去。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>isEmpty()</strong> 栈是否为空<br><strong>push(&amp;s, T elem)</strong> 压入栈<br><strong>pop(&amp;s, T elem)</strong> 吐出最顶上那个元素<br><strong>getTop(s, &amp;x)</strong>  把最顶上那个复制一份给x<br><strong>destroyStack()</strong> 毁灭吧，栈</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储—-gt-顺序栈"><a href="#顺序存储—-gt-顺序栈" class="headerlink" title="顺序存储—&gt;顺序栈"></a>顺序存储—&gt;顺序栈</h3><p>就是用数组来存，然后有一个位置指针来操作。</p><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>顺序栈的抠门做法。一个空间俩栈用。一个从头开始，一个从尾巴开始这样子。</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>就叫链栈。便于多个栈共享存储空间，提高效率。不存在放不下的问题，反正链式，可以无限扩展。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>算式转换，中序转后序。这个不好怎么解释，就来个🌰体会一下。</p><blockquote><p>中序表达式 <code>a + b - a * ((c + d) / e - f) + g</code>转换为等价的后缀表达式为<code>ab+acd+e/f-*-g+</code><br><br>过程大约是这个样子的：<br></p><ol><li>最先压入一个“#”<br></li><li>然后遇到数字直接输出<br></li><li>遇到符号根据优先级来，如果后一个的优先级高于栈顶的，则直接压入；如果后一个的优先级低于栈顶的，则弹出栈顶的，再做比较。</li></ol></blockquote><p>来一道例题吧</p><blockquote><p>假设栈初始为空，将中序表达式<code>a / b + (c * d - e * f) / g</code>转换为等价的后缀表达式的过程中，当扫描到<code>f</code>时，栈中的元素依次是<br><br>A.<code>+(*-</code> B. <code>+(-*</code> C. <code>/+(*-*</code> D. <code>/+-*</code><br><br><br><br>直接来个答案吧，B</p></blockquote><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><blockquote><ol><li>设链表不带头节点，且所有操作均在表头进行，则下列最不适合作为链栈的是（ ）<br><br> A. 只有表头节点指针，没有表尾指针的双向循环链表<br> B. 只有表尾节点指针，没有表头指针的双向循环链表<br>C. 只有表头节点指针，没有表尾指针的单项循环链表<br>D.只有表尾节点指针，没有表头指针的单项循环链表<br><br><br><br>C. 因为这里只有表头，没有表尾。每次对于栈的操作都是在头上做的。但是为了维持循环链表，所以得找到尾，所以所有操作至少都是<script type="math/tex">O(n)</script>，所以它不合适。<br><br></li><li><p>若已知一个栈的入栈序列是1，2，3，4，其出栈序列为<script type="math/tex">P_{1}, P_{2}, P_{3}, P_{4}</script>, 则<script type="math/tex">P_{2}, P_{4}</script>不可能是（ ）<br><br>A. 2，4  B. 2，1 C. 4，3 D.<br><br><br><br>这种题目，就只有一种方法，那就是自己一个个举例子。<br><br></p></li><li><p>设栈的初始状态为空，当字符序列“n1_”作为栈的输入时，输出长度为3，且可用作C语言标识符的序列有（ ）<br><br>A. 4 B. 5 C. 3 D. 6<br><br><br><br>这个题我个人觉得出的还挺好的，结合了数据结构和C语言的知识。这里，C语言标识符的要求是“第1个字符只能是字母或是下划线。”</p></li></ol></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>也是特殊的线性表。先进先出，就跟那吸管一样，只有一头可以进，另一头可以出。</p><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>front</strong> 头<br><strong>rear</strong> 尾<br><strong>enQueue()</strong> 压入<br><strong>deQueue()</strong> 出队列<br><strong>getHead()</strong> 获取头</p><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>“假溢出”。要是用传统的一条的那种数组来存队列的话，进进出出几次，下标就给整没了，但是其实那时候队列里面还是有空间存储元素的。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>所以人们就变聪明了，用环形的来存储队列。这就涉及一个下标计算的问题，这个问题常考，所以要记得一些公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">队首指针进1: front &#x3D; (front + 1) % MaxSize</span><br><span class="line">队尾指针进1:rear &#x3D; (rear + 1) %MaxSize</span><br><span class="line">队列长度:(rear + MaxSize - front) %MaxSize</span><br><span class="line">队满：(rear + 1) % MaxSize &#x3D;&#x3D; front</span><br><span class="line">空：front &#x3D;&#x3D; rear</span><br></pre></td></tr></table></figure><h3 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h3><p>带头节点单链表。有一个头头节点，然后有一个rear节点，这样子就能够很好的表示队列。</p><h2 id="奇奇怪怪的队列增加了"><a href="#奇奇怪怪的队列增加了" class="headerlink" title="奇奇怪怪的队列增加了"></a>奇奇怪怪的队列增加了</h2><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>就是两端都可以出栈和入栈。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>解决主机与外设之间速度不匹配的问题，解决由多用户引起的cpu资源竞争问题。<br>eg：设置一个打印数据缓冲区。cpu中的任务排成一个队列。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;是线性表的应用</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【数据结构】线性表</title>
    <link href="https://luoyongjia.github.io/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://luoyongjia.github.io/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2021-03-08T09:32:27.000Z</published>
    <updated>2021-03-08T15:00:48.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>相同数据类型</strong>的数据元素，<strong>有限</strong>长的序列。是一种逻辑结构，表示元素之间一对一的相邻关系。</p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>使用连续地址存储。这里有一个<strong>位序</strong>，位序是从1开始的。</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>最开始的时候分配的一定量的空间，是不可以扩充的。</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>开始分配一定量的空间。在存满之后，会开辟更大一个空间，然后替换之前那个小空间。</p><h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><p>纯属，只是写了，没有测试是否正确。VSCode的c++配置太难了，就这样吧。我试着去把JetBrains的工具下下来。果然白嫖就是有点难…</p><p>SeqList.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># ifndef CIRCLE_H</span><br><span class="line"># define CIRCLE_H</span><br><span class="line">int defaultSize &#x3D; 100;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SeqList</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T *data;</span><br><span class="line">    int maxSize;</span><br><span class="line">    int last;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    SeqList(int len &#x3D; defaultSize);</span><br><span class="line">    SeqList(const SeqList&lt;T&gt; &amp;L);   &#x2F;&#x2F; 拷贝构造</span><br><span class="line">    ~SeqList();</span><br><span class="line">    &#x2F;&#x2F; ostream &amp;operator&#x3D;(const SeqList&lt;T&gt; &amp;L);</span><br><span class="line"></span><br><span class="line">    bool Add(T elem);</span><br><span class="line">    bool Insert(int i, T elem);</span><br><span class="line">    bool Remove(int i, T elem);</span><br><span class="line">    int Search(T elem);</span><br><span class="line">    void SetData(int i, T elem);</span><br><span class="line">    void Show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>SeqList.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SeqList.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(int len)&#123;</span><br><span class="line">    maxSize &#x3D; len;</span><br><span class="line">    data &#x3D; new T[maxSize];</span><br><span class="line">    last &#x3D; -1;  &#x2F;&#x2F;线性表为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(const SeqList&lt;T&gt; &amp;L)&#123;</span><br><span class="line">    maxSize &#x3D; L.maxSize;</span><br><span class="line">    last &#x3D; L.last;</span><br><span class="line">    data &#x3D; new T[maxSize];</span><br><span class="line"></span><br><span class="line">    if(data &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;存储分配失败&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~SeqList()&#123;</span><br><span class="line">    delete[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Add(T elem)&#123;</span><br><span class="line">    if((last + 1)&gt;maxSize)</span><br><span class="line">        return false;</span><br><span class="line">    data[last++] &#x3D; elem;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Insert(int i, T elem)&#123;</span><br><span class="line">    if(last &#x3D;&#x3D; maxSize-1)&#123;</span><br><span class="line">        &#x2F;&#x2F; 表满，不能再存</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &lt; 0 || i &gt;last+1)&#123;</span><br><span class="line">        &#x2F;&#x2F; i越界了</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; last; j &gt;&#x3D; i; j--)&#123;</span><br><span class="line">        data[j + 1] &#x3D; data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    data[i] &#x3D; elem;</span><br><span class="line">    last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Remove(int i, T elem)&#123;</span><br><span class="line">    if(i &lt; 0|| i &gt; last)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; i; j &lt; last; j++)&#123;</span><br><span class="line">        data[j] &#x3D; data[j + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    last--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int SeqList&lt;T&gt;::Search(T elem)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; last; i++)&#123;</span><br><span class="line">        if(data[i] &#x3D;&#x3D; elem)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::SetData(int i, T elem)&#123;</span><br><span class="line">    &#x2F;&#x2F; 检查i的合法性</span><br><span class="line">    if(i &lt; 0|| i &gt; last)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[i] &#x3D; elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::Show()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; last; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>插入： <script type="math/tex">O(n)</script><br>删除： <script type="math/tex">O(n)</script><br>查找： <script type="math/tex">O(1)</script><br>修改： <script type="math/tex">O(1)</script>    </p><h2 id="错题环节"><a href="#错题环节" class="headerlink" title="错题环节"></a>错题环节</h2><blockquote><ol><li>线性表的顺序存储结构是一种（ ）<br><br>A. 随机存取的存储结构        B. 顺序存取的存储结构  C. 索引存储的存储结构  D.散列存取的存储结构<br><br><br>⚠️选项中写的是<strong>存取</strong>。顺序存储，就是可以瞎取（按照下标直接存取），所以是随机的存取结构。而顺序的存取结构，是链式存储的，就是说只可以按照一定的顺序来存取。</li></ol></blockquote><h1 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h1><p>其实就是用链式存储来存顺序表，这其中不过是分配的空间不连续了。</p><h2 id="静态链表与动态链表"><a href="#静态链表与动态链表" class="headerlink" title="静态链表与动态链表"></a>静态链表与动态链表</h2><p>静态链表：初始化的时候，每个节点都初始化了。不能改变长短的。但是存储地址不一定是连续的。<br>动态链表：就，日常的链表</p><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><h3 id="头与尾"><a href="#头与尾" class="headerlink" title="头与尾"></a>头与尾</h3><p>头节点与尾节点，可有可无。里面不存内容，单纯定个位。有时候计算链表的长度可以考虑下是否有头、尾的情况。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>日常的，单向的链表。</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>就是不仅仅有指向下一个节点的指针，还有指向上一个节点的指针。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>尾部的next是头节点。就是，形成一个环了的链表。</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>一个表，跟顺序表差不多。存的指针是节点的相对地址，也就是下一个元素的index。-1时结束。</p><p><img src="/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/1.jpg" alt="f1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;相同数据类型&lt;/strong&gt;的数据元素，&lt;strong&gt;有限&lt;/strong&gt;长的序列。是一种逻辑结构，表示元素之间一对一</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>503. 下一个更大的元素2</title>
    <link href="https://luoyongjia.github.io/2021/03/06/503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A02/"/>
    <id>https://luoyongjia.github.io/2021/03/06/503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A02/</id>
    <published>2021-03-06T15:37:15.000Z</published>
    <updated>2021-03-07T08:35:14.909Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看题，这题…有点绕。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组（首尾相接那种），输出每个元素的下一个更大元素。如果搜完了整个数组，都没有找到比它大的数字，就输出-1。</p><blockquote><p><strong>输入：</strong>[1, 2, 1]<br><br><strong>输出：</strong>[2, -1, 2]<br><br><strong>解释：</strong>第一个1的下一个更大的数是2；<br><br>数字2找不到下一个更大的数；<br>第二个1的下一个最大的数循环搜索，结果就是2</p></blockquote><h2 id="自己一想"><a href="#自己一想" class="headerlink" title="自己一想"></a>自己一想</h2><p>简单，粗暴的方法。这样时间复杂度到了<script type="math/tex">O(n^{2})</script></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">    int[] ans &#x3D; new int[nums.length];</span><br><span class="line">    boolean forhead;</span><br><span class="line">    &#x2F;&#x2F; 找每一个数字的下一个更大的元素</span><br><span class="line">    for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        forhead &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 先找i后面的元素</span><br><span class="line">        for(int j &#x3D; i+1; j &lt; nums.length; j++)&#123;</span><br><span class="line">            if(nums[j] &gt; nums[i])&#123;</span><br><span class="line">                ans[i] &#x3D; nums[j];</span><br><span class="line">                forhead &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 再找i前面的元素</span><br><span class="line">        if(forhead &#x3D;&#x3D; true)&#123;</span><br><span class="line">            int k;</span><br><span class="line">            for(k &#x3D; 0; k &lt; i; k++)&#123;</span><br><span class="line">                if(nums[k] &gt; nums[i])&#123;</span><br><span class="line">                    ans[i] &#x3D; nums[k];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k &#x3D;&#x3D; i)&#123;</span><br><span class="line">                ans[i] &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="然后解析里的“单调栈”"><a href="#然后解析里的“单调栈”" class="headerlink" title="然后解析里的“单调栈”"></a>然后解析里的“单调栈”</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>栈里面的元素从栈底到栈顶是单调的。</p><ul><li>如果栈空，当前元素入栈</li><li>栈非空，判断当前和栈顶元素的大小<ul><li>如果比栈顶元素大，那么逐个弹出比较，构建ans</li><li>如果比栈顶元素小，则当前元素入栈</li></ul></li></ul><h3 id="循环数组实现方法："><a href="#循环数组实现方法：" class="headerlink" title="循环数组实现方法："></a>循环数组实现方法：</h3><p><strong>Way1:</strong>  把数组复制一份到数组的末尾<br><strong>Way2:</strong> 使用取模运算，把下表为<script type="math/tex">i</script>映射到数组<script type="math/tex">nums</script>的长度<script type="math/tex">0-N</script>中</p><h2 id="重写代码"><a href="#重写代码" class="headerlink" title="重写代码"></a>重写代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    int[] ans &#x3D; new int[n];</span><br><span class="line">    &#x2F;&#x2F;将ans用-1初始化</span><br><span class="line">    Arrays.fill(ans, -1);</span><br><span class="line">    Deque&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 栈非空,且比栈顶元素大，逐个弹出比较，构建ans</span><br><span class="line">        while(!stack.isEmpty() &amp;&amp; nums[stack.peek()]&lt;nums[i%n])&#123;</span><br><span class="line">            ans[stack.pop()] &#x3D; nums[i%n];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 不比栈顶元素大了，或者小了，或者栈空了，压入</span><br><span class="line">        stack.push(i%n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/">动画讲解：单调栈</a></p><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/">code来源-LeetCode-Solution</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来看看题，这题…有点绕。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个循环数组（首尾相接那种），输出每个元素的下一个更大元素。如果搜完了整个数组，都没有找到比它</summary>
      
    
    
    
    <category term="leetcode" scheme="https://luoyongjia.github.io/categories/leetcode/"/>
    
    
    <category term="单调栈" scheme="https://luoyongjia.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】绪论</title>
    <link href="https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/"/>
    <id>https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/</id>
    <published>2021-03-06T12:27:22.000Z</published>
    <updated>2021-03-08T09:33:24.559Z</updated>
    
    <content type="html"><![CDATA[<p>我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>很好，记不住的东西。</p><p><strong>数据</strong> 是信息，是数据，是程序直接处理的原料。<br><strong>数据元素</strong> 数据元素含有数据，是由一群数据组成的最小的、不可分割的最小单位。比如说，一个学生（包括他的姓名、学号、年龄等）就是一个数据元素。<br><strong>数据对象</strong> 一群同类型的数据元素组成的。比如说，学生对象，就是由一群学生对象组成的。<br><strong>数据类型</strong> 就比如说<code>byte, short, int, long</code>这些。就是一种数值的集合。其下面又有<strong>原子类型</strong>、<strong>结构类型</strong>、<strong>抽象数据类型</strong>，分别表示值不可分，值可以分，数据和与之相关的操作。<br><strong>数据结构</strong> 诶嘿，终于到它了。数据结构是有关系的数据元素的集合。包括<strong>逻辑结构</strong>，<strong>存储结构</strong>和<strong>数据的运算</strong>（个人理解为方法）。</p><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><p>我觉得这里主要是在讲逻辑结构与存储结构。还有一个名词叫“物理结构”，我在这里将会把他们仨分清楚。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑逻辑嘛，那当然是一种抽象的东西，我们不考虑他们的实际应该怎么样，只去考虑这样子特性的数据有些什么特色，可以怎么操作。</p><p><img src="/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/逻辑结构.png" alt="f1"></p><p>这里要解释一下<strong>集合</strong>，就是一群数据挤到一起，没有其他联系这样子。</p><h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>就是解决如何将数据存储的问题。</p><p><img src="/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/存储结构.png" alt="f1"></p><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>个人理解，就是操作、方法这种东西。</p><h3 id="这里来几道错题加深理解"><a href="#这里来几道错题加深理解" class="headerlink" title="这里来几道错题加深理解"></a>这里来几道错题加深理解</h3><blockquote><ol><li>可以用（ ）来定义一个完整的数据结构<br><br>A. 数据元素        B.数据对象        C.数据关系        D. 抽象数据类型<br><br>这里，👀上面的基本概念，就能得出答案D<br><br><br></li><li>以下属于逻辑结构的是（ ）<br><br>A. 顺序表    B. 哈希表    C. 有序表    D. 单链表<br><br><br>顺序表、哈希表、单链表，既可以表示逻辑结构，又可以表示存储结构。只有有序表是单纯的。<br><br><br></li><li>以下数据与数据的存储结构无关的术语是（ ）<br><br>A. 循环队列 B. 链表 C. 哈希表 D. 栈<br><br><br>B和C都很好排除。循环队列为一种数据结构？（这里存疑，之后来解决）可能是因为，他包含顺序表的逻辑结构，和顺序存储的存储结构，以及一些操作方法。讲真，<strong>不知道如何区分数据结构和逻辑结构的区别</strong>。问问后来补充。<br><br><br></li><li>在存储数据时，通常不仅要存储个数据元素的值，而且要存储( )<br><br>A. 数据的操作方法 B. 数据元素的类型 C. 数据元素之间的关系 D. 数据存取的方法<br><br><br>D，这没啥好说的，记住就好。</li></ol></blockquote><h2 id="算法评价"><a href="#算法评价" class="headerlink" title="算法评价"></a>算法评价</h2><p>算法，对于一个问题的解决方法逐步描述。</p><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><p><strong>有穷性</strong> 是不是有穷时间能跑完<br><strong>确定性</strong> 描述是不是无歧义的<br><strong>可行性</strong> 电脑能不能跑起来<br><strong>I/O</strong> 输入输出<br><strong>正确性</strong> 能不能正确解决问题<br><strong>可读性</strong> 是不是很好理解<br><strong>健壮性</strong> 能不能面对攻击<br><strong>效率</strong> 效率就是效率，时间、空间效率</p><h3 id="时间复杂度、空间复杂度"><a href="#时间复杂度、空间复杂度" class="headerlink" title="时间复杂度、空间复杂度"></a>时间复杂度、空间复杂度</h3><p>这种主要考：给段代码，然后让算复杂度。</p><p>注意点：O(1)的可以是常数级别的复杂度。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://blog.csdn.net/YangTongA/article/details/78244252">数据结构之逻辑结构与物理结构（存储结构）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;很</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>再开公告</title>
    <link href="https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/"/>
    <id>https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/</id>
    <published>2021-03-06T11:56:28.000Z</published>
    <updated>2021-03-06T12:19:28.588Z</updated>
    
    <content type="html"><![CDATA[<p>很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。</p><p>之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找别人讨论；看元学习那篇大论文的时候，因为很多数学知识不了解，又放弃（过了一段时间明白了之中的大概原理）。当然，可能因为当初想的很多的时候，人还很小；来到大学了之后接触了更多的东西，选择多了，人也就迷惑了。</p><p>但是我觉得，我的绝望，很多是来源与我自己。我总觉得自己应该成为一个了不起的人，但是，大多数人最终不是还是普通人吗？我打算认命的，但是我做了什么呢？在家摸鱼摸了俩月。看出来了吧，就是因为自己骨子里的懒惰。考研的时候也是这样，学了两天之后，得休息上三天，才能继续。恨自己的不争气，却又一再地放纵。还有遇见了困难，总是想逃避，总想过着当下混沌又舒适的生活。可是这样的生活，我过得也很难受。总的来说，就是想要摆脱现状，但是又没有行动这样子。</p><p>认识到问题，当然得改。我试着去改改吧，这样下去不是个事儿。就从这次准备复试开始吧。</p><p>接下来想要在blog上分享一下我每天为复试准备的知识，以及每次上完TOEFL课的小总结这样子。</p><p><img src="/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/1.jpg" alt="figer1"></p><p>偷偷放一张喜欢的焦糖太太的图。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。&lt;/p&gt;
&lt;p&gt;之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="随笔" scheme="https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>String，StringBuffer和StringBuilder类</title>
    <link href="https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/"/>
    <id>https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/</id>
    <published>2021-01-08T10:14:09.000Z</published>
    <updated>2021-01-08T10:16:39.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String，StringBuffer和StringBuilder类"><a href="#String，StringBuffer和StringBuilder类" class="headerlink" title="String，StringBuffer和StringBuilder类"></a>String，StringBuffer和StringBuilder类</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String对象的值是无法改变的！要改变，请找String Buffer和String Builer</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str0 &#x3D; &quot;Gugugu&quot;;</span><br><span class="line">String str1 &#x3D; &quot;Gugugu&quot;;</span><br><span class="line">String str2 &#x3D; new String(&quot;Gugugu&quot;);</span><br><span class="line">String str3 &#x3D; new String(&quot;Gugugu&quot;);</span><br></pre></td></tr></table></figure><p>str0和str1都是指向公共池中相同的地址，而str2和str3指向堆中的不同地址。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>str0.length()</strong>    获取长度</p><p><strong>str0.concat(str1)</strong>    连接两个字符串，返回的是创建的一个新字符串，可以自己连自己。</p><p><strong>String.format(“balabalabala是%f”, floatVar)</strong>    就跟printf一样。String（java）里面是百分号诶。</p><p><strong>char charAt(int index)</strong> 返回指定下标的字符</p><p><strong>int indexOf(int ch)</strong> 返回第一次出现ch（or str）的下标，如果没有就-1</p><p><strong>int compareTo(String str)</strong> 字典序比较字符串</p><p><strong>int compareTolgnoreCase(String str)</strong>    不考虑大小写的比较字符串</p><p><strong>boolean contentEquals(StringBuffer sb)</strong>    与指定的StringBuffer有相同顺序的字符时返回true</p><p><strong>static String copyValueOf(char[] data, int offset, int count)</strong>    返回指定数组中表示改字符的序列的String。offset是开始点。</p><p><strong>char[] toCharArray()</strong>    转换为字符数组</p><p><strong>String toLowerCase()</strong>    全部转小写</p><p><strong>String toUpperCase()</strong>    全部转大写</p><p><strong>isEmpty()</strong>    判断字符串是否为空</p><h2 id="String-Buffer和String-Builder"><a href="#String-Buffer和String-Builder" class="headerlink" title="String Buffer和String Builder"></a>String Buffer和String Builder</h2><p>StringBuffer和StringBuilder类的对象能够被多次修改，不产生新的未使用对象。</p><p>StringBuilder和StringBuffer最大的不同在于StringBuilder的方法不是线程安全的（不能同步访问）。</p><p>StringBuilder运行速度比StringBuffer快。</p><p><img src="/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/1.png" alt="figer1"></p><p><img src="/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/2.png" alt="figer2"></p><p>refer:<br><a href="https://www.runoob.com/java/java-string.html">Java String 类</a><br><a href="https://www.runoob.com/java/java-stringbuffer.html">Java StringBuffer 和 StringBuilder 类</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String，StringBuffer和StringBuilder类&quot;&gt;&lt;a href=&quot;#String，StringBuffer和StringBuilder类&quot; class=&quot;headerlink&quot; title=&quot;String，StringBuffer和Stri</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="常用类" scheme="https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月3日</title>
    <link href="https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/</id>
    <published>2021-01-03T15:43:55.000Z</published>
    <updated>2021-01-03T15:52:06.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Character类、Math类、Number类</li><li>动态规划问题，三道题</li><li>练字</li></ul><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天感觉还是很充实的，虽然看下来没有做些什么，但是其实又做了一点什么。感觉需要上计网和机组了…想要找一点对应的题做，不知道去年的王道的书被我丢哪儿了…没事儿，从网上找点对应题应该也不错。今天发现了一个写leetCoded总结很好的项目，之后就跟这个吧。我感觉明天常用类也能差不多，感觉在常用类上耗太久了，之后边用边学吧。今天终于是不咕鸟了，早点休息，想要拥有正常的作息。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>leetcode一个专题</li><li>Java集合、IO</li><li>计网和机组</li><li>练字</li></ol><hr><p>♨️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Character类、Math类、Number类&lt;/li&gt;
</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划问题</title>
    <link href="https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-03T06:04:03.000Z</published>
    <updated>2021-03-07T08:34:39.144Z</updated>
    
    <content type="html"><![CDATA[<p>一般形式是求最值，比如说最长递增子序列，最小编辑距离。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>求最值，把所有的可行答案穷举出来，然后找最值就ok。</p><p><em>动态规划</em>不是简单的穷举，因为动态规划问题存在<strong>「重叠子问题」</strong>，暴力穷举会效率很低，所以需要「备忘录」或者「DP table」来优化穷举的过程，避免不必要的计算。</p><p>并且动态规划一定会具备<strong>「最优子结构」</strong>，才能通过子问题的最值的到原问题的最值。<br>需要列出正确的<strong>「状态转移方程」</strong>才能正确的穷举。在实际的算法问题中，写出「状态转移方程」是最困难的。所以提供了一个思维框架辅助思考状态转移方程：</p><p><strong>明确base case -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义</strong></p><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h2><h3 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法"></a>暴力递归法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法十分的低效，假设n = 20，画出递归树：</p><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure1.png" alt="figure1"></p><p>PS：画出递归树是分析递归问题的好方法。</p><h4 id="递归算法的时间复杂度计算"><a href="#递归算法的时间复杂度计算" class="headerlink" title="递归算法的时间复杂度计算"></a>递归算法的时间复杂度计算</h4><p>首先计算子问题数，由图可以看出斐波那契数列是满二叉树，所以子问题的个数为<script type="math/tex">O(2^n)</script></p><p>然后计算每个子问题的时间，此算法没有循环，只有一个递归基和<code>f(n - 1) + f(n - 2)</code>，所以时间复杂度为<script type="math/tex">O(1)</script></p><p>递归算法的时间复杂度为子问题数 <script type="math/tex">\times</script> 子问题的时间。由此可得：斐波那契的暴力递归解法的时间复杂度为 <script type="math/tex">O(2^n)</script></p><p>观察递归树，可以发现：存在了大量的重复计算，比如<code>f(18)</code>被计算了两次，而<code>f(18)</code>为根的递归树体量巨大，多算一遍会耗费巨大的时间，在递归中出现了多次这样的情况，使得重复进行了多次相同的运算，使得这个算法十分低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。</p><h3 id="如何解决「重叠子问题」的问题"><a href="#如何解决「重叠子问题」的问题" class="headerlink" title="如何解决「重叠子问题」的问题"></a>如何解决「重叠子问题」的问题</h3><h4 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h4><p>我们可以造一个「备忘录」，每次计算出某个子问题的答案之后，先记入「备忘录」，然后再返回。每次遇到一个子问题先去「备忘录」中查查，如果发现已经解决过这个问题，就直接把答案拿出来用，就不用再次计算了。</p><p>一般使用数组充当这个「备忘录」，当然也可以用哈希表（字典）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int memoFib(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">&#x2F;&#x2F; 为了提高代码的可读性，所以开辟了n+1，这样每个fib数将会与相应的下标对应</span><br><span class="line">int[] memoArray() &#x3D; new int[n+1];</span><br><span class="line"></span><br><span class="line">return helper(memoArray(), n);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造memArray()</span><br><span class="line">public int memArray(int[] memo, int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line">if(memo[n] !&#x3D; 0)</span><br><span class="line">return memo[n];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归体</span><br><span class="line">memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2);</span><br><span class="line"></span><br><span class="line">return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><h4 id="dp数组迭代解法"><a href="#dp数组迭代解法" class="headerlink" title="dp数组迭代解法"></a>dp数组迭代解法</h4><p>有了上一步「备忘录」的启发，我们可以把「备忘录」独立出来成为一张表，就叫做DP table。在这张表上完成「自底向上」的推算岂不美哉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int dpTable(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构建dpTable</span><br><span class="line">int[] dp &#x3D; new int[n + 1];</span><br><span class="line">dp[1] &#x3D; 1;</span><br><span class="line">dp[2] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">dp[i] &#x3D; dp[i - 1] + dp[1 - 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure2.jpg" alt="figure2"></p><p><strong>「状态转移方程」</strong>：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}1, n = 1,2 \\f(n-1) + f(n-2), n>2 \\\end{aligned}\right.</script><p>这里把<code>f(n)</code>想做状态<code>n</code>，状态<code>n</code>是由状态<code>n-1</code>和状态<code>n-2</code>相加转移而来的，这就叫状态转移。</p><p>所以要先想出暴力解，然后通过暴力解的到转移方程，再通过备忘录或者DP table优化。</p><p><strong>fib还可以优化</strong><br>甚至不需要整个dpTable，只需要记载n，n-1，n-2三个值就ok，此时的复杂度降到了<em>O(1)</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int bestFib(int n)&#123;</span><br><span class="line">int num1 &#x3D; 1;</span><br><span class="line">int num2 &#x3D; 1;</span><br><span class="line">int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">num &#x3D; num1 + num2;</span><br><span class="line">num1 &#x3D; num2;</span><br><span class="line">num2 &#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法叫做「状态压缩」，当我们发现状态转移时只需要用上DP table中的一部分，那样就可以尝试用状态压缩来缩小DP table。</p><h2 id="322-凑零钱"><a href="#322-凑零钱" class="headerlink" title="322.凑零钱"></a>322.凑零钱</h2><p>题目：给你<code>k</code>中面值的硬币，面值分别为<code>c1, c2, ...,ck</code>，美中硬币的数量无限，再给一个总金额<code>amount</code>，问最少需要几枚硬币来凑出这个金额，如果凑不出，返回<code>-1</code>。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合<strong>「最优子结构」</strong>，<strong>子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p><p>比如说，假设考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><h3 id="如何列出正确的状态转移方程"><a href="#如何列出正确的状态转移方程" class="headerlink" title="如何列出正确的状态转移方程"></a>如何列出正确的状态转移方程</h3><ol><li><p><strong>确定 base case</strong>，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p><strong>确定「状态」</strong>，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p></li><li><strong>确定「选择」</strong>，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li><li><strong>明确 dp 函数/数组的定义</strong>。这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：</li></ol><p><code>dp(n)</code> ：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p><p>然后就可以得到状态转移方程</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}0, n=0 \\-1, n<0 \\min\{dg(n-coin) + 1|coin \in coins\}, n>0\end{aligned}\right.</script><h3 id="带备忘录的递归解法-1"><a href="#带备忘录的递归解法-1" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public int getCoinsMemo(int[] coins, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int[] memo &#x3D; new int[n + 1];</span><br><span class="line">    return helper(coins, memo, n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public int helper(int[] coins, int[] memo, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[n] !&#x3D; 0)</span><br><span class="line">        return memo[n];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;得到当💰需要的coin数</span><br><span class="line">    int cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int coinNum &#x3D; 0;</span><br><span class="line">    for (int coin : coins) &#123;</span><br><span class="line">        coinNum &#x3D; helper(coins, memo, n - coin);</span><br><span class="line">        &#x2F;&#x2F; 当小于0或者这个子方法表示不出的时候</span><br><span class="line">        if (n - coin &lt; 0 || coinNum &#x3D;&#x3D; -1)</span><br><span class="line">            continue;</span><br><span class="line">        if (coinNum + 1 &lt; cur) &#123;</span><br><span class="line">            cur &#x3D; coinNum + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cur &#x3D;&#x3D; Integer.MAX_VALUE)&#123;</span><br><span class="line">        cur &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] &#x3D; cur;</span><br><span class="line">    return cur;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自底向上的DPtable方法"><a href="#自底向上的DPtable方法" class="headerlink" title="自底向上的DPtable方法"></a>自底向上的DPtable方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自底向上DPtable方法</span><br><span class="line">public int getCoinsDP(int[] coins, int sum) &#123;</span><br><span class="line">    if (sum &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if (sum &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp[] &#x3D; new int[sum + 1];</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    int cur;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; sum; i++) &#123;</span><br><span class="line">        cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            if (i - coin &lt; 0 || dp[i - coin] &#x3D;&#x3D; -1)</span><br><span class="line">                continue;</span><br><span class="line">            if (dp[i - coin] + 1 &lt; cur)</span><br><span class="line">                cur &#x3D; dp[i - coin] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur &#x3D;&#x3D; Integer.MAX_VALUE)</span><br><span class="line">            dp[i] &#x3D; -1;</span><br><span class="line">        else</span><br><span class="line">            dp[i] &#x3D; cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就是那个步骤：</p><p><strong>明确base case（递归基） -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 -&gt;优化</strong></p><h3 id="「备忘录」自上而下的方法"><a href="#「备忘录」自上而下的方法" class="headerlink" title="「备忘录」自上而下的方法"></a>「备忘录」自上而下的方法</h3><p>其实就是一种递归的优化方法，消除了很多重复计算的部分，所以优化了方法，但是还是没有自下而上好。</p><h3 id="「DPtable」自下而上的方法"><a href="#「DPtable」自下而上的方法" class="headerlink" title="「DPtable」自下而上的方法"></a>「DPtable」自下而上的方法</h3><p>当我们分析出「状态转移方程」后，就可以自下而上构造<code>dp[]</code>（其实就是备忘录），然后直接从中取得就OK。</p><hr><p>refer：<br><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架</a></p><p><a href="https://github.com/Luoyongjia/leetCode/tree/main/src/dynamicProgramming">Code</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般形式是求最值，比如说最长递增子序列，最小编辑距离。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;求最值，把所有的可行答案穷举出来，然后找最值就ok。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://luoyongjia.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月2日</title>
    <link href="https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/</id>
    <published>2021-01-02T15:04:58.000Z</published>
    <updated>2021-03-06T12:00:52.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Object类</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><p>Object类太难了，套娃一样，lei了。从Object到String到Integer…希望明天能简单一点。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>方法有问题，明日改方法。希望每天的时间能够均匀一点，不要总扑在一件事情上。明天中午睡觉不脱裤子，不然又会睡过，今天中午就睡了一个半小时，起床之后还泡了一杯奶茶…但是还是消除不了Object带来的心累。害，明天一定不会这么苦，希望拥有正常的作息。☕️</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>letcode中的3题，一定要开始！</li><li>Java两个类的使用</li><li>剑指offer的2题</li><li>练字</li></ol><hr><p>今天又是鸽子精，希望明天能做不咕鸟🐦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Object类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;过程中</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/"/>
    <id>https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/</id>
    <published>2021-01-02T14:59:11.000Z</published>
    <updated>2021-01-02T15:07:15.747Z</updated>
    
    <content type="html"><![CDATA[<p><em>java.lang.Object</em></p><p>是一个根类，是老祖宗。</p><p>lang包不用导入，直接使用。</p><h2 id="boolean-equals-object-obj"><a href="#boolean-equals-object-obj" class="headerlink" title="boolean equals(object obj)"></a>boolean equals(object obj)</h2><p>判断对象的地址是否相等。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean myEquals(MyObject obj)&#123;</span><br><span class="line">return this &#x3D;&#x3D; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这里<code>==</code>比较的是两个对象在内存中的地址。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.equals(anOtherObject);</span><br></pre></td></tr></table></figure><h3 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals()和==的区别"></a><code>equals()</code>和<code>==</code>的区别</h3><ol><li><code>equals()</code>是方法，<code>==</code>是操作符</li><li><code>==</code>能用于基本类型变量(byte, short, int, long, float, double)，但是<code>equals()</code>不能，<code>equals()</code>只能用于继承Object类的类的对象。</li><li><code>==</code>在基本类型变量的比较过程中比较的是基本类型变量值，<code>==</code>、<code>equale()</code>在对象的比较中都是比较的地址。可以将<code>equals()</code>重写来使其比较值。</li></ol><h3 id="对于String类的equals-重写"><a href="#对于String类的equals-重写" class="headerlink" title="对于String类的equals()重写"></a>对于String类的<code>equals()</code>重写</h3><h4 id="重写euqals-应该遵循JavaSE的通用约定"><a href="#重写euqals-应该遵循JavaSE的通用约定" class="headerlink" title="重写euqals()应该遵循JavaSE的通用约定"></a>重写<code>euqals()</code>应该遵循JavaSE的通用约定</h4><blockquote><ol><li>自反性（reflexive）：对于任何非<code>null</code>引用值<code>x</code>，<code>x.equals(x)</code>必须返回<code>true</code><br></li><li>对称性（symmetric）：对于任何非<code>null</code>引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>返回<code>true</code>时，<code>y.equals(x)</code>返回<code>true</code><br></li><li>传递性（transitive）: 对于任何非<code>null</code>的引用值<code>x</code>, <code>y</code>和<code>z</code>， 如果<code>x.equals(y)</code>返回<code>true</code>, 并且<code>y.equals(z)</code>也返回<code>true</code>, 那么<code>x.equals(z)</code>也必须返回true。<br></li><li>一致性（consistent）: 对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>, 只要<code>equals()</code>的比较操作在对象中所用的信息没有被修改，多次调用<code>x.equals(y)</code>就会一致的返回<code>true</code>, 或者一致的返回<code>false</code>。</li><li>对于任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>必须返回<code>false</code>。</li></ol></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>我搜了搜原码，发现在String类中的<code>equals()</code>没有写<code>@Override</code>，然后就去搜了一下，发现<code>@Override</code>是伪代码，可写可不写的，写上可以方便阅读、适合编译器给你检查。</p><p>String类中<code>private final char[] value</code>存储输入的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject)&#123;</span><br><span class="line">&#x2F;&#x2F;判断地址是否相同</span><br><span class="line">if(this &#x3D;&#x3D; anObject)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(anObject instanceof String)&#123;</span><br><span class="line">String anOtherString &#x3D; (String) anObject;</span><br><span class="line">int n &#x3D; value.length;</span><br><span class="line">&#x2F;&#x2F;判断长度是否相同</span><br><span class="line">if(n &#x3D;&#x3D; anOtherString.value.length)&#123;</span><br><span class="line">char v1[] &#x3D; value;</span><br><span class="line">char v2[] &#x3D; anOtherString.value;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">while(n-- !&#x3D; 0)&#123;</span><br><span class="line">if(v1[i] !&#x3D; v2[i])</span><br><span class="line">return false;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当所有都比对过之后跳出while</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当传入的Object都不是String类的情况</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="final-native-Class-lt-gt-getClass"><a href="#final-native-Class-lt-gt-getClass" class="headerlink" title="final native Class&lt;?&gt; getClass();"></a>final native Class&lt;?&gt; getClass();</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>返回的是当前引用指向的实例的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        TestClass test1 &#x3D; new TestClass();</span><br><span class="line">        Object test2 &#x3D; new TestClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;test1 class &#x3D; &quot; + test1.getClass());</span><br><span class="line">        System.out.println(&quot;test2 class &#x3D; &quot; + test2.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1 class &#x3D; class src.TestClass</span><br><span class="line">test2 class &#x3D; class src.TestClass</span><br></pre></td></tr></table></figure><h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><p>native是与C++联合开发时去使用的。使用native关键字说明这个方法是原生函数，也就是这个方法使用C/C++语言实现的，并且被便衣成了dll，由java去调用。</p><h3 id="C-源码"><a href="#C-源码" class="headerlink" title="C++源码"></a>C++源码</h3><p>挖坑</p><h2 id="native-int-hashCode"><a href="#native-int-hashCode" class="headerlink" title="native int hashCode();"></a>native int hashCode();</h2><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.hashCode();</span><br></pre></td></tr></table></figure><h3 id="C-源码-1"><a href="#C-源码-1" class="headerlink" title="C++源码"></a>C++源码</h3><p>挖坑</p><h3 id="重写hashCode-方法"><a href="#重写hashCode-方法" class="headerlink" title="重写hashCode()方法"></a>重写<code>hashCode()</code>方法</h3><h4 id="应该遵循JavaSE的通用约定"><a href="#应该遵循JavaSE的通用约定" class="headerlink" title="应该遵循JavaSE的通用约定"></a>应该遵循JavaSE的通用约定</h4><blockquote><ol><li>在应用程序的执行期间，只要对象的<code>equals()</code>的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次<code>hashCode()</code>，它必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同。<br></li><li>如果两个对象根据<code>equals(Object)</code>方法是相等的，那么调用这两个对象中任一个对象的<code>hashCode()</code>必须产生同样的整数结果。<br></li><li>如果两个对象根据<code>equals(Object)</code>是不相等的，那么调用这两个对象中任一个对象的<code>hashCode()</code>，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li></ol></blockquote><p>所以根据第<strong>2</strong>条可以看出，重写了<code>equals()</code>方法之后必须重写<code>hashCode()</code>方法，这两个方法相互对应。</p><h4 id="String重写hashCode-方法"><a href="#String重写hashCode-方法" class="headerlink" title="String重写hashCode()方法"></a>String重写<code>hashCode()</code>方法</h4><p>在原String类中，其直接改变了hashCode的生成方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()&#123;</span><br><span class="line">&#x2F;&#x2F;hash的默认值为0，为String类的一个private属性</span><br><span class="line">int h &#x3D; hash;</span><br><span class="line">&#x2F;&#x2F;当String实例中value不为空时，hashCode根据value的内容产生</span><br><span class="line">if(h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0)&#123;</span><br><span class="line">char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 0; i &lt; value.length; i++)&#123;</span><br><span class="line">h &#x3D; 31 * h + val[i];</span><br><span class="line">&#125;</span><br><span class="line">hash &#x3D; h;</span><br><span class="line">&#125;</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String-toString"><a href="#String-toString" class="headerlink" title="String toString()"></a>String toString()</h2><p>把对象中的值以字符串的形式展示出来</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>套中套中套中套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;哈希码转String</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;Integer类</span><br><span class="line">&#x2F;&#x2F;toHexString(int i)方法</span><br><span class="line">public static String toHexString(int i)&#123;</span><br><span class="line">return toUsignedString0(i, 4);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">* toUnsignedString0方法</span><br><span class="line">     * Convert the integer to an unsigned number.</span><br><span class="line">     * 将一群数字变成String</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String toUnsignedString0(int val, int shift)&#123;</span><br><span class="line"> &#x2F;&#x2F;assert shift &gt;  0 &amp;&amp; shift &lt;&#x3D; 5 : &quot;Illegal shift value&quot;;</span><br><span class="line"> &#x2F;&#x2F;删除头部的0</span><br><span class="line"> int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);</span><br><span class="line"> &#x2F;&#x2F;私以为：判断一共有几位（一位有shift个码），最小为1</span><br><span class="line"> int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);</span><br><span class="line"> &#x2F;&#x2F;创建字符串容器了，用来装输出的String</span><br><span class="line"> char[] buf &#x3D; new char[chars];</span><br><span class="line"> </span><br><span class="line"> formatUnsignedInt(val, shift, buf, 0, chars);</span><br><span class="line"> </span><br><span class="line"> return new String(buf, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line">将一串unsigned数据转换为字符串</span><br><span class="line">val, 需要被转换的unsigned int</span><br><span class="line">     shift，分组的过程(4 for hex, 3 for octal, 1 for binary)</span><br><span class="line">     buf, 存储内容的对应2^shift进制的数字</span><br><span class="line">     offset，开始读val的位置</span><br><span class="line">     len，要写入的char的数量</span><br><span class="line">     return 写入第一个char的下标</span><br><span class="line">*&#x2F;</span><br><span class="line">static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)&#123;</span><br><span class="line">int charPos &#x3D; len;</span><br><span class="line">&#x2F;&#x2F;得到对应进制的掩码</span><br><span class="line">&#x2F;&#x2F;eg: 16-&gt;1 0000</span><br><span class="line">int radix &#x3D; 1 &lt;&lt; shift;</span><br><span class="line">&#x2F;&#x2F;1 0000 - 1 -&gt; 1111</span><br><span class="line">int mask &#x3D; radix - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当val非空且还有未读的位时</span><br><span class="line">do&#123;</span><br><span class="line">&#x2F;&#x2F;将当前位置的值与掩码做比较，存下这一位的值</span><br><span class="line">buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask];</span><br><span class="line">&#x2F;&#x2F;下一位，val右移shif位</span><br><span class="line">val &gt;&gt;&gt;&#x3D; shift;</span><br><span class="line">&#125;while(val !&#x3D; 0 &amp;&amp; charPos &gt; 0)</span><br><span class="line"></span><br><span class="line">return charPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;就是一个进制转换表</span><br><span class="line">final static char[] digits &#x3D; &#123;</span><br><span class="line">        &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; ,</span><br><span class="line">        &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; ,</span><br><span class="line">        &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; ,</span><br><span class="line">        &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; ,</span><br><span class="line">        &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; ,</span><br><span class="line">        &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>普通的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objectName.toString()</span><br><span class="line"></span><br><span class="line">return: className@地址</span><br></pre></td></tr></table></figure><p>重写了hashCode的类，可能也会重写这个函数，这个函数主要还是根据哈希值来得到内容的。</p><hr><h6 id="refer："><a href="#refer：" class="headerlink" title="refer："></a>refer：</h6><p> <a href="https://juejin.cn/post/6844903862587883527">JDK源码阅读（一）：Object源码分析</a></p><p> <a href="https://hellofrank.github.io/2019/09/21/%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99Java%E7%9A%84equals%E6%96%B9%E6%B3%95/?utm_source=tuicool&amp;utm_medium=referral">说说如何重写Java的equals方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;java.lang.Object&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是一个根类，是老祖宗。&lt;/p&gt;
&lt;p&gt;lang包不用导入，直接使用。&lt;/p&gt;
&lt;h2 id=&quot;boolean-equals-object-obj&quot;&gt;&lt;a href=&quot;#boolean-equals-objec</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="常用类" scheme="https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月1日</title>
    <link href="https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/</id>
    <published>2021-01-01T16:14:30.000Z</published>
    <updated>2021-01-03T15:45:17.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>年度计划（永远立不起来的flag）</li><li>Java基础语法</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><p>无，详情请见<a href="Java基础语法以及易忽略点总结">Java基础语法以及易忽略点总结</a></p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天睡得很开心，中午也睡了午觉。任务太多了，完不成。所以决定调整计划，明天希望过得轻松一点。空调温度果然还是需要调高一点，下午20度真的冻死我了。（附：还是好想去自习室，元旦特惠没有了，有点可惜）。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><p>flag永不倒！！！！</p><ul><li>找2个类学学</li><li>英语听力</li><li>leetcode-3个题</li><li><strong>开题报告开题报告开题报告开题报告</strong></li><li>剑指offer2个题</li><li>练字</li></ul><hr><p>明天一定是 <strong>不 咕 鸟</strong>🐦！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;年度计划（永远立不起来的flag）&lt;/li&gt;
&lt;li&gt;Jav</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础语法以及易忽略点总结</title>
    <link href="https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-01T16:09:10.000Z</published>
    <updated>2021-01-01T16:10:40.570Z</updated>
    
    <content type="html"><![CDATA[<p><strong>非常主观 非常主观 非常主观！</strong></p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>基本类型： byte, short, int, long, float, double, char, boolean<br>（low —— high）<br>引用类型：类，接口，数组</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在运算中，不同类型的数据都会先转化为较高的那一类，然后再进行运算</p><p>而由高转低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((低类型) 变量名) </span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java是一种强类型语言，也就是说每个东西都要有它明确的属性，不像Js、Python。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>个人jio得这个可以去康康我之前那篇<a href="https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">由JVM内存划分与职能到值传递和引用传递</a>。这里就做一个简单的描述。</p><p><strong>静态变量：</strong>也就是类变量，当类加载时就存在的变量，只加载一次，不能改变。</p><p><strong>实例变量：</strong>也就是成员变量，在类实例化时加载，存在那个实例里面。</p><p><strong>局部变量：</strong>一次性变量，即用即删。生存周期同存在的方法时间相同。</p><p>数字里面可以带<code>_</code>，更容易理解，JDK新功能。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>就是特殊的变量，在程序运行过程中保持不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Type name &#x3D; xxx;</span><br></pre></td></tr></table></figure><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>不要以<code>_</code>或<code>$</code>开始或者结束。不要用拼音（除非国际通用的国内代名词）。</p><p><strong>类名</strong> 开头大写的驼峰式。</p><p><strong>方法名、参数名、成员变量、局部变量</strong> 同一使用开头小写的驼峰式。</p><p><strong>常量</strong> 全部大写，单词之间用<code>_</code>隔开。</p><p>抽象类用<code>Abstract</code>或<code>Base</code>开头；异常类用<code>Exception</code>结尾；测试类用<code>Test</code>结尾。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>a++</strong> 先加，再拿a进行操作</p><p><strong>++a</strong> 先拿a进行操作，再加</p><p><strong>—</strong> 同理</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>&amp;</strong> 将两个数字都转换为二进制后，两个数字在当位上都为1时此位为1，否则则为0</p><p><strong>|</strong> 两个数字在当位上只需要有一个为1，则此位为1。</p><p><strong>^</strong> 当两个数字当位上的数字不一样，则为1，相同则为0</p><p><strong>～</strong> 当前数字二进制取逆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; 0011 1001</span><br><span class="line">B &#x3D; 0000 0101</span><br><span class="line"></span><br><span class="line">A &amp; B &#x3D; 0000 0001</span><br><span class="line">A | B &#x3D; 0011 1101</span><br><span class="line">A ^ B &#x3D; 0011 1100</span><br><span class="line">~B &#x3D; 1111 1010</span><br></pre></td></tr></table></figure><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p><strong>&lt;&lt;</strong> 向左移，高位溢出舍弃高位。补码啊…我都忘记了，等我机组学到这里再来补。负数无符号右移，用1填补。正数用0填补。</p><p><strong>&gt;&gt;</strong> 向右移，同&lt;&lt;</p><p><strong>&gt;&gt;&gt;</strong> 无符号版本，都是补0</p><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>导包： import</p><p>命名：通常用域名的倒置座位包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg: www.baidu.com</span><br><span class="line">包的格式就为：com.baidu.www</span><br></pre></td></tr></table></figure><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><p>生成文档，超级6。文档注释。<br>首先来个<code>Doc.java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*</span><br><span class="line">* @author name</span><br><span class="line">* @ version 1.0</span><br><span class="line">* @since 1.8 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Doc&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*</span><br><span class="line">* @author xxx</span><br><span class="line">* @param name</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">public String test(String name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中/**回车自动生成。</p><p>主要的有些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@author</span><br><span class="line">@version</span><br><span class="line">@sincejdk支持的最老版本</span><br><span class="line">@palam参数名</span><br><span class="line">@return</span><br><span class="line">@throw异常抛出</span><br></pre></td></tr></table></figure><p>然后命令行当前路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charaset UTF-8 Doc.java</span><br></pre></td></tr></table></figure><p><code>javadoc</code>生成文档命令。</p><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>来自于<code>java.util.Scanner</code>的输入</p><p>Scanner对象的常用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scanner.next()&#x2F;&#x2F;读取输入的字符，空格断开</span><br><span class="line">scanner.nextLine()&#x2F;&#x2F;读取当前行的输入</span><br><span class="line">scanner.hasNext()&#x2F;&#x2F;判断之后还有没有输入</span><br><span class="line">scanner.hasNextLine()&#x2F;&#x2F;判断是否还有下一行的输入</span><br><span class="line">&#x2F;&#x2F;next后还可以加基本类名，则限定输入的类</span><br></pre></td></tr></table></figure><h3 id="Scanner读取规则"><a href="#Scanner读取规则" class="headerlink" title="Scanner读取规则"></a>Scanner读取规则</h3><p><strong>next()</strong> 要读到有效字符后的第一个空格或者换行符后结束。光标指向此空格之后</p><p><strong>nextLine()</strong> 读完一行之后，光标指向下一行的开头</p><h3 id="scanner-close"><a href="#scanner-close" class="headerlink" title="scanner.close()"></a>scanner.close()</h3><p><strong>慎用！慎用！慎用！</strong></p><p>只要调用了这个函数后，之后新建的Scanner对象就无效了。但是也不能忘记在程序的结尾处，开了几个Scanner就关几个Scanner。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>VSCode还不知道怎么搞，坑先挖这儿吧。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>就是名称相同，通过输入的参数的类型不同而调用不同的方法的功能。（写好几个相同名字的方法）</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>你是否还记得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中的args，这里就是用来实现命令行参数的，先在当前路径<code>javac **.java</code>编译。然后退到<code>src</code>文件夹（根文件夹）再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java 此文件所在的相对位置.**.class 输入输入输入</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在参数的最后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType ...a)</span><br></pre></td></tr></table></figure><p>就可以输入多个这个类型的参数。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>动态数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] name &#x3D; new dataType[size];</span><br><span class="line">dataType[][] name1 &#x3D; new dataType[rowNum][colNum];</span><br></pre></td></tr></table></figure><p>初始化为0..</p><p>静态数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] name2 &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">dataType[][] name3 &#x3D; &#123;&#123;1, 2&#125;,&#123;3, 4&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法之间的调用"><a href="#方法之间的调用" class="headerlink" title="方法之间的调用"></a>方法之间的调用</h3><p>当两个方法都为静态方法或者非静态方法的时候，它们之间可以相互调用，但一个静态一个非静态时，不可以相互调用。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ClassName();</span><br></pre></td></tr></table></figure><p>当重写了构造器（有输入）之后需要重写一个没输入的才能实现继承。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>假设现在这里有<code>Father</code>类，<code>Son</code>类继承<code>Father</code>类。假设他们都有<code>eat()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father fater &#x3D; new Son();</span><br><span class="line">Son son &#x3D; new Son();</span><br><span class="line"></span><br><span class="line">father.eat();&#x2F;&#x2F;执行的是son中的eat</span><br><span class="line">son.eat();&#x2F;&#x2F;执行的是son中的eat</span><br></pre></td></tr></table></figure><p><code>Father</code>类引用只能调用<code>Father</code>类中存在的方法，<code>father</code>不能调用<code>Son</code>中独有的方法。两个类都有的方法调用实例化那个类的方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>类之间是否存在关系。<br>父子ok，对象作实例化类来判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A instance of B</span><br></pre></td></tr></table></figure><h2 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h2><p>执行顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">&#x2F;&#x2F; 静态代码块</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 匿名代码块</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;非常主观 非常主观 非常主观！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;p&gt;基本类型： byte, short, int, long, </summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020年12月31日</title>
    <link href="https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/</id>
    <published>2020-12-31T16:37:41.000Z</published>
    <updated>2021-01-03T15:45:30.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>hexo上传图片问题</li><li>Java基础语法</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><h3 id="hexo上传本地图片"><a href="#hexo上传本地图片" class="headerlink" title="hexo上传本地图片"></a>hexo上传本地图片</h3><p>在尝试调用url无效之后，开始打起了装插件的想法，没想到又是个大坑。不过终究是解决了。</p><h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>修改<strong>根目录</strong>的<code>_config.ym</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder:true</span><br></pre></td></tr></table></figure><h4 id="Step-2-安装正确版本的插件"><a href="#Step-2-安装正确版本的插件" class="headerlink" title="Step 2 安装正确版本的插件"></a>Step 2 安装正确版本的插件</h4><p>注意注意注意，我直接安装<code>hexo-asset-image</code>出现了图片被多加了一个/的问题，再搜，发现是这个包的问题，尝试了改<code>index.js</code>，发现无效，所以就卸载了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unisntall -g hexo-asset-image</span><br></pre></td></tr></table></figure><p>然后安装正确版本<code>hexo-asset-image-0.0.5.git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save</span><br></pre></td></tr></table></figure><h4 id="Step-3-插入图片🎉"><a href="#Step-3-插入图片🎉" class="headerlink" title="Step 3 插入图片🎉"></a>Step 3 插入图片🎉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![1](文章名字对应文件夹&#x2F;图片名)</span><br></pre></td></tr></table></figure><h3 id="Java内容明日再更新，之后再加链接到这里"><a href="#Java内容明日再更新，之后再加链接到这里" class="headerlink" title="Java内容明日再更新，之后再加链接到这里"></a>Java内容明日再更新，之后再加链接到这里</h3><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>其实一上午都没有学习，因为起得晚，再🐟一下就到十点了，好像因为晚上睡得晚，导致早上也起不来…无解。有点想去自习室，但是爹妈就是不同意，不知道为什么。新的一年到来了，希望一切都能变得好起来。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>Java基础过完</li><li>新年计划（今天真的太困了…只能咕）</li><li>Java基础的blog总结一下</li><li>开题报告开题报告开题报告！</li><li>练字</li><li>letcode-3题（or more）</li></ol><hr><h6 id="refer：hexo本地图片不显示"><a href="#refer：hexo本地图片不显示" class="headerlink" title="refer：hexo本地图片不显示"></a>refer：<a href="http://www.theoak.online/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/">hexo本地图片不显示</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;hexo上传图片问题&lt;/li&gt;
&lt;li&gt;Java基础语法&lt;/</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>由JVM内存划分与职能到值传递和引用传递</title>
    <link href="https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2020-12-31T14:52:00.000Z</published>
    <updated>2021-01-01T03:43:56.656Z</updated>
    
    <content type="html"><![CDATA[<p>课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。</p><h2 id="JVM内存划分与职能"><a href="#JVM内存划分与职能" class="headerlink" title="JVM内存划分与职能"></a>JVM内存划分与职能</h2><p>在java第一课中我们认识到了java程序都是运行在jvm上的，那jvm里面到底干了些什么呢？这里给出一个更加详细的程序执行图</p><p><img src="/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/1.png" alt="figer1"></p><h3 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h3><p>由图可以得出，当java代码被翻译成字节码后，jvm开辟了一片新的内存空间（运行时数据区），下面依次来介绍其中的功能。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>方法被执行的地方，虚拟基站中存放着栈帧，方法调用的过程对应着栈帧在虚拟机中入栈到出栈的过程。</p><p>栈时私有的，也就是线程之间栈是隔离的。当程序某个线程开始执行一个方法，就会创建一个栈帧并入栈（于栈顶），方法结束后，栈帧出栈</p><p>下图为Java栈的模型及栈帧的组成：</p><p><img src="/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/2.png" alt="figer2"></p><p><strong>局部变量表：</strong>储存方法中的局部变量，变量为基本数据类型时，存储值，变量为引用类时，存储引用类对象的地址</p><p><strong>操作数栈：</strong>Java虚拟机的解释执行引擎常被称为<strong>“基于栈的执行引擎”</strong>，其中的栈为这个操作栈</p><p><strong>指向运行时常量池的引用：</strong>可能用到的常量的<strong>引用</strong></p><p><strong>方法返回地址：</strong>存储方法执行完之后的返回地址</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存储对象本身和数组，JVM中只有一个堆，所以堆是被所有线程共享的。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>一块线程共享的内存逻辑区域，JVM中只有一个方法区，存放一些线程可共享的内容。它是线程安全的，多个线程访问一个内容时，只有一个线程装载其数据，其他线程等待。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈和虚拟机栈功能大约相同，线程私有。它和虚拟机栈之间的差别在于它主要<strong>为本地方法服务</strong>而虚拟机栈为Java方法服务。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>线程私有。记录当前线程所执行的字节码（*.class）的行号和指示器。字节码解释器工作就是通过改变计数器的值来选去下一条需要执行的字节码指令。个人认为程序计数器实现了Java的解释型语言性质。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="数据基础知识"><a href="#数据基础知识" class="headerlink" title="数据基础知识"></a>数据基础知识</h3><blockquote><p>基本类型：byte, short, int, long, float, double, char, boolean </p><p>引用类型：类，接口，数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">public static PI &#x3D; 3.14;&#x2F;&#x2F;静态变量</span><br><span class="line">private int name;&#x2F;&#x2F;成员变量</span><br><span class="line"></span><br><span class="line">public void static main(String[] args)&#123;</span><br><span class="line">int a;&#x2F;&#x2F;局部变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(int num1, int num2)&#123;</span><br><span class="line">int sum &#x3D; 0;&#x2F;&#x2F;局部变量</span><br><span class="line">sum &#x3D; num1 + num2;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据在内存中存储方法"><a href="#数据在内存中存储方法" class="headerlink" title="数据在内存中存储方法"></a>数据在内存中存储方法</h3><h4 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>直接存储在内存中的栈上，也就是之前提到过的“虚拟机栈”。</p><p>所以当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>也就是class中的一些属性变量，这些变量的生命周期同对象是一致的。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>当类开始纯在，静态变量就储存在了堆中，当类被消灭的时候，它们才会被消灭。</p><h4 id="引用数据"><a href="#引用数据" class="headerlink" title="引用数据"></a>引用数据</h4><p>引用数据传入时，传入的是存放变量内容的地址。</p><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>可以简单的理解为上面对于成员变量的定义，一次性的变量。</p><p>当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。</p><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>很好理解，就是将存变量值的堆中的地址给传进方法了，所以方法中对于传入的变量的更改实质上就是更改那个地址中存储的内容，一改则全改。<br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        person.setName(&quot;小红&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">p.setName(&quot;小明&quot;);</span><br><span class="line">PersonCrossTest(p);</span><br><span class="line">System.out.println(&quot;方法执行后的name: &quot; + p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：小明</span><br><span class="line">方法内重新赋值后的name：小红</span><br><span class="line">方法执行后的name：小红</span><br></pre></td></tr></table></figure><p><strong>在那篇博客中还发现了一片很好玩的问题：</strong></p><p>还是刚刚那段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        &#x2F;&#x2F;改变的地方</span><br><span class="line">        person &#x3D; new Person();</span><br><span class="line">        person.setName(&quot;小红&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">p.setName(&quot;小明&quot;);</span><br><span class="line">PersonCrossTest(p);</span><br><span class="line">System.out.println(&quot;方法执行后的name: &quot; + p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方在PersonCrossTest方法里，person由原来指向<code>小明</code>的<strong>地址1</strong>改为了在方法中new Person()创建的临时的一个Person对象的<strong>地址2</strong>，在PersonCrossTest方法结束时<strong>地址2</strong>就被删除了，<strong>地址1</strong>中的内容并没有改变。</p><p>所以说，这里的引用传递其实是一个虚假的引用传递，不过是在栈帧中创建了一个变量存储传进来变量的地址。</p><hr><p>终于写完了，今天就只加个总结吧，Java基础内容明日再更。</p><h6 id="refer-这一次，彻底解决Java的值传递和引用传递"><a href="#refer-这一次，彻底解决Java的值传递和引用传递" class="headerlink" title="refer:这一次，彻底解决Java的值传递和引用传递"></a>refer:<a href="https://segmentfault.com/a/1190000016773324">这一次，彻底解决Java的值传递和引用传递</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。&lt;/p&gt;
&lt;h2 id=&quot;JVM内存划分与职能&quot;&gt;&lt;a href=&quot;#JVM内存划分与职能&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的Java第一课</title>
    <link href="https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <id>https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/</id>
    <published>2020-12-30T15:31:50.000Z</published>
    <updated>2020-12-31T03:42:56.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="不同的java"><a href="#不同的java" class="headerlink" title="不同的java"></a>不同的java</h3><p><strong>JavaSE</strong>: 标准版，适用于桌面程序与控制台的开发</p><p><strong>JavaME</strong>: 嵌入式开发</p><p><strong>JavaEE</strong>: 企业级开发，如Web服务器</p><p><strong>动态性、多线程</strong></p><p><strong>Write Once, Run Anywhere</strong></p><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><h4 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h4><p>简单的来说，就是一个虚拟机，java程序都是基于这个虚拟机来跑的。</p><p>正是这个虚拟机使得Java能够屏蔽底层的差异，实现跨平台开发</p><h4 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE(Java Runtime Environment)"></a>JRE(Java Runtime Environment)</h4><p>包，JRE提供了Java的类库，其中包含了JVM</p><h4 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK(Java Development Kit)"></a>JDK(Java Development Kit)</h4><p>开发者需要的东西，其中包括了很多开发工具</p><p>所以综上所述，它们仨的关系可以用这个图来表示： </p><p><img src="/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/jjjRelation.jpg" alt="test"></p><p>接下来就开始上机操作了</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>袜，这个真的，也有一点坑，我在<a href="https://www.oracle.com/index.html">官网</a>上找了好久才找到下载的地方。这里直接<a href="https://www.oracle.com/java/technologies/javase-downloads.html">指路</a>吧。选择自己相应的版本然后注册（登陆）oracle账号就👌。</p><p>然后配置环境变量（<em>仅限mac</em>）。打开终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk你的版本.jdk&#x2F;Contents&#x2F;Home</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.</span><br><span class="line">CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>最后用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java-version</span><br></pre></td></tr></table></figure><p>看java版本是不是跟自己的jdk装的版本一样就🉑️了</p><h3 id="JDK内部探秘"><a href="#JDK内部探秘" class="headerlink" title="JDK内部探秘"></a>JDK内部探秘</h3><p>因为课里面讲了一点，所以也记了一下。就几个主要的文件夹。</p><p><strong>\bin</strong> 可执行的程序，比如说java、javac的运行程序就在这里面</p><p><strong>\include</strong> 因为Java是基于C、C++的嘛，这里面就有调用的一些C、C++的包</p><p><strong>\jre</strong> 运行环境</p><p><strong>\lib</strong> Java的库</p><p><strong>\src</strong> 一些Java类</p><p>我感觉这一块儿还不是太懂，之后有更深入了解了再来补充与修改</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><h3 id="文本编辑器版本"><a href="#文本编辑器版本" class="headerlink" title="文本编辑器版本"></a>文本编辑器版本</h3><p>创建Hello.java<br>写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后命令行进入对应文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java</span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure><h5 id="这里就出现一个问题了，为什么要先javac，然后再java呢"><a href="#这里就出现一个问题了，为什么要先javac，然后再java呢" class="headerlink" title="这里就出现一个问题了，为什么要先javac，然后再java呢"></a>这里就出现一个问题了，为什么要先<code>javac</code>，然后再<code>java</code>呢</h5><p>这就不得不说一下Java的运行机制了。Java是集编译型与解释型的语言。<code>javac</code>就是起编译器的作用。生成字节码<code>Hello.class</code>，然后再进行之后的操作</p><p><img src="/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/2.png" alt></p><h3 id="VSCode版本"><a href="#VSCode版本" class="headerlink" title="VSCode版本"></a>VSCode版本</h3><h4 id="step-1-下载插件"><a href="#step-1-下载插件" class="headerlink" title="step 1 下载插件"></a>step 1 下载插件</h4><ul><li>Language Support for Java™ by Red Hat</li><li>Debugger for Java</li><li>Java Test Runner</li><li>Maven for Java</li><li>Java Dependency Viewer</li><li>Java Extension Pack</li></ul><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p><code>Ctrl+Shift+P</code>输入<code>Java: Configure Java Runtime</code>修改默认JDK版本与路径</p><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><p>可以开始创建工程，输入代码，然后run辣</p><h4 id="其中遇见了一个奇葩问题"><a href="#其中遇见了一个奇葩问题" class="headerlink" title="其中遇见了一个奇葩问题"></a>其中遇见了一个奇葩问题</h4><p>我看课程中使用IDEA写的，在<code>project/src/pakageName</code>中直接写代码就能跑，但是在VSCode中不一样，需要在<code>*.java</code>文件的开头添加<code>package src.pakageName;</code></p><p>具体是什么原因我也不大清楚，先记下来吧。</p><h6 id="Refer：Java-JDK-JRE-and-JVM"><a href="#Refer：Java-JDK-JRE-and-JVM" class="headerlink" title="Refer：Java JDK, JRE and JVM"></a>Refer：<a href="https://www.programiz.com/java-programming/jvm-jre-jdk">Java JDK, JRE and JVM</a></h6><hr><p>太懒了，图片先不整了，有缘再整</p><p>图片调整好辣，今天晚上一定要记一下这个坑</p><p>配置就到这儿啦，希望明天能过完基础语法🤡</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;不同的java&quot;&gt;&lt;a href=&quot;#不同的java&quot; class=&quot;headerlink&quot; title=&quot;不同的</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020年12月30日</title>
    <link href="https://luoyongjia.github.io/2020/12/30/12-30/"/>
    <id>https://luoyongjia.github.io/2020/12/30/12-30/</id>
    <published>2020-12-30T14:31:54.000Z</published>
    <updated>2021-01-03T15:45:45.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>昨天规划的大约的工作安排做了</li><li>git就只学会了初始化，上传这样子</li><li>Java环境搭建，以及写了个hello world</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>就是从一个空白项目怎么配置到本地这样子</p><blockquote><p>先创建一个空白的文件夹，我习惯是创建一个同名的，然后进入此文件夹的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com: ...&#x2F;&#x2F;...是项目的路径</span><br><span class="line">git add .</span><br><span class="line">git push -u origin master&#x2F;&#x2F;这里要注意此电脑是master</span><br></pre></td></tr></table></figure><p>或者用这种方法，在<code>git add .</code>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>这样子就是main路径了。</p><p>删除了user文件夹下初始化过的<code>.gith</code>文件夹，vscode的sourceControl终于不现实5k+ changes了，我就觉得肯定是因为有个<code>.git</code>的问题</p></blockquote><h3 id="Java开发相关的问题"><a href="#Java开发相关的问题" class="headerlink" title="Java开发相关的问题"></a>Java开发相关的问题</h3><p>这个我想重新写一篇<a href="https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/">blog</a>来更全面的描述。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今日没有出门学习，感觉在家果然还是有点🐟的。也还行吧，早上起来床了，任务也完成得七七八八。Java的课上着感觉有点简单，但是还是跟着上下去吧，熟悉的就2倍速，不熟悉的再仔细听，我怕出现那种像高数课一样，突然什么都听不懂了。还是希望明天能够更高效吧。搞这些整得我觉得手机都不好玩了，真好。明天想要写一个年度总结，不知道有没有时间，或许就同日记一起写了，但是我觉得这俩还是有挺大区别的，日记主要还是记一下当日遇见的问题以及解决的方法。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>letcode中的3题</li><li>Java语法学完（这个任务视难度而调整）</li><li>剑指offer-2题</li><li>至少把自己的开题报告好好康康</li><li>练字练字练字！</li></ol><hr><p><strong>每天都要开心哦🥳</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;昨天规划的大约的工作安排做了&lt;/li&gt;
&lt;li&gt;git就只学会了初始化，上传这样子&lt;/l</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>春招准备规划【实时更新】</title>
    <link href="https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/"/>
    <id>https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/</id>
    <published>2020-12-30T04:02:12.000Z</published>
    <updated>2020-12-30T06:04:17.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="春招准备规划【实时更新】"><a href="#春招准备规划【实时更新】" class="headerlink" title="春招准备规划【实时更新】"></a>春招准备规划【实时更新】</h2><h3 id="第一阶段（12-30-1-31）"><a href="#第一阶段（12-30-1-31）" class="headerlink" title="第一阶段（12.30-1.31）"></a>第一阶段（12.30-1.31）</h3><h4 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h4><h5 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h5><p>这里采用剑指offer中的题和算法面试题汇总结合，每天做一定量（2+3）</p><p><strong>手写代码手写代码手写代码！</strong></p><h5 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h5><p>上网课同时实践</p><h5 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h5><p>看书+练题</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>针对性，手写代码。</p><p>目标：历届的笔试面试题</p><p>通过小公司面试积累经验，先从小公司开始</p><p>说话能力</p><h4 id="每日任务"><a href="#每日任务" class="headerlink" title="每日任务"></a>每日任务</h4><ol><li>3+2 算法题</li><li>网络一课</li><li>机组一课</li><li>英语听力</li><li>练字</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;春招准备规划【实时更新】&quot;&gt;&lt;a href=&quot;#春招准备规划【实时更新】&quot; class=&quot;headerlink&quot; title=&quot;春招准备规划【实时更新】&quot;&gt;&lt;/a&gt;春招准备规划【实时更新】&lt;/h2&gt;&lt;h3 id=&quot;第一阶段（12-30-1-31）&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="规划" scheme="https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
</feed>
