<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gugugu&#39;s blog</title>
  
  
  <link href="https://luoyongjia.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyongjia.github.io/"/>
  <updated>2021-01-03T15:52:06.734Z</updated>
  <id>https://luoyongjia.github.io/</id>
  
  <author>
    <name>罗咏佳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021年1月3日</title>
    <link href="https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/</id>
    <published>2021-01-03T15:43:55.000Z</published>
    <updated>2021-01-03T15:52:06.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Character类、Math类、Number类</li><li>动态规划问题，三道题</li><li>练字</li></ul><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天感觉还是很充实的，虽然看下来没有做些什么，但是其实又做了一点什么。感觉需要上计网和机组了…想要找一点对应的题做，不知道去年的王道的书被我丢哪儿了…没事儿，从网上找点对应题应该也不错。今天发现了一个写leetCoded总结很好的项目，之后就跟这个吧。我感觉明天常用类也能差不多，感觉在常用类上耗太久了，之后边用边学吧。今天终于是不咕鸟了，早点休息，想要拥有正常的作息。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>leetcode一个专题</li><li>Java集合、IO</li><li>计网和机组</li><li>练字</li></ol><hr><p>♨️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Character类、Math类、Number类&lt;/li&gt;
</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划问题</title>
    <link href="https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-03T06:04:03.000Z</published>
    <updated>2021-01-03T09:06:02.478Z</updated>
    
    <content type="html"><![CDATA[<p>一般形式是求最值，比如说最长递增子序列，最小编辑距离。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>求最值，把所有的可行答案穷举出来，然后找最值就ok。</p><p><em>动态规划</em>不是简单的穷举，因为动态规划问题存在<strong>「重叠子问题」</strong>，暴力穷举会效率很低，所以需要「备忘录」或者「DP table」来优化穷举的过程，避免不必要的计算。</p><p>并且动态规划一定会具备<strong>「最优子结构」</strong>，才能通过子问题的最值的到原问题的最值。<br>需要列出正确的<strong>「状态转移方程」</strong>才能正确的穷举。在实际的算法问题中，写出「状态转移方程」是最困难的。所以提供了一个思维框架辅助思考状态转移方程：</p><p><strong>明确base case -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义</strong></p><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h2><h3 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法"></a>暴力递归法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法十分的低效，假设n = 20，画出递归树：</p><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure1.png" alt="figure1"></p><p>PS：画出递归树是分析递归问题的好方法。</p><h4 id="递归算法的时间复杂度计算"><a href="#递归算法的时间复杂度计算" class="headerlink" title="递归算法的时间复杂度计算"></a>递归算法的时间复杂度计算</h4><p>首先计算子问题数，由图可以看出斐波那契数列是满二叉树，所以子问题的个数为<em>O(2^n)</em></p><p>然后计算每个子问题的时间，此算法没有循环，只有一个递归基和<code>f(n - 1) + f(n - 2)</code>，所以时间复杂度为<em>O(1)</em></p><p>递归算法的时间复杂度为子问题数 <script type="math/tex">\times</script> 子问题的时间。由此可得：斐波那契的暴力递归解法的时间复杂度为 <em>O(2^n)</em></p><p>观察递归树，可以发现：存在了大量的重复计算，比如<code>f(18)</code>被计算了两次，而<code>f(18)</code>为根的递归树体量巨大，多算一遍会耗费巨大的时间，在递归中出现了多次这样的情况，使得重复进行了多次相同的运算，使得这个算法十分低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。</p><h3 id="如何解决「重叠子问题」的问题"><a href="#如何解决「重叠子问题」的问题" class="headerlink" title="如何解决「重叠子问题」的问题"></a>如何解决「重叠子问题」的问题</h3><h4 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h4><p>我们可以造一个「备忘录」，每次计算出某个子问题的答案之后，先记入「备忘录」，然后再返回。每次遇到一个子问题先去「备忘录」中查查，如果发现已经解决过这个问题，就直接把答案拿出来用，就不用再次计算了。</p><p>一般使用数组充当这个「备忘录」，当然也可以用哈希表（字典）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int memoFib(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">&#x2F;&#x2F; 为了提高代码的可读性，所以开辟了n+1，这样每个fib数将会与相应的下标对应</span><br><span class="line">int[] memoArray() &#x3D; new int[n+1];</span><br><span class="line"></span><br><span class="line">return helper(memoArray(), n);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造memArray()</span><br><span class="line">public int memArray(int[] memo, int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line">if(memo[n] !&#x3D; 0)</span><br><span class="line">return memo[n];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归体</span><br><span class="line">memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2);</span><br><span class="line"></span><br><span class="line">return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><h4 id="dp数组迭代解法"><a href="#dp数组迭代解法" class="headerlink" title="dp数组迭代解法"></a>dp数组迭代解法</h4><p>有了上一步「备忘录」的启发，我们可以把「备忘录」独立出来成为一张表，就叫做DP table。在这张表上完成「自底向上」的推算岂不美哉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int dpTable(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构建dpTable</span><br><span class="line">int[] dp &#x3D; new int[n + 1];</span><br><span class="line">dp[1] &#x3D; 1;</span><br><span class="line">dp[2] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">dp[i] &#x3D; dp[i - 1] + dp[1 - 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure2.jpg" alt="figure2"></p><p><strong>「状态转移方程」</strong>：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}1, n = 1,2 \\f(n-1) + f(n-2), n>2 \\\end{aligned}\right.</script><p>这里把<code>f(n)</code>想做状态<code>n</code>，状态<code>n</code>是由状态<code>n-1</code>和状态<code>n-2</code>相加转移而来的，这就叫状态转移。</p><p>所以要先想出暴力解，然后通过暴力解的到转移方程，再通过备忘录或者DP table优化。</p><p><strong>fib还可以优化</strong><br>甚至不需要整个dpTable，只需要记载n，n-1，n-2三个值就ok，此时的复杂度降到了<em>O(1)</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int bestFib(int n)&#123;</span><br><span class="line">int num1 &#x3D; 1;</span><br><span class="line">int num2 &#x3D; 1;</span><br><span class="line">int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">num &#x3D; num1 + num2;</span><br><span class="line">num1 &#x3D; num2;</span><br><span class="line">num2 &#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法叫做「状态压缩」，当我们发现状态转移时只需要用上DP table中的一部分，那样就可以尝试用状态压缩来缩小DP table。</p><h2 id="322-凑零钱"><a href="#322-凑零钱" class="headerlink" title="322.凑零钱"></a>322.凑零钱</h2><p>题目：给你<code>k</code>中面值的硬币，面值分别为<code>c1, c2, ...,ck</code>，美中硬币的数量无限，再给一个总金额<code>amount</code>，问最少需要几枚硬币来凑出这个金额，如果凑不出，返回<code>-1</code>。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合<strong>「最优子结构」</strong>，<strong>子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p><p>比如说，假设考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><h3 id="如何列出正确的状态转移方程"><a href="#如何列出正确的状态转移方程" class="headerlink" title="如何列出正确的状态转移方程"></a>如何列出正确的状态转移方程</h3><ol><li><p><strong>确定 base case</strong>，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p><strong>确定「状态」</strong>，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p></li><li><strong>确定「选择」</strong>，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li><li><strong>明确 dp 函数/数组的定义</strong>。这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：</li></ol><p><code>dp(n)</code> ：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p><p>然后就可以得到状态转移方程</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}0, n=0 \\-1, n<0 \\min\{dg(n-coin) + 1|coin \in coins\}, n>0\end{aligned}\right.</script><h3 id="带备忘录的递归解法-1"><a href="#带备忘录的递归解法-1" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public int getCoinsMemo(int[] coins, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int[] memo &#x3D; new int[n + 1];</span><br><span class="line">    return helper(coins, memo, n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public int helper(int[] coins, int[] memo, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[n] !&#x3D; 0)</span><br><span class="line">        return memo[n];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;得到当💰需要的coin数</span><br><span class="line">    int cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int coinNum &#x3D; 0;</span><br><span class="line">    for (int coin : coins) &#123;</span><br><span class="line">        coinNum &#x3D; helper(coins, memo, n - coin);</span><br><span class="line">        &#x2F;&#x2F; 当小于0或者这个子方法表示不出的时候</span><br><span class="line">        if (n - coin &lt; 0 || coinNum &#x3D;&#x3D; -1)</span><br><span class="line">            continue;</span><br><span class="line">        if (coinNum + 1 &lt; cur) &#123;</span><br><span class="line">            cur &#x3D; coinNum + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cur &#x3D;&#x3D; Integer.MAX_VALUE)&#123;</span><br><span class="line">        cur &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] &#x3D; cur;</span><br><span class="line">    return cur;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自底向上的DPtable方法"><a href="#自底向上的DPtable方法" class="headerlink" title="自底向上的DPtable方法"></a>自底向上的DPtable方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自底向上DPtable方法</span><br><span class="line">public int getCoinsDP(int[] coins, int sum) &#123;</span><br><span class="line">    if (sum &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if (sum &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp[] &#x3D; new int[sum + 1];</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    int cur;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; sum; i++) &#123;</span><br><span class="line">        cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            if (i - coin &lt; 0 || dp[i - coin] &#x3D;&#x3D; -1)</span><br><span class="line">                continue;</span><br><span class="line">            if (dp[i - coin] + 1 &lt; cur)</span><br><span class="line">                cur &#x3D; dp[i - coin] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur &#x3D;&#x3D; Integer.MAX_VALUE)</span><br><span class="line">            dp[i] &#x3D; -1;</span><br><span class="line">        else</span><br><span class="line">            dp[i] &#x3D; cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就是那个步骤：</p><p><strong>明确base case（递归基） -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 -&gt;优化</strong></p><h3 id="「备忘录」自上而下的方法"><a href="#「备忘录」自上而下的方法" class="headerlink" title="「备忘录」自上而下的方法"></a>「备忘录」自上而下的方法</h3><p>其实就是一种递归的优化方法，消除了很多重复计算的部分，所以优化了方法，但是还是没有自下而上好。</p><h3 id="「DPtable」自下而上的方法"><a href="#「DPtable」自下而上的方法" class="headerlink" title="「DPtable」自下而上的方法"></a>「DPtable」自下而上的方法</h3><p>当我们分析出「状态转移方程」后，就可以自下而上构造<code>dp[]</code>（其实就是备忘录），然后直接从中取得就OK。</p><hr><p>refer：<br><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架</a></p><p><a href="https://github.com/Luoyongjia/leetCode/tree/main/src/dynamicProgramming">Code</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般形式是求最值，比如说最长递增子序列，最小编辑距离。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;求最值，把所有的可行答案穷举出来，然后找最值就ok。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://luoyongjia.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月2日</title>
    <link href="https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/</id>
    <published>2021-01-02T15:04:58.000Z</published>
    <updated>2021-01-02T15:14:24.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Object类</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><p>Object类太难了，套娃一样，lei了。从Object到String到Integer…希望明天能简单一点。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>方法有问题，明日改方法。希望每天的时间能够均匀一点，不要总扑在一件事情上。明天中午睡觉不脱裤子，不然又会睡过，今天中午就睡了一个半小时，起床之后还泡了一杯奶茶…但是还是消除不了Object带来的心累。害，明天一定不会这么苦，希望拥有正常的作息。☕️</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>letcode中的3题，一定要开始！</li><li>Java两个类的使用</li><li>剑指offer的2题</li><li>练字</li></ol><hr><p>今天又是鸽子精，希望明天能做不咕鸟🐦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Object类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;过程中</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="瞎写" scheme="https://luoyongjia.github.io/tags/%E7%9E%8E%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/"/>
    <id>https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/</id>
    <published>2021-01-02T14:59:11.000Z</published>
    <updated>2021-01-02T15:07:15.747Z</updated>
    
    <content type="html"><![CDATA[<p><em>java.lang.Object</em></p><p>是一个根类，是老祖宗。</p><p>lang包不用导入，直接使用。</p><h2 id="boolean-equals-object-obj"><a href="#boolean-equals-object-obj" class="headerlink" title="boolean equals(object obj)"></a>boolean equals(object obj)</h2><p>判断对象的地址是否相等。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean myEquals(MyObject obj)&#123;</span><br><span class="line">return this &#x3D;&#x3D; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这里<code>==</code>比较的是两个对象在内存中的地址。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.equals(anOtherObject);</span><br></pre></td></tr></table></figure><h3 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals()和==的区别"></a><code>equals()</code>和<code>==</code>的区别</h3><ol><li><code>equals()</code>是方法，<code>==</code>是操作符</li><li><code>==</code>能用于基本类型变量(byte, short, int, long, float, double)，但是<code>equals()</code>不能，<code>equals()</code>只能用于继承Object类的类的对象。</li><li><code>==</code>在基本类型变量的比较过程中比较的是基本类型变量值，<code>==</code>、<code>equale()</code>在对象的比较中都是比较的地址。可以将<code>equals()</code>重写来使其比较值。</li></ol><h3 id="对于String类的equals-重写"><a href="#对于String类的equals-重写" class="headerlink" title="对于String类的equals()重写"></a>对于String类的<code>equals()</code>重写</h3><h4 id="重写euqals-应该遵循JavaSE的通用约定"><a href="#重写euqals-应该遵循JavaSE的通用约定" class="headerlink" title="重写euqals()应该遵循JavaSE的通用约定"></a>重写<code>euqals()</code>应该遵循JavaSE的通用约定</h4><blockquote><ol><li>自反性（reflexive）：对于任何非<code>null</code>引用值<code>x</code>，<code>x.equals(x)</code>必须返回<code>true</code><br></li><li>对称性（symmetric）：对于任何非<code>null</code>引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>返回<code>true</code>时，<code>y.equals(x)</code>返回<code>true</code><br></li><li>传递性（transitive）: 对于任何非<code>null</code>的引用值<code>x</code>, <code>y</code>和<code>z</code>， 如果<code>x.equals(y)</code>返回<code>true</code>, 并且<code>y.equals(z)</code>也返回<code>true</code>, 那么<code>x.equals(z)</code>也必须返回true。<br></li><li>一致性（consistent）: 对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>, 只要<code>equals()</code>的比较操作在对象中所用的信息没有被修改，多次调用<code>x.equals(y)</code>就会一致的返回<code>true</code>, 或者一致的返回<code>false</code>。</li><li>对于任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>必须返回<code>false</code>。</li></ol></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>我搜了搜原码，发现在String类中的<code>equals()</code>没有写<code>@Override</code>，然后就去搜了一下，发现<code>@Override</code>是伪代码，可写可不写的，写上可以方便阅读、适合编译器给你检查。</p><p>String类中<code>private final char[] value</code>存储输入的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject)&#123;</span><br><span class="line">&#x2F;&#x2F;判断地址是否相同</span><br><span class="line">if(this &#x3D;&#x3D; anObject)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(anObject instanceof String)&#123;</span><br><span class="line">String anOtherString &#x3D; (String) anObject;</span><br><span class="line">int n &#x3D; value.length;</span><br><span class="line">&#x2F;&#x2F;判断长度是否相同</span><br><span class="line">if(n &#x3D;&#x3D; anOtherString.value.length)&#123;</span><br><span class="line">char v1[] &#x3D; value;</span><br><span class="line">char v2[] &#x3D; anOtherString.value;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">while(n-- !&#x3D; 0)&#123;</span><br><span class="line">if(v1[i] !&#x3D; v2[i])</span><br><span class="line">return false;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当所有都比对过之后跳出while</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当传入的Object都不是String类的情况</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="final-native-Class-lt-gt-getClass"><a href="#final-native-Class-lt-gt-getClass" class="headerlink" title="final native Class&lt;?&gt; getClass();"></a>final native Class&lt;?&gt; getClass();</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>返回的是当前引用指向的实例的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        TestClass test1 &#x3D; new TestClass();</span><br><span class="line">        Object test2 &#x3D; new TestClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;test1 class &#x3D; &quot; + test1.getClass());</span><br><span class="line">        System.out.println(&quot;test2 class &#x3D; &quot; + test2.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1 class &#x3D; class src.TestClass</span><br><span class="line">test2 class &#x3D; class src.TestClass</span><br></pre></td></tr></table></figure><h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><p>native是与C++联合开发时去使用的。使用native关键字说明这个方法是原生函数，也就是这个方法使用C/C++语言实现的，并且被便衣成了dll，由java去调用。</p><h3 id="C-源码"><a href="#C-源码" class="headerlink" title="C++源码"></a>C++源码</h3><p>挖坑</p><h2 id="native-int-hashCode"><a href="#native-int-hashCode" class="headerlink" title="native int hashCode();"></a>native int hashCode();</h2><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.hashCode();</span><br></pre></td></tr></table></figure><h3 id="C-源码-1"><a href="#C-源码-1" class="headerlink" title="C++源码"></a>C++源码</h3><p>挖坑</p><h3 id="重写hashCode-方法"><a href="#重写hashCode-方法" class="headerlink" title="重写hashCode()方法"></a>重写<code>hashCode()</code>方法</h3><h4 id="应该遵循JavaSE的通用约定"><a href="#应该遵循JavaSE的通用约定" class="headerlink" title="应该遵循JavaSE的通用约定"></a>应该遵循JavaSE的通用约定</h4><blockquote><ol><li>在应用程序的执行期间，只要对象的<code>equals()</code>的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次<code>hashCode()</code>，它必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同。<br></li><li>如果两个对象根据<code>equals(Object)</code>方法是相等的，那么调用这两个对象中任一个对象的<code>hashCode()</code>必须产生同样的整数结果。<br></li><li>如果两个对象根据<code>equals(Object)</code>是不相等的，那么调用这两个对象中任一个对象的<code>hashCode()</code>，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li></ol></blockquote><p>所以根据第<strong>2</strong>条可以看出，重写了<code>equals()</code>方法之后必须重写<code>hashCode()</code>方法，这两个方法相互对应。</p><h4 id="String重写hashCode-方法"><a href="#String重写hashCode-方法" class="headerlink" title="String重写hashCode()方法"></a>String重写<code>hashCode()</code>方法</h4><p>在原String类中，其直接改变了hashCode的生成方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()&#123;</span><br><span class="line">&#x2F;&#x2F;hash的默认值为0，为String类的一个private属性</span><br><span class="line">int h &#x3D; hash;</span><br><span class="line">&#x2F;&#x2F;当String实例中value不为空时，hashCode根据value的内容产生</span><br><span class="line">if(h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0)&#123;</span><br><span class="line">char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 0; i &lt; value.length; i++)&#123;</span><br><span class="line">h &#x3D; 31 * h + val[i];</span><br><span class="line">&#125;</span><br><span class="line">hash &#x3D; h;</span><br><span class="line">&#125;</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String-toString"><a href="#String-toString" class="headerlink" title="String toString()"></a>String toString()</h2><p>把对象中的值以字符串的形式展示出来</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>套中套中套中套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;哈希码转String</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;Integer类</span><br><span class="line">&#x2F;&#x2F;toHexString(int i)方法</span><br><span class="line">public static String toHexString(int i)&#123;</span><br><span class="line">return toUsignedString0(i, 4);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">* toUnsignedString0方法</span><br><span class="line">     * Convert the integer to an unsigned number.</span><br><span class="line">     * 将一群数字变成String</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String toUnsignedString0(int val, int shift)&#123;</span><br><span class="line"> &#x2F;&#x2F;assert shift &gt;  0 &amp;&amp; shift &lt;&#x3D; 5 : &quot;Illegal shift value&quot;;</span><br><span class="line"> &#x2F;&#x2F;删除头部的0</span><br><span class="line"> int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);</span><br><span class="line"> &#x2F;&#x2F;私以为：判断一共有几位（一位有shift个码），最小为1</span><br><span class="line"> int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);</span><br><span class="line"> &#x2F;&#x2F;创建字符串容器了，用来装输出的String</span><br><span class="line"> char[] buf &#x3D; new char[chars];</span><br><span class="line"> </span><br><span class="line"> formatUnsignedInt(val, shift, buf, 0, chars);</span><br><span class="line"> </span><br><span class="line"> return new String(buf, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line">将一串unsigned数据转换为字符串</span><br><span class="line">val, 需要被转换的unsigned int</span><br><span class="line">     shift，分组的过程(4 for hex, 3 for octal, 1 for binary)</span><br><span class="line">     buf, 存储内容的对应2^shift进制的数字</span><br><span class="line">     offset，开始读val的位置</span><br><span class="line">     len，要写入的char的数量</span><br><span class="line">     return 写入第一个char的下标</span><br><span class="line">*&#x2F;</span><br><span class="line">static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)&#123;</span><br><span class="line">int charPos &#x3D; len;</span><br><span class="line">&#x2F;&#x2F;得到对应进制的掩码</span><br><span class="line">&#x2F;&#x2F;eg: 16-&gt;1 0000</span><br><span class="line">int radix &#x3D; 1 &lt;&lt; shift;</span><br><span class="line">&#x2F;&#x2F;1 0000 - 1 -&gt; 1111</span><br><span class="line">int mask &#x3D; radix - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当val非空且还有未读的位时</span><br><span class="line">do&#123;</span><br><span class="line">&#x2F;&#x2F;将当前位置的值与掩码做比较，存下这一位的值</span><br><span class="line">buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask];</span><br><span class="line">&#x2F;&#x2F;下一位，val右移shif位</span><br><span class="line">val &gt;&gt;&gt;&#x3D; shift;</span><br><span class="line">&#125;while(val !&#x3D; 0 &amp;&amp; charPos &gt; 0)</span><br><span class="line"></span><br><span class="line">return charPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;就是一个进制转换表</span><br><span class="line">final static char[] digits &#x3D; &#123;</span><br><span class="line">        &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; ,</span><br><span class="line">        &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; ,</span><br><span class="line">        &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; ,</span><br><span class="line">        &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; ,</span><br><span class="line">        &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; ,</span><br><span class="line">        &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>普通的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objectName.toString()</span><br><span class="line"></span><br><span class="line">return: className@地址</span><br></pre></td></tr></table></figure><p>重写了hashCode的类，可能也会重写这个函数，这个函数主要还是根据哈希值来得到内容的。</p><hr><h6 id="refer："><a href="#refer：" class="headerlink" title="refer："></a>refer：</h6><p> <a href="https://juejin.cn/post/6844903862587883527">JDK源码阅读（一）：Object源码分析</a></p><p> <a href="https://hellofrank.github.io/2019/09/21/%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99Java%E7%9A%84equals%E6%96%B9%E6%B3%95/?utm_source=tuicool&amp;utm_medium=referral">说说如何重写Java的equals方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;java.lang.Object&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是一个根类，是老祖宗。&lt;/p&gt;
&lt;p&gt;lang包不用导入，直接使用。&lt;/p&gt;
&lt;h2 id=&quot;boolean-equals-object-obj&quot;&gt;&lt;a href=&quot;#boolean-equals-objec</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="常用类" scheme="https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月1日</title>
    <link href="https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/</id>
    <published>2021-01-01T16:14:30.000Z</published>
    <updated>2021-01-03T15:45:17.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>年度计划（永远立不起来的flag）</li><li>Java基础语法</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><p>无，详情请见<a href="Java基础语法以及易忽略点总结">Java基础语法以及易忽略点总结</a></p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天睡得很开心，中午也睡了午觉。任务太多了，完不成。所以决定调整计划，明天希望过得轻松一点。空调温度果然还是需要调高一点，下午20度真的冻死我了。（附：还是好想去自习室，元旦特惠没有了，有点可惜）。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><p>flag永不倒！！！！</p><ul><li>找2个类学学</li><li>英语听力</li><li>leetcode-3个题</li><li><strong>开题报告开题报告开题报告开题报告</strong></li><li>剑指offer2个题</li><li>练字</li></ul><hr><p>明天一定是 <strong>不 咕 鸟</strong>🐦！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;年度计划（永远立不起来的flag）&lt;/li&gt;
&lt;li&gt;Jav</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础语法以及易忽略点总结</title>
    <link href="https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-01T16:09:10.000Z</published>
    <updated>2021-01-01T16:10:40.570Z</updated>
    
    <content type="html"><![CDATA[<p><strong>非常主观 非常主观 非常主观！</strong></p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>基本类型： byte, short, int, long, float, double, char, boolean<br>（low —— high）<br>引用类型：类，接口，数组</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在运算中，不同类型的数据都会先转化为较高的那一类，然后再进行运算</p><p>而由高转低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((低类型) 变量名) </span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java是一种强类型语言，也就是说每个东西都要有它明确的属性，不像Js、Python。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>个人jio得这个可以去康康我之前那篇<a href="https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">由JVM内存划分与职能到值传递和引用传递</a>。这里就做一个简单的描述。</p><p><strong>静态变量：</strong>也就是类变量，当类加载时就存在的变量，只加载一次，不能改变。</p><p><strong>实例变量：</strong>也就是成员变量，在类实例化时加载，存在那个实例里面。</p><p><strong>局部变量：</strong>一次性变量，即用即删。生存周期同存在的方法时间相同。</p><p>数字里面可以带<code>_</code>，更容易理解，JDK新功能。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>就是特殊的变量，在程序运行过程中保持不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Type name &#x3D; xxx;</span><br></pre></td></tr></table></figure><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>不要以<code>_</code>或<code>$</code>开始或者结束。不要用拼音（除非国际通用的国内代名词）。</p><p><strong>类名</strong> 开头大写的驼峰式。</p><p><strong>方法名、参数名、成员变量、局部变量</strong> 同一使用开头小写的驼峰式。</p><p><strong>常量</strong> 全部大写，单词之间用<code>_</code>隔开。</p><p>抽象类用<code>Abstract</code>或<code>Base</code>开头；异常类用<code>Exception</code>结尾；测试类用<code>Test</code>结尾。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>a++</strong> 先加，再拿a进行操作</p><p><strong>++a</strong> 先拿a进行操作，再加</p><p><strong>—</strong> 同理</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>&amp;</strong> 将两个数字都转换为二进制后，两个数字在当位上都为1时此位为1，否则则为0</p><p><strong>|</strong> 两个数字在当位上只需要有一个为1，则此位为1。</p><p><strong>^</strong> 当两个数字当位上的数字不一样，则为1，相同则为0</p><p><strong>～</strong> 当前数字二进制取逆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; 0011 1001</span><br><span class="line">B &#x3D; 0000 0101</span><br><span class="line"></span><br><span class="line">A &amp; B &#x3D; 0000 0001</span><br><span class="line">A | B &#x3D; 0011 1101</span><br><span class="line">A ^ B &#x3D; 0011 1100</span><br><span class="line">~B &#x3D; 1111 1010</span><br></pre></td></tr></table></figure><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p><strong>&lt;&lt;</strong> 向左移，高位溢出舍弃高位。补码啊…我都忘记了，等我机组学到这里再来补。负数无符号右移，用1填补。正数用0填补。</p><p><strong>&gt;&gt;</strong> 向右移，同&lt;&lt;</p><p><strong>&gt;&gt;&gt;</strong> 无符号版本，都是补0</p><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>导包： import</p><p>命名：通常用域名的倒置座位包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg: www.baidu.com</span><br><span class="line">包的格式就为：com.baidu.www</span><br></pre></td></tr></table></figure><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><p>生成文档，超级6。文档注释。<br>首先来个<code>Doc.java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*</span><br><span class="line">* @author name</span><br><span class="line">* @ version 1.0</span><br><span class="line">* @since 1.8 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Doc&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*</span><br><span class="line">* @author xxx</span><br><span class="line">* @param name</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">public String test(String name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中/**回车自动生成。</p><p>主要的有些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@author</span><br><span class="line">@version</span><br><span class="line">@sincejdk支持的最老版本</span><br><span class="line">@palam参数名</span><br><span class="line">@return</span><br><span class="line">@throw异常抛出</span><br></pre></td></tr></table></figure><p>然后命令行当前路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charaset UTF-8 Doc.java</span><br></pre></td></tr></table></figure><p><code>javadoc</code>生成文档命令。</p><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>来自于<code>java.util.Scanner</code>的输入</p><p>Scanner对象的常用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scanner.next()&#x2F;&#x2F;读取输入的字符，空格断开</span><br><span class="line">scanner.nextLine()&#x2F;&#x2F;读取当前行的输入</span><br><span class="line">scanner.hasNext()&#x2F;&#x2F;判断之后还有没有输入</span><br><span class="line">scanner.hasNextLine()&#x2F;&#x2F;判断是否还有下一行的输入</span><br><span class="line">&#x2F;&#x2F;next后还可以加基本类名，则限定输入的类</span><br></pre></td></tr></table></figure><h3 id="Scanner读取规则"><a href="#Scanner读取规则" class="headerlink" title="Scanner读取规则"></a>Scanner读取规则</h3><p><strong>next()</strong> 要读到有效字符后的第一个空格或者换行符后结束。光标指向此空格之后</p><p><strong>nextLine()</strong> 读完一行之后，光标指向下一行的开头</p><h3 id="scanner-close"><a href="#scanner-close" class="headerlink" title="scanner.close()"></a>scanner.close()</h3><p><strong>慎用！慎用！慎用！</strong></p><p>只要调用了这个函数后，之后新建的Scanner对象就无效了。但是也不能忘记在程序的结尾处，开了几个Scanner就关几个Scanner。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>VSCode还不知道怎么搞，坑先挖这儿吧。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>就是名称相同，通过输入的参数的类型不同而调用不同的方法的功能。（写好几个相同名字的方法）</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>你是否还记得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中的args，这里就是用来实现命令行参数的，先在当前路径<code>javac **.java</code>编译。然后退到<code>src</code>文件夹（根文件夹）再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java 此文件所在的相对位置.**.class 输入输入输入</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在参数的最后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType ...a)</span><br></pre></td></tr></table></figure><p>就可以输入多个这个类型的参数。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>动态数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] name &#x3D; new dataType[size];</span><br><span class="line">dataType[][] name1 &#x3D; new dataType[rowNum][colNum];</span><br></pre></td></tr></table></figure><p>初始化为0..</p><p>静态数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] name2 &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">dataType[][] name3 &#x3D; &#123;&#123;1, 2&#125;,&#123;3, 4&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法之间的调用"><a href="#方法之间的调用" class="headerlink" title="方法之间的调用"></a>方法之间的调用</h3><p>当两个方法都为静态方法或者非静态方法的时候，它们之间可以相互调用，但一个静态一个非静态时，不可以相互调用。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ClassName();</span><br></pre></td></tr></table></figure><p>当重写了构造器（有输入）之后需要重写一个没输入的才能实现继承。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>假设现在这里有<code>Father</code>类，<code>Son</code>类继承<code>Father</code>类。假设他们都有<code>eat()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father fater &#x3D; new Son();</span><br><span class="line">Son son &#x3D; new Son();</span><br><span class="line"></span><br><span class="line">father.eat();&#x2F;&#x2F;执行的是son中的eat</span><br><span class="line">son.eat();&#x2F;&#x2F;执行的是son中的eat</span><br></pre></td></tr></table></figure><p><code>Father</code>类引用只能调用<code>Father</code>类中存在的方法，<code>father</code>不能调用<code>Son</code>中独有的方法。两个类都有的方法调用实例化那个类的方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>类之间是否存在关系。<br>父子ok，对象作实例化类来判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A instance of B</span><br></pre></td></tr></table></figure><h2 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h2><p>执行顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">&#x2F;&#x2F; 静态代码块</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 匿名代码块</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;非常主观 非常主观 非常主观！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;p&gt;基本类型： byte, short, int, long, </summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020年12月31日</title>
    <link href="https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/</id>
    <published>2020-12-31T16:37:41.000Z</published>
    <updated>2021-01-03T15:45:30.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>hexo上传图片问题</li><li>Java基础语法</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><h3 id="hexo上传本地图片"><a href="#hexo上传本地图片" class="headerlink" title="hexo上传本地图片"></a>hexo上传本地图片</h3><p>在尝试调用url无效之后，开始打起了装插件的想法，没想到又是个大坑。不过终究是解决了。</p><h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>修改<strong>根目录</strong>的<code>_config.ym</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder:true</span><br></pre></td></tr></table></figure><h4 id="Step-2-安装正确版本的插件"><a href="#Step-2-安装正确版本的插件" class="headerlink" title="Step 2 安装正确版本的插件"></a>Step 2 安装正确版本的插件</h4><p>注意注意注意，我直接安装<code>hexo-asset-image</code>出现了图片被多加了一个/的问题，再搜，发现是这个包的问题，尝试了改<code>index.js</code>，发现无效，所以就卸载了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unisntall -g hexo-asset-image</span><br></pre></td></tr></table></figure><p>然后安装正确版本<code>hexo-asset-image-0.0.5.git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save</span><br></pre></td></tr></table></figure><h4 id="Step-3-插入图片🎉"><a href="#Step-3-插入图片🎉" class="headerlink" title="Step 3 插入图片🎉"></a>Step 3 插入图片🎉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![1](文章名字对应文件夹&#x2F;图片名)</span><br></pre></td></tr></table></figure><h3 id="Java内容明日再更新，之后再加链接到这里"><a href="#Java内容明日再更新，之后再加链接到这里" class="headerlink" title="Java内容明日再更新，之后再加链接到这里"></a>Java内容明日再更新，之后再加链接到这里</h3><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>其实一上午都没有学习，因为起得晚，再🐟一下就到十点了，好像因为晚上睡得晚，导致早上也起不来…无解。有点想去自习室，但是爹妈就是不同意，不知道为什么。新的一年到来了，希望一切都能变得好起来。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>Java基础过完</li><li>新年计划（今天真的太困了…只能咕）</li><li>Java基础的blog总结一下</li><li>开题报告开题报告开题报告！</li><li>练字</li><li>letcode-3题（or more）</li></ol><hr><h6 id="refer：hexo本地图片不显示"><a href="#refer：hexo本地图片不显示" class="headerlink" title="refer：hexo本地图片不显示"></a>refer：<a href="http://www.theoak.online/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/">hexo本地图片不显示</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;hexo上传图片问题&lt;/li&gt;
&lt;li&gt;Java基础语法&lt;/</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>由JVM内存划分与职能到值传递和引用传递</title>
    <link href="https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2020-12-31T14:52:00.000Z</published>
    <updated>2021-01-01T03:43:56.656Z</updated>
    
    <content type="html"><![CDATA[<p>课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。</p><h2 id="JVM内存划分与职能"><a href="#JVM内存划分与职能" class="headerlink" title="JVM内存划分与职能"></a>JVM内存划分与职能</h2><p>在java第一课中我们认识到了java程序都是运行在jvm上的，那jvm里面到底干了些什么呢？这里给出一个更加详细的程序执行图</p><p><img src="/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/1.png" alt="figer1"></p><h3 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h3><p>由图可以得出，当java代码被翻译成字节码后，jvm开辟了一片新的内存空间（运行时数据区），下面依次来介绍其中的功能。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>方法被执行的地方，虚拟基站中存放着栈帧，方法调用的过程对应着栈帧在虚拟机中入栈到出栈的过程。</p><p>栈时私有的，也就是线程之间栈是隔离的。当程序某个线程开始执行一个方法，就会创建一个栈帧并入栈（于栈顶），方法结束后，栈帧出栈</p><p>下图为Java栈的模型及栈帧的组成：</p><p><img src="/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/2.png" alt="figer2"></p><p><strong>局部变量表：</strong>储存方法中的局部变量，变量为基本数据类型时，存储值，变量为引用类时，存储引用类对象的地址</p><p><strong>操作数栈：</strong>Java虚拟机的解释执行引擎常被称为<strong>“基于栈的执行引擎”</strong>，其中的栈为这个操作栈</p><p><strong>指向运行时常量池的引用：</strong>可能用到的常量的<strong>引用</strong></p><p><strong>方法返回地址：</strong>存储方法执行完之后的返回地址</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存储对象本身和数组，JVM中只有一个堆，所以堆是被所有线程共享的。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>一块线程共享的内存逻辑区域，JVM中只有一个方法区，存放一些线程可共享的内容。它是线程安全的，多个线程访问一个内容时，只有一个线程装载其数据，其他线程等待。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈和虚拟机栈功能大约相同，线程私有。它和虚拟机栈之间的差别在于它主要<strong>为本地方法服务</strong>而虚拟机栈为Java方法服务。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>线程私有。记录当前线程所执行的字节码（*.class）的行号和指示器。字节码解释器工作就是通过改变计数器的值来选去下一条需要执行的字节码指令。个人认为程序计数器实现了Java的解释型语言性质。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="数据基础知识"><a href="#数据基础知识" class="headerlink" title="数据基础知识"></a>数据基础知识</h3><blockquote><p>基本类型：byte, short, int, long, float, double, char, boolean </p><p>引用类型：类，接口，数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">public static PI &#x3D; 3.14;&#x2F;&#x2F;静态变量</span><br><span class="line">private int name;&#x2F;&#x2F;成员变量</span><br><span class="line"></span><br><span class="line">public void static main(String[] args)&#123;</span><br><span class="line">int a;&#x2F;&#x2F;局部变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(int num1, int num2)&#123;</span><br><span class="line">int sum &#x3D; 0;&#x2F;&#x2F;局部变量</span><br><span class="line">sum &#x3D; num1 + num2;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据在内存中存储方法"><a href="#数据在内存中存储方法" class="headerlink" title="数据在内存中存储方法"></a>数据在内存中存储方法</h3><h4 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>直接存储在内存中的栈上，也就是之前提到过的“虚拟机栈”。</p><p>所以当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>也就是class中的一些属性变量，这些变量的生命周期同对象是一致的。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>当类开始纯在，静态变量就储存在了堆中，当类被消灭的时候，它们才会被消灭。</p><h4 id="引用数据"><a href="#引用数据" class="headerlink" title="引用数据"></a>引用数据</h4><p>引用数据传入时，传入的是存放变量内容的地址。</p><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>可以简单的理解为上面对于成员变量的定义，一次性的变量。</p><p>当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。</p><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>很好理解，就是将存变量值的堆中的地址给传进方法了，所以方法中对于传入的变量的更改实质上就是更改那个地址中存储的内容，一改则全改。<br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        person.setName(&quot;小红&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">p.setName(&quot;小明&quot;);</span><br><span class="line">PersonCrossTest(p);</span><br><span class="line">System.out.println(&quot;方法执行后的name: &quot; + p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：小明</span><br><span class="line">方法内重新赋值后的name：小红</span><br><span class="line">方法执行后的name：小红</span><br></pre></td></tr></table></figure><p><strong>在那篇博客中还发现了一片很好玩的问题：</strong></p><p>还是刚刚那段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        &#x2F;&#x2F;改变的地方</span><br><span class="line">        person &#x3D; new Person();</span><br><span class="line">        person.setName(&quot;小红&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">p.setName(&quot;小明&quot;);</span><br><span class="line">PersonCrossTest(p);</span><br><span class="line">System.out.println(&quot;方法执行后的name: &quot; + p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方在PersonCrossTest方法里，person由原来指向<code>小明</code>的<strong>地址1</strong>改为了在方法中new Person()创建的临时的一个Person对象的<strong>地址2</strong>，在PersonCrossTest方法结束时<strong>地址2</strong>就被删除了，<strong>地址1</strong>中的内容并没有改变。</p><p>所以说，这里的引用传递其实是一个虚假的引用传递，不过是在栈帧中创建了一个变量存储传进来变量的地址。</p><hr><p>终于写完了，今天就只加个总结吧，Java基础内容明日再更。</p><h6 id="refer-这一次，彻底解决Java的值传递和引用传递"><a href="#refer-这一次，彻底解决Java的值传递和引用传递" class="headerlink" title="refer:这一次，彻底解决Java的值传递和引用传递"></a>refer:<a href="https://segmentfault.com/a/1190000016773324">这一次，彻底解决Java的值传递和引用传递</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。&lt;/p&gt;
&lt;h2 id=&quot;JVM内存划分与职能&quot;&gt;&lt;a href=&quot;#JVM内存划分与职能&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的Java第一课</title>
    <link href="https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <id>https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/</id>
    <published>2020-12-30T15:31:50.000Z</published>
    <updated>2020-12-31T03:42:56.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="不同的java"><a href="#不同的java" class="headerlink" title="不同的java"></a>不同的java</h3><p><strong>JavaSE</strong>: 标准版，适用于桌面程序与控制台的开发</p><p><strong>JavaME</strong>: 嵌入式开发</p><p><strong>JavaEE</strong>: 企业级开发，如Web服务器</p><p><strong>动态性、多线程</strong></p><p><strong>Write Once, Run Anywhere</strong></p><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><h4 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h4><p>简单的来说，就是一个虚拟机，java程序都是基于这个虚拟机来跑的。</p><p>正是这个虚拟机使得Java能够屏蔽底层的差异，实现跨平台开发</p><h4 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE(Java Runtime Environment)"></a>JRE(Java Runtime Environment)</h4><p>包，JRE提供了Java的类库，其中包含了JVM</p><h4 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK(Java Development Kit)"></a>JDK(Java Development Kit)</h4><p>开发者需要的东西，其中包括了很多开发工具</p><p>所以综上所述，它们仨的关系可以用这个图来表示： </p><p><img src="/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/jjjRelation.jpg" alt="test"></p><p>接下来就开始上机操作了</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>袜，这个真的，也有一点坑，我在<a href="https://www.oracle.com/index.html">官网</a>上找了好久才找到下载的地方。这里直接<a href="https://www.oracle.com/java/technologies/javase-downloads.html">指路</a>吧。选择自己相应的版本然后注册（登陆）oracle账号就👌。</p><p>然后配置环境变量（<em>仅限mac</em>）。打开终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk你的版本.jdk&#x2F;Contents&#x2F;Home</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.</span><br><span class="line">CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>最后用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java-version</span><br></pre></td></tr></table></figure><p>看java版本是不是跟自己的jdk装的版本一样就🉑️了</p><h3 id="JDK内部探秘"><a href="#JDK内部探秘" class="headerlink" title="JDK内部探秘"></a>JDK内部探秘</h3><p>因为课里面讲了一点，所以也记了一下。就几个主要的文件夹。</p><p><strong>\bin</strong> 可执行的程序，比如说java、javac的运行程序就在这里面</p><p><strong>\include</strong> 因为Java是基于C、C++的嘛，这里面就有调用的一些C、C++的包</p><p><strong>\jre</strong> 运行环境</p><p><strong>\lib</strong> Java的库</p><p><strong>\src</strong> 一些Java类</p><p>我感觉这一块儿还不是太懂，之后有更深入了解了再来补充与修改</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><h3 id="文本编辑器版本"><a href="#文本编辑器版本" class="headerlink" title="文本编辑器版本"></a>文本编辑器版本</h3><p>创建Hello.java<br>写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后命令行进入对应文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java</span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure><h5 id="这里就出现一个问题了，为什么要先javac，然后再java呢"><a href="#这里就出现一个问题了，为什么要先javac，然后再java呢" class="headerlink" title="这里就出现一个问题了，为什么要先javac，然后再java呢"></a>这里就出现一个问题了，为什么要先<code>javac</code>，然后再<code>java</code>呢</h5><p>这就不得不说一下Java的运行机制了。Java是集编译型与解释型的语言。<code>javac</code>就是起编译器的作用。生成字节码<code>Hello.class</code>，然后再进行之后的操作</p><p><img src="/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/2.png" alt></p><h3 id="VSCode版本"><a href="#VSCode版本" class="headerlink" title="VSCode版本"></a>VSCode版本</h3><h4 id="step-1-下载插件"><a href="#step-1-下载插件" class="headerlink" title="step 1 下载插件"></a>step 1 下载插件</h4><ul><li>Language Support for Java™ by Red Hat</li><li>Debugger for Java</li><li>Java Test Runner</li><li>Maven for Java</li><li>Java Dependency Viewer</li><li>Java Extension Pack</li></ul><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p><code>Ctrl+Shift+P</code>输入<code>Java: Configure Java Runtime</code>修改默认JDK版本与路径</p><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><p>可以开始创建工程，输入代码，然后run辣</p><h4 id="其中遇见了一个奇葩问题"><a href="#其中遇见了一个奇葩问题" class="headerlink" title="其中遇见了一个奇葩问题"></a>其中遇见了一个奇葩问题</h4><p>我看课程中使用IDEA写的，在<code>project/src/pakageName</code>中直接写代码就能跑，但是在VSCode中不一样，需要在<code>*.java</code>文件的开头添加<code>package src.pakageName;</code></p><p>具体是什么原因我也不大清楚，先记下来吧。</p><h6 id="Refer：Java-JDK-JRE-and-JVM"><a href="#Refer：Java-JDK-JRE-and-JVM" class="headerlink" title="Refer：Java JDK, JRE and JVM"></a>Refer：<a href="https://www.programiz.com/java-programming/jvm-jre-jdk">Java JDK, JRE and JVM</a></h6><hr><p>太懒了，图片先不整了，有缘再整</p><p>图片调整好辣，今天晚上一定要记一下这个坑</p><p>配置就到这儿啦，希望明天能过完基础语法🤡</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;不同的java&quot;&gt;&lt;a href=&quot;#不同的java&quot; class=&quot;headerlink&quot; title=&quot;不同的</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="编程" scheme="https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020年12月30日</title>
    <link href="https://luoyongjia.github.io/2020/12/30/12-30/"/>
    <id>https://luoyongjia.github.io/2020/12/30/12-30/</id>
    <published>2020-12-30T14:31:54.000Z</published>
    <updated>2021-01-03T15:45:45.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>昨天规划的大约的工作安排做了</li><li>git就只学会了初始化，上传这样子</li><li>Java环境搭建，以及写了个hello world</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>就是从一个空白项目怎么配置到本地这样子</p><blockquote><p>先创建一个空白的文件夹，我习惯是创建一个同名的，然后进入此文件夹的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com: ...&#x2F;&#x2F;...是项目的路径</span><br><span class="line">git add .</span><br><span class="line">git push -u origin master&#x2F;&#x2F;这里要注意此电脑是master</span><br></pre></td></tr></table></figure><p>或者用这种方法，在<code>git add .</code>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>这样子就是main路径了。</p><p>删除了user文件夹下初始化过的<code>.gith</code>文件夹，vscode的sourceControl终于不现实5k+ changes了，我就觉得肯定是因为有个<code>.git</code>的问题</p></blockquote><h3 id="Java开发相关的问题"><a href="#Java开发相关的问题" class="headerlink" title="Java开发相关的问题"></a>Java开发相关的问题</h3><p>这个我想重新写一篇<a href="https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/">blog</a>来更全面的描述。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今日没有出门学习，感觉在家果然还是有点🐟的。也还行吧，早上起来床了，任务也完成得七七八八。Java的课上着感觉有点简单，但是还是跟着上下去吧，熟悉的就2倍速，不熟悉的再仔细听，我怕出现那种像高数课一样，突然什么都听不懂了。还是希望明天能够更高效吧。搞这些整得我觉得手机都不好玩了，真好。明天想要写一个年度总结，不知道有没有时间，或许就同日记一起写了，但是我觉得这俩还是有挺大区别的，日记主要还是记一下当日遇见的问题以及解决的方法。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>letcode中的3题</li><li>Java语法学完（这个任务视难度而调整）</li><li>剑指offer-2题</li><li>至少把自己的开题报告好好康康</li><li>练字练字练字！</li></ol><hr><p><strong>每天都要开心哦🥳</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;昨天规划的大约的工作安排做了&lt;/li&gt;
&lt;li&gt;git就只学会了初始化，上传这样子&lt;/l</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>春招准备规划【实时更新】</title>
    <link href="https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/"/>
    <id>https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/</id>
    <published>2020-12-30T04:02:12.000Z</published>
    <updated>2020-12-30T06:04:17.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="春招准备规划【实时更新】"><a href="#春招准备规划【实时更新】" class="headerlink" title="春招准备规划【实时更新】"></a>春招准备规划【实时更新】</h2><h3 id="第一阶段（12-30-1-31）"><a href="#第一阶段（12-30-1-31）" class="headerlink" title="第一阶段（12.30-1.31）"></a>第一阶段（12.30-1.31）</h3><h4 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h4><h5 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h5><p>这里采用剑指offer中的题和算法面试题汇总结合，每天做一定量（2+3）</p><p><strong>手写代码手写代码手写代码！</strong></p><h5 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h5><p>上网课同时实践</p><h5 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h5><p>看书+练题</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>针对性，手写代码。</p><p>目标：历届的笔试面试题</p><p>通过小公司面试积累经验，先从小公司开始</p><p>说话能力</p><h4 id="每日任务"><a href="#每日任务" class="headerlink" title="每日任务"></a>每日任务</h4><ol><li>3+2 算法题</li><li>网络一课</li><li>机组一课</li><li>英语听力</li><li>练字</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;春招准备规划【实时更新】&quot;&gt;&lt;a href=&quot;#春招准备规划【实时更新】&quot; class=&quot;headerlink&quot; title=&quot;春招准备规划【实时更新】&quot;&gt;&lt;/a&gt;春招准备规划【实时更新】&lt;/h2&gt;&lt;h3 id=&quot;第一阶段（12-30-1-31）&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="规划" scheme="https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年12月29日</title>
    <link href="https://luoyongjia.github.io/2020/12/30/12-29%E6%97%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://luoyongjia.github.io/2020/12/30/12-29%E6%97%A5%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-29T16:44:36.000Z</published>
    <updated>2021-01-03T15:45:53.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>大约将博客搭起来了</li><li>了解了毕设中期需要做一些什么</li><li>开了蓝灯</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><h4 id="git在post的过程中出现帐号错误"><a href="#git在post的过程中出现帐号错误" class="headerlink" title="git在post的过程中出现帐号错误"></a>git在post的过程中出现帐号错误</h4><p>原因：当初作死，就想换个github帐号重新开始，导致电脑中默认的git帐号密码有问题</p><p>解决方法：不仅仅是说我使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -list \\查询信息</span><br><span class="line">git config --global  user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><p>就可以了的，在不同的系统下操作不同，我此仅代表mac用户。</p><p>还需要删除钥匙串访问中的<code>github.com</code>项</p><h4 id="关于hexo-pure主题配置的一堆破事"><a href="#关于hexo-pure主题配置的一堆破事" class="headerlink" title="关于hexo pure主题配置的一堆破事"></a>关于hexo pure主题配置的一堆破事</h4><p>所以在这里写下从头开始应该怎么配置pure主题，附上<a href="https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md">官方文档</a></p><h5 id="修改基本信息"><a href="#修改基本信息" class="headerlink" title="修改基本信息"></a>修改基本信息</h5><p>基本信息</p><blockquote><p><code>hexofolder\themes\hexo-theme-pure\source\images</code>中替换头像的那张图片，然后在<code>hexo-theme-pure\_config.ym</code>中配置</p></blockquote><p>icon</p><blockquote><p>删除了<code>hexofolder\themes\hexo-theme-pure\source\</code>中的<code>favicon.png</code>，然后在<code>images</code>文件夹下 添加了icon的图片，将<code>hexofolder\themes\hexo-theme-pure\_config.yml</code>中favicon对应的路径改成了<code>\images\favicon</code>。这真的是一个大坑，因为在hexo创建新的文章后路径上会加上日期，所以使用相对路径就会找不到icon图标</p></blockquote><p>comment</p><blockquote><p>这部分肥肠简单，我选择的是valine。大约步骤如下</p><ol><li>注册一个LeanCloud帐号</li><li>创建一个工程</li><li>在设置中找应用keys填进去</li><li>在安全中心添加blog的url</li></ol></blockquote><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>明明感觉自己做了很多事情，写起来又发现自己其实只做了一点点。毕设的中期答辩想要开始准备了，但是感觉还是无从下手。未来几个月怎么准备找工作的规划也还没做。可能是处理问题的速度太慢了。但是我也没有办法，只能慢慢来。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>做好找工作的整体安排，安排了当天就做点吧</li><li>写git的常用操作并实践</li><li>毕设的概要了解，工作量估计</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大约将博客搭起来了&lt;/li&gt;
&lt;li&gt;了解了毕设中期需要做一些什么&lt;/li&gt;
&lt;li&gt;开</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luoyongjia.github.io/2020/12/29/hello-world/"/>
    <id>https://luoyongjia.github.io/2020/12/29/hello-world/</id>
    <published>2020-12-29T06:07:19.495Z</published>
    <updated>2020-12-29T06:07:19.495Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
