<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gugugu&#39;s blog</title>
  
  
  <link href="https://luoyongjia.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyongjia.github.io/"/>
  <updated>2021-04-19T08:14:44.665Z</updated>
  <id>https://luoyongjia.github.io/</id>
  
  <author>
    <name>罗咏佳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【ML】Classification and Logistic Regression</title>
    <link href="https://luoyongjia.github.io/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/"/>
    <id>https://luoyongjia.github.io/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/</id>
    <published>2021-04-18T05:45:22.000Z</published>
    <updated>2021-04-19T08:14:44.665Z</updated>
    
    <content type="html"><![CDATA[<p>李宏毅机器学习笔记</p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>classification嘛，很好理解，就是分类问题。它和回归问题的最大差别在于，回归问题出来的结果是连续的，分类问题的结果是离散的。课中通过概率大约介绍了这个分类的过程。</p><h1 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h1><p>Input: 一个个体的各个特征。<br>Output: 把这个体分到哪一类。</p><h2 id="假设一个二分类的问题"><a href="#假设一个二分类的问题" class="headerlink" title="假设一个二分类的问题"></a>假设一个二分类的问题</h2><h3 id="Model-set"><a href="#Model-set" class="headerlink" title="Model set"></a>Model set</h3><p>现在有一个数据过来啦，我们怎么判断它是哪一类呢？</p><script type="math/tex; mode=display">P(C_{1}|x) = \frac{P(x|C_{1})P(C_{1})}{P(x|C_{1})P(C_{1}) + P(x|C_{2})P(C_{2})}</script><p>1 <script type="math/tex">P(C_{1}\mid x)</script>：当前有一个x，那么它是<script type="math/tex">C_{1}</script>类的可能性,<br>2 <script type="math/tex">P(C_{n})</script>：class n在整个数据集中占多大比例,<br>3 <script type="math/tex">P(x\mid C_{n})</script>：在class n中取到x的概率,         </p><p>所以这两个参数都是已知的，现在未知的只有<script type="math/tex">P(x|C_{1})</script>。通常我们假设这个class是一种分布，然后把x的feature值代进去，就可以取出来在这个模型的前提下，取到x到的概率是多少。</p><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>就是对于预测结果的一个放大。</p><p><img src="/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/1.png" alt="f1"></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><p>然后根据这个公式计算出的某个类作为预测结果，对于正确的个数求和（我觉得求百分比能够更加直观的看出效果），来评估预测效果。因为这个正确率我们是想要越大越好，而loss，求极小值为普遍方法，所以我们在loss之前加个负号。这里使用交叉熵loss。</p><script type="math/tex; mode=display">L = -[ylog\hat{y} +(1 - y)log(1 - \hat{y})]</script><h3 id="Optimition"><a href="#Optimition" class="headerlink" title="Optimition"></a>Optimition</h3><p>反正，我们到最后可以把这个离散的关系化做</p><script type="math/tex; mode=display">\sigma(wx + b)</script><p>然后还是用梯度下降。且，<script type="math/tex">\sigma(z)</script>只是一种代表的激活函数，激活函数之后会有一个总结。</p><h2 id="logistic-Regression"><a href="#logistic-Regression" class="headerlink" title="logistic Regression"></a>logistic Regression</h2><p>从上文化简之后，可以看出来也就是一个<script type="math/tex">wx + b</script>，就和linear regression很像了。怎么构造非线形的关系呢，激活函数。这种方法就是逻辑回归，用于分类。逻辑回归相较于线性回归，模型，loss不同，优化方法差不多。</p><p><img src="/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/2.png" alt="f2"></p><p>关系可以大概表示为这样子，是不是，很眼熟？？对，你想得没错，就是神经元，就是神经网络里面的神经元。</p><h3 id="feature-Transformation"><a href="#feature-Transformation" class="headerlink" title="feature Transformation"></a>feature Transformation</h3><p>有一些数据，他们原本的分布无法很好地进行分类，这时候就需要对他们进行调整。可以通过这种方法：</p><p><img src="/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/3.png" alt="f3"></p><p>诶嘿，是不是有神经网络那味儿了。神经网络其实就是隐藏层做一个好的特征提取器，跟这个差不多。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML20.html">李宏毅DL/ML</a></p><p>袜，过分，我几个公式调整了好久，发现一行没办法以latex公式开头。暂时还不知道怎么才能用latex作为头。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;李宏毅机器学习笔记&lt;/p&gt;
&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;classification嘛，很好理解，就是分类问题。它和回归问题的最大差别在于，回归问题出来的</summary>
      
    
    
    
    <category term="深度学习基础" scheme="https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>【ML】Gradient Descent</title>
    <link href="https://luoyongjia.github.io/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/"/>
    <id>https://luoyongjia.github.io/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/</id>
    <published>2021-04-12T13:39:07.000Z</published>
    <updated>2021-04-19T07:31:51.687Z</updated>
    
    <content type="html"><![CDATA[<p>李宏毅机器学习3-1笔记。</p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>是一种得到loss最优值的一种方法。</p><blockquote><ol><li>随机取一点</li><li>求这一点的梯度</li><li>根据梯度以及learning rate来更新参数<br><br>从而得到最小的loss==得到最佳的参数</li></ol></blockquote><h1 id="为什么有效"><a href="#为什么有效" class="headerlink" title="为什么有效"></a>为什么有效</h1><p>GD其实是通过取局部loss下降最多的点，来决定参数的变化方向的。</p><p><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/1.png" alt="f1"></p><h2 id="如何快速地取到这个局部最优呢？"><a href="#如何快速地取到这个局部最优呢？" class="headerlink" title="如何快速地取到这个局部最优呢？"></a>如何快速地取到这个局部最优呢？</h2><p>这时候就引入了泰勒公式，将一个复杂的函数在一个很小的范围内取：</p><script type="math/tex; mode=display">h(x) \approx h(x_{0}) + h'(x_{0})(x - x_{0})</script><p>假设u、v为loss对于两个参数的偏微分，则：</p><script type="math/tex; mode=display">L(\theta) \approx s + u(\theta_{1} - a) + v(\theta_{2} - b)</script><p>想要<script type="math/tex">L(\theta)</script>取得最小值，则如图所示<script type="math/tex">(\Delta \theta_{1}, \Delta \theta_{2})</script>取(u, v)反方向，最大值。所以Gradient Descent的过程是<script type="math/tex">\theta^{1}\gets \theta ^{0 } - \eta \Delta L</script></p><p><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/2.png" alt="f2"></p><h1 id="Gradient-Descent的升级版"><a href="#Gradient-Descent的升级版" class="headerlink" title="Gradient Descent的升级版"></a>Gradient Descent的升级版</h1><h2 id="基于Learning-Rate"><a href="#基于Learning-Rate" class="headerlink" title="基于Learning Rate"></a>基于Learning Rate</h2><p>Learning rate 这个东西，太大很可能得不到最优值，太小呢效率又低，所以选择一个正确的learning rate是十分重要的。</p><p><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/4.png" alt="f4"><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/3.png" alt="f3"></p><h3 id="Adaptive-Learning-Rate"><a href="#Adaptive-Learning-Rate" class="headerlink" title="Adaptive Learning Rate"></a>Adaptive Learning Rate</h3><p>这是基于随着梯度下降的进行，当前点距离最优解是越来越近的理论的。随着梯度下降的进行，learning rate随之减小，比如说像这样的learning rate：</p><script type="math/tex; mode=display">\eta^{t} = \frac{\eta}{\sqrt{n + 1}}</script><h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}&w^{t+1} \gets w^{t} - \frac{n^{t}}{\sigma^{t}}\\&\sigma^{t} = \sqrt{\frac{1}{t + 1}\sum_{i = 0}^{t}(g^{i})^{2}}\\& \eta^{t} = \frac{\eta}{\sqrt{n + 1}}\\\end{aligned}\end{equation*}</script><p>其中<script type="math/tex">\sigma^{t}</script>是之前这个<script type="math/tex">w</script>的所有偏微分值的均方根。这样子当t较大的时候，<script type="math/tex">\sigma^{t}</script>就能十分接近二次微分从而做到对于不同的<script type="math/tex">w</script>有一个将不同参数的分布进行类似归一化的处理。使得不同的参数的取值距离最优点距离的估算都是一个单位的。</p><p>对于上述算式进行化简，得到：</p><script type="math/tex; mode=display">w^{t+1} \gets w^{t} - \frac{\eta}{\sqrt{\sum_{i = 0}^{t} (g^{i})^{2}}}</script><h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>传统的GD是对于所有的训练数据计算梯度，然后更新系数。SGD是从训练数据中随机的抽取几个数据来算梯度，立马更新。显然这种方法更加快，效果也不错。</p><p><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/5.png" alt="f5"></p><h2 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h2><p>当不同参数传入的特征值单位相差很大的时候，不同参数对于结果的影响就会出现偏差，这样是非常不好的，不仅仅会影响到参数的更新，也会影响到训练的效率以及结果。所以需要将不同的特征值进行归一化处理。</p><p><img src="/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/6.png" alt="f6"></p><p>将特征的值，通过：</p><script type="math/tex; mode=display">x_{i}^{r} \gets \frac{x_{i}^{r} - m_{i}}{\sigma^{2}}</script><p>其中<script type="math/tex">m_{i}</script>是所有<script type="math/tex">x_{i}</script>这个特征值的平均值，<script type="math/tex">\sigma^{2}</script>是方差。这样处理之后，此特征的分布平均值为0，方差为1，对于所有的feature都进行这样的处理了之后，就服从相同的分布了。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://www.youtube.com/watch?v=yKKNr-QKz2Q&amp;feature=youtu.be">ML Lecture 3-1: Gradient Descent</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;李宏毅机器学习3-1笔记。&lt;/p&gt;
&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;是一种得到loss最优值的一种方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="深度学习基础" scheme="https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>【ML】Error</title>
    <link href="https://luoyongjia.github.io/2021/04/10/%E3%80%90ML%E3%80%91Error/"/>
    <id>https://luoyongjia.github.io/2021/04/10/%E3%80%90ML%E3%80%91Error/</id>
    <published>2021-04-10T09:52:54.000Z</published>
    <updated>2021-04-11T14:02:36.949Z</updated>
    
    <content type="html"><![CDATA[<p>这节课主要是讲，如何调教Average error。为何出现这种情况以及如何针对性解决问题。</p><p>我们的目标是—-在testing data上获得更好的表现！！！</p><h1 id="Bias-and-Variance-of-Estimator"><a href="#Bias-and-Variance-of-Estimator" class="headerlink" title="Bias and Variance of Estimator"></a>Bias and Variance of Estimator</h1><h2 id="Estimator"><a href="#Estimator" class="headerlink" title="Estimator"></a>Estimator</h2><p>估算器是用来判断这一群<script type="math/tex">f^{*}</script>跟正确的<script type="math/tex">\widehat{f}</script>之间的差距。有两个变量，Bias+Variance。</p><h2 id="Bias"><a href="#Bias" class="headerlink" title="Bias"></a>Bias</h2><p>其实就是你定义的函数对于正确函数之间的偏差。比如说正确的是5次函数，但是我们设置的是1次函数，这样子就出现了bias, 不管怎么训练，都没法儿很好的拟合数据。</p><h2 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h2><p>这个是关于训练的数据是否足够。不同的训练出来的模型是否效果都差不多。如果效果相差很多，就是variance大，这时候就需要更多的数据来训练模型。</p><h2 id="总的来说"><a href="#总的来说" class="headerlink" title="总的来说"></a>总的来说</h2><p>我觉得这个图片能够很好的说明问题</p><p><img src="/2021/04/10/%E3%80%90ML%E3%80%91Error/1.png" alt="f1"></p><p>怎么训练都训练不出，无非两个问题：</p><ol><li>model的原型选的就有问题。</li><li>训练的数据不够。</li></ol><h1 id="如何快速、有效挑选model？"><a href="#如何快速、有效挑选model？" class="headerlink" title="如何快速、有效挑选model？"></a>如何快速、有效挑选model？</h1><p>如果说，我每一个model都用所有的训练数据去训练，这样需要耗费大量的资源。然后还有一个问题，就是我们现在训练出来的参数只是针对当先数据的最优，我们怎么去应对未知的数据呢？</p><h2 id="Validation-set"><a href="#Validation-set" class="headerlink" title="Validation set"></a>Validation set</h2><p>这时候，验证集就出现啦。我们将验证集作为验证参数的有效性的依据，然后用testing set来模拟真实情况下未知的数据。可以一分为二，也可以将数据分为三份，然后每次挑其中一个作为验证集。将验证集拿来检验当前的model的效果，最后挑选效果最好的model用全部已知数据来训练。</p><p><img src="/2021/04/10/%E3%80%90ML%E3%80%91Error/2.png" alt="f2"></p><p>私以为，这种方法能够有效降低bias。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://www.youtube.com/watch?v=D_S6y0Jm6dQ">Where does the error come from?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这节课主要是讲，如何调教Average error。为何出现这种情况以及如何针对性解决问题。&lt;/p&gt;
&lt;p&gt;我们的目标是—-在testing data上获得更好的表现！！！&lt;/p&gt;
&lt;h1 id=&quot;Bias-and-Variance-of-Estimator&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="深度学习基础" scheme="https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo Latex显示问题</title>
    <link href="https://luoyongjia.github.io/2021/04/07/hexo-Latex%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <id>https://luoyongjia.github.io/2021/04/07/hexo-Latex%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-07T07:21:08.000Z</published>
    <updated>2021-04-07T07:31:36.392Z</updated>
    
    <content type="html"><![CDATA[<p>近几天突然发现博客上<script type="math/tex">\latex</script>公式不显示了，前段时间还好好的，并且在本地的<code>locallhost:4000</code>上很正常。来一下解决方案，或许以后还能用到。</p><p>我的博客用的是<code>pure</code>主题。它的配置文件中并没有提到mathjax，所以我是手动加的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p>也用了一段时间。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><ul><li>安装了插件、false</li><li>换了个浏览器、false</li><li>肯定不是网的问题，网一直都在墙外呆着、false</li></ul><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>看到<code>NexT</code>主题中关于mathjax的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: false</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: &#x2F;&#x2F;cdn.mathjax.org&#x2F;mathjax&#x2F;latest&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>把这段整到我的主题的配置文件里面去，就ok惹。🎉🎉</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://www.lizhechen.com/2018/10/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%94%B9%E7%89%88/">调教Hexo[4]——记一次费劲的改版</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近几天突然发现博客上&lt;script type=&quot;math/tex&quot;&gt;\latex&lt;/script&gt;公式不显示了，前段时间还好好的，并且在本地的&lt;code&gt;locallhost:4000&lt;/code&gt;上很正常。来一下解决方案，或许以后还能用到。&lt;/p&gt;
&lt;p&gt;我的博客用的是&lt;</summary>
      
    
    
    
    <category term="基本操作" scheme="https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="hexo" scheme="https://luoyongjia.github.io/tags/hexo/"/>
    
    <category term="latex" scheme="https://luoyongjia.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>【ML】Regression</title>
    <link href="https://luoyongjia.github.io/2021/04/01/%E3%80%90ML%E3%80%91Regression/"/>
    <id>https://luoyongjia.github.io/2021/04/01/%E3%80%90ML%E3%80%91Regression/</id>
    <published>2021-04-01T13:06:44.000Z</published>
    <updated>2021-04-07T07:16:44.293Z</updated>
    
    <content type="html"><![CDATA[<p>这是李宏毅深度学习2020的第一课笔记。</p><h1 id="Regression在做什么"><a href="#Regression在做什么" class="headerlink" title="Regression在做什么"></a>Regression在做什么</h1><p>输入数据，输出一个<strong>数值</strong>。    </p><ul><li>股票预测<ul><li><script type="math/tex; mode=display">f(StocksInfo) = DowJonesIndustrialAverage atTomorrow</script></li></ul></li><li>自动驾驶<ul><li><script type="math/tex">f(Road Info) =</script> 方向盘的角度</li></ul></li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>课上用宝可梦的例子来解释了这个步骤。通过一个基础宝可梦的相关数据预测其进化后的Combat Power(CP)</p><h2 id="Step-1-Model"><a href="#Step-1-Model" class="headerlink" title="Step 1: Model"></a>Step 1: Model</h2><p>从一堆不同的函数中（一次函数、二次函数、对数函数等），选取合适当前数据的函数。</p><p>这里选取了线性模型：<script type="math/tex">y = b + \sum w_{i}x_{i}</script><br>feature: <script type="math/tex">x_{i}: x_{cp}, x_{hp}, x_{w}, x_{h}...</script></p><p><img src="/2021/04/01/%E3%80%90ML%E3%80%91Regression/1.png" alt="f1"></p><p>挑了<script type="math/tex">x_{cp}</script>作为天选之子，不同的<script type="math/tex">w</script>和<script type="math/tex">b</script>的选择能构成各种各样的函数：    </p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}&f1: y = 10.0 + 9.0\cdot x_{cp}\\&f2: y = 9.8 + 9.2\cdot x_{cp}\\&f3: y = -0.8 - 1.2\cdot x_{cp}\\\end{aligned}\end{equation*}</script><h2 id="Step-2-Goodness-of-Function"><a href="#Step-2-Goodness-of-Function" class="headerlink" title="Step 2: Goodness of Function"></a>Step 2: Goodness of Function</h2><p>现在有那么多的函式，想要挑出能最好预测宝可梦cp值的函式需要有一个<strong>评判标准</strong>。这时候，Loss就出来了。</p><h3 id="先来观察下Training-Data"><a href="#先来观察下Training-Data" class="headerlink" title="先来观察下Training Data"></a>先来观察下Training Data</h3><p>Train Data由函数输入<script type="math/tex">x^{i}</script>和函数正确的输出<script type="math/tex">\widehat{y}^{i}</script>。<br><img src="/2021/04/01/%E3%80%90ML%E3%80%91Regression/2.png" alt="f2"><br>课上老师的数据中有十组宝可梦的数据<script type="math/tex">(x_{cp}^{n}, \widehat{y}^{n})</script></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><p>Input: a function<br>Output: how bat it is        </p><p>这里定义loss为：        </p><script type="math/tex; mode=display">L(f) = \sum_{n = 1}^{10}(\widehat{y}^{n} - f(x_{cp}^{n}))^{2}</script><p>也就是：    </p><script type="math/tex; mode=display">L(w,b) = \sum_{n = 1}^{10}(\widehat{y}^{n} - (b + w \cdot x_{cp}^{n}))^{2}</script><p>Loss function的值越小，表示函数预测cp值的效果越好。</p><h2 id="Step-3-Best-Function"><a href="#Step-3-Best-Function" class="headerlink" title="Step 3: Best Function"></a>Step 3: Best Function</h2><p>诶嘿，终于要找最好的预测函数了。在上一步中，我们定义了Loss Function，这里需要做的工作就是将Loss Function的值降到最低。课上使用了梯度下降。</p><p>工作：    </p><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}f^{*} &= arg \mathop{min}\limits_{f}L(f)\\w^{*}, b^{*} &= arg \mathop{min}\limits_{w,b} L(w,b)\\& = arg \mathop{min}\limits_{w,b} \sum_{n = 1}^{10}(\widehat{y}^{n} - (b + w \cdot x_{cp}^{n}))^{2}\\end{aligned}\end{equation*}</script><h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>梯度下降，最简单的梯度下降。</p><ol><li>随机初始化<script type="math/tex">w^{0}</script></li><li>计算梯度<script type="math/tex">\frac{dL}{dw}|_{w = w^{0}}</script><script type="math/tex; mode=display">\begin{equation*}\begin{aligned}&w^{1} = w^{0} - \eta \frac{dL}{dw}|_{w = w^{0}}\\&w^{2} = w^{1} - \eta \frac{dL}{dw}|_{w = w^{1}}\\& \ldots\end{aligned}\end{equation*}</script></li></ol><p><img src="/2021/04/01/%E3%80%90ML%E3%80%91Regression/3.png" alt="f3"><br>梯度为负时，w++，梯度为正时，w—就这样一步步重复计算梯度-&gt;移动w的过程。</p><h4 id="Gradient是什么"><a href="#Gradient是什么" class="headerlink" title="Gradient是什么"></a>Gradient是什么</h4><p>就是对于多个参数组成的向量。<br><img src="/2021/04/01/%E3%80%90ML%E3%80%91Regression/4.png" alt="f4">    </p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="Average-Error"><a href="#Average-Error" class="headerlink" title="Average Error"></a>Average Error</h3><script type="math/tex; mode=display">\frac{1}{n}\sum_{i = 1}^{n}e^{i}</script><p><script type="math/tex">\sum</script>|真实值-预测值|</p><h3 id="探索不同的model的效果"><a href="#探索不同的model的效果" class="headerlink" title="探索不同的model的效果"></a>探索不同的model的效果</h3><p>这里就不一一举例了，直接来个结果：<br>次数越高的model，对于train data的拟合效果越好，能表示的数据结构更多。但是这样会使得再test data上效果并不好，这就是<strong>过拟合</strong>。所以要找一个合适的model，能够做到train data和test data两个性能的兼顾。</p><p><img src="/2021/04/01/%E3%80%90ML%E3%80%91Regression/5.png" alt="f5"></p><h3 id="多feature"><a href="#多feature" class="headerlink" title="多feature"></a>多feature</h3><p>观察更多的数据，发现并不只当前cp值影响预测结果，还有很多其他的因素。这时候<script type="math/tex">x</script>就不是一个单纯的数值，而是一个能够表现多个特征的向量。暂时，是这么理解的。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://www.youtube.com/watch?v=fegAeph9UaA">ML讲座1：回归 - 案例研究</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是李宏毅深度学习2020的第一课笔记。&lt;/p&gt;
&lt;h1 id=&quot;Regression在做什么&quot;&gt;&lt;a href=&quot;#Regression在做什么&quot; class=&quot;headerlink&quot; title=&quot;Regression在做什么&quot;&gt;&lt;/a&gt;Regression在做什么&lt;/</summary>
      
    
    
    
    <category term="深度学习基础" scheme="https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>conda常用操作</title>
    <link href="https://luoyongjia.github.io/2021/03/30/conda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://luoyongjia.github.io/2021/03/30/conda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2021-03-30T11:35:27.000Z</published>
    <updated>2021-03-30T12:15:25.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="升级conda"><a href="#升级conda" class="headerlink" title="升级conda"></a>升级conda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h3 id="升级anaconda"><a href="#升级anaconda" class="headerlink" title="升级anaconda"></a>升级anaconda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h3 id="显示config"><a href="#显示config" class="headerlink" title="显示config"></a>显示config</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure><h3 id="查看channels"><a href="#查看channels" class="headerlink" title="查看channels"></a>查看channels</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure><h3 id="移除镜像源"><a href="#移除镜像源" class="headerlink" title="移除镜像源"></a>移除镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove channels (url)</span><br></pre></td></tr></table></figure><h3 id="添加镜像源"><a href="#添加镜像源" class="headerlink" title="添加镜像源"></a>添加镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels (url)</span><br></pre></td></tr></table></figure><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n Name python&#x3D;x.x</span><br></pre></td></tr></table></figure><h3 id="进入环境"><a href="#进入环境" class="headerlink" title="进入环境"></a>进入环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate Name</span><br></pre></td></tr></table></figure><h3 id="查看某环境下的包"><a href="#查看某环境下的包" class="headerlink" title="查看某环境下的包"></a>查看某环境下的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n Name</span><br></pre></td></tr></table></figure><h3 id="给某环境安装包"><a href="#给某环境安装包" class="headerlink" title="给某环境安装包"></a>给某环境安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n Name package</span><br></pre></td></tr></table></figure><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source deactivate</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h3 id="搜索指定的包"><a href="#搜索指定的包" class="headerlink" title="搜索指定的包"></a>搜索指定的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search package</span><br></pre></td></tr></table></figure><h3 id="更新当前环境所有包"><a href="#更新当前环境所有包" class="headerlink" title="更新当前环境所有包"></a>更新当前环境所有包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package</span><br></pre></td></tr></table></figure><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package</span><br></pre></td></tr></table></figure><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://blog.csdn.net/qq_37405118/article/details/106003069">conda 基本操作（常用的）</a><br><a href="https://zhuanlan.zhihu.com/p/103134000">利用conda升级Anaconda及其包</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;升级conda&quot;&gt;&lt;a href=&quot;#升级conda&quot; class=&quot;headerlink&quot; title=&quot;升级conda&quot;&gt;&lt;/a&gt;升级conda&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="基本操作" scheme="https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux查看GPU状态</title>
    <link href="https://luoyongjia.github.io/2021/03/30/Linux%E6%9F%A5%E7%9C%8BGPU%E7%8A%B6%E6%80%81/"/>
    <id>https://luoyongjia.github.io/2021/03/30/Linux%E6%9F%A5%E7%9C%8BGPU%E7%8A%B6%E6%80%81/</id>
    <published>2021-03-30T02:41:08.000Z</published>
    <updated>2021-03-30T11:32:42.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p><strong>查看显卡信息</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i vga</span><br></pre></td></tr></table></figure></p><p>然后会显示一条条的显卡信息。然后用<code>lspci -v -s 00:0X:XX</code>，查看相应的显卡信息。<br><strong>nvida GPU查看</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i nvidia</span><br></pre></td></tr></table></figure></p><h2 id="Nvidia表格"><a href="#Nvidia表格" class="headerlink" title="Nvidia表格"></a>Nvidia表格</h2><p><strong>Nvidia显卡信息及表头解释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p><img src="/2021/03/30/Linux%E6%9F%A5%E7%9C%8BGPU%E7%8A%B6%E6%80%81/1.png" alt="f1"></p><h3 id="上层"><a href="#上层" class="headerlink" title="上层"></a>上层</h3><ul><li>Fan: 风扇转速（0-100%），计算机的期望转速。N/A表示计算机不是风冷或风扇坏了。</li><li>Temp: 显卡内部温度（摄氏度）。</li><li>Perf: 性能状态，P0-P12，P0表示最大性能。</li><li>Pwr: 能耗。</li><li>Bus-Id: GPU总线相关信息。</li><li>Disp.A: Display Active, GPU是否初始化。</li><li>Memory Usage: 显存使用率。</li><li>Volatile GPU-Util: 浮动的GPU使用率。</li><li>Compute M: 计算模式。</li></ul><h3 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h3><p>显示每块GPU上每个进程所使用的现存情况。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://blog.csdn.net/dcrmg/article/details/78146797">Linux查看GPU信息和使用情况</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;查看显卡信息&lt;/strong&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="基本操作" scheme="https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="GPU" scheme="https://luoyongjia.github.io/tags/GPU/"/>
    
    <category term="Linux" scheme="https://luoyongjia.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>神经网络结构搜索（NAS）综述0.1</title>
    <link href="https://luoyongjia.github.io/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/"/>
    <id>https://luoyongjia.github.io/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/</id>
    <published>2021-03-29T02:37:04.000Z</published>
    <updated>2021-03-30T02:35:23.867Z</updated>
    
    <content type="html"><![CDATA[<p>近期读了一篇Nas综述（<a href="https://arxiv.org/abs/1808.05377">Neural Architecture Search: A Survey</a>）了，这篇是一篇19年的综述…就这两年Nas的发展可以说是老综述了；但是更新的我也没找到，所以就凑活着看看。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先是<strong>深度学习</strong>在各个领域的应用。随着深度学习的发展，网络结构的设计对于完成任务至关重要。但是很多网络结构的设计都是基于人的经验的，这很容易出错。所以将构建网络这个过程，也交给数据与机器去自动选择。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>能够快速地找到适应一个任务的网络结构。<br>如图所示：</p><p><img src="/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/1.jpg" alt="f1"></p><h1 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h1><p><img src="/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/2.png" alt="f2"></p><p>主要包含三个方向：<strong>搜索空间</strong>、<strong>搜索策略</strong>、<strong>评价预估</strong>。很好理解：<br><strong>搜索空间</strong> 从哪些网络结构中搜索<br><strong>搜索策略</strong> 怎么针对任务挑出适应的结构<br><strong>评价预估</strong> 具像化简单的理解，就是评价搜索策略找出来的这个网络结构的性能。        </p><h1 id="Search-Space"><a href="#Search-Space" class="headerlink" title="Search Space"></a>Search Space</h1><p><script type="math/tex">chain-structured neural networks</script>: 链式的网络结构，搜索的可以有：1. 网络的层数；2. 每一层的操作；3. 超参。<br>如图中左边的结构。</p><p><script type="math/tex">multi-branch networks</script>: 就字面意思，多分支，看图中右边结构就懂了。</p><p><img src="/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/3.png" alt="f3"></p><p><script type="math/tex">cells</script>：人工设计的复杂的网络中有很多重复的部分，大约就是，训练小的cell，然后再进行堆叠。</p><p><img src="/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/4.png" alt="f4"></p><h1 id="Search-Strategy"><a href="#Search-Strategy" class="headerlink" title="Search Strategy"></a>Search Strategy</h1><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>这个暂时还不懂。</p><h2 id="遗传进化算法"><a href="#遗传进化算法" class="headerlink" title="遗传进化算法"></a>遗传进化算法</h2><p>大约的框架就是：</p><blockquote><ol><li>随机生成一个种群（n个网络结构）</li><li>循环：选择、交叉、变异，直到满足最终条件</li></ol></blockquote><p>不同的工作可以聚焦在不同的过程中，比如如何sample种群，如何选择种群等。</p><p>我毕设中就是用的这种方法。</p><h2 id="基于梯度的方法"><a href="#基于梯度的方法" class="headerlink" title="基于梯度的方法"></a>基于梯度的方法</h2><p>强化学习和遗传进化算法都是在离散的空间中搜索，这种方法就是把操作与操作之间的路径选择转基于选择某路径的概率，从而使得离散的问题变成了连续的问题，就可以基于梯度优化的方法进行网络结构搜索了。</p><h1 id="Performance-Estimation-Strategy"><a href="#Performance-Estimation-Strategy" class="headerlink" title="Performance Estimation Strategy"></a>Performance Estimation Strategy</h1><p>诶嘿，这块儿是一个加快NAS训练的重要点。然后我挑了俩个人觉得还算靠谱的方法。</p><h2 id="Weight-Inheritance"><a href="#Weight-Inheritance" class="headerlink" title="Weight Inheritance"></a>Weight Inheritance</h2><p>参数级别的迁移，用之前已经训练好的模型权重参数对于目标问题赋值，从一个较高起点的初值开始搜。具体怎么搞的，以后再补充。</p><h2 id="One-shot"><a href="#One-shot" class="headerlink" title="One-shot"></a>One-shot</h2><p>在其他的方法中都需要对于每一个（<script type="math/tex">n</script>）网络结构进行训练。所以One-shot把这<script type="math/tex">n</script>个网络结构使用一个SuperNet表示。SuperNet中，可以表示不同的SubNet，从而覆盖了之前的<script type="math/tex">n</script>个网络结构。通过对于这个SuperNet的训练达到了训练<script type="math/tex">n</script>个网络结构的效果。从而大大减少了训练所需的时间和资源。</p><h1 id="自己的碎碎念"><a href="#自己的碎碎念" class="headerlink" title="自己的碎碎念"></a>自己的碎碎念</h1><p>之前了解得不多，怎么说呢，想要开始就整这个方向。现在看了🤏相关的知识，会发现这其实只是一种方法，也可以说是一种工具吧，并不是一个好的，作为research起点的方向。确实这个方向有很多值得研究的方面，但是我觉得都是需要基于个人对于另一个什么方向有了深刻的理解了，再来，或许是优化NAS的方法，又或许是NAS与某个方面结合，亦或许是使NAS能做到多任务。这都是没有好的其他的基础，做不到的，so.</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://blog.csdn.net/qq_41997920/article/details/92760903">神经网络架构搜索（NAS）综述</a><br><a href="https://arxiv.org/abs/1808.05377">Neural Architecture Search: A Survey</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期读了一篇Nas综述（&lt;a href=&quot;https://arxiv.org/abs/1808.05377&quot;&gt;Neural Architecture Search: A Survey&lt;/a&gt;）了，这篇是一篇19年的综述…就这两年Nas的发展可以说是老综述了；但是更新的我也没</summary>
      
    
    
    
    <category term="Research" scheme="https://luoyongjia.github.io/categories/Research/"/>
    
    
    <category term="Nas" scheme="https://luoyongjia.github.io/tags/Nas/"/>
    
  </entry>
  
  <entry>
    <title>Mac配置Anaconda环境变量</title>
    <link href="https://luoyongjia.github.io/2021/03/26/Mac%E9%85%8D%E7%BD%AEAnaconda%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://luoyongjia.github.io/2021/03/26/Mac%E9%85%8D%E7%BD%AEAnaconda%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-03-26T05:15:34.000Z</published>
    <updated>2021-03-26T05:23:46.212Z</updated>
    
    <content type="html"><![CDATA[<p>因为好像就是这两年，macOS的系统大更新，把默认shell的bash改成了zsh。导致以前的一些配置环境变量的东西都没法儿用了。今天要开始看python的代码了，所以想着来把anaconda配一下。真的太久没用了，导致版本都……所以需要在终端配置一下，居然发现我的终端的conda, not found了。就来解决了一下。</p><h2 id="机器背景"><a href="#机器背景" class="headerlink" title="机器背景"></a>机器背景</h2><p>mbp2018, bash。</p><p>会发现，原来的<code>bash_profile</code>都不管用了<br>而且，anaconda的默认路径也更改了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>anaconda的路径: <code>/Users/USERNAME/opt/anaconda3/bin</code></p><p>bash配置文件路径：<code>/private/etc/bashrc</code></p><p>就，强制在bashrc文件里面加<code>export PATH=&quot;/Users/USERNAME/opt/anaconda3/bin:$PATH&quot;</code><br>即可。</p><p>暂时还没出现问题，后续再说吧。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://zhuanlan.zhihu.com/p/121086727">Mac 没有找到 conda命令</a><br><a href="https://discussionschinese.apple.com/thread/251633370">mac设置全局环境变量</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为好像就是这两年，macOS的系统大更新，把默认shell的bash改成了zsh。导致以前的一些配置环境变量的东西都没法儿用了。今天要开始看python的代码了，所以想着来把anaconda配一下。真的太久没用了，导致版本都……所以需要在终端配置一下，居然发现我的终端的c</summary>
      
    
    
    
    
    <category term="环境变量" scheme="https://luoyongjia.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】串</title>
    <link href="https://luoyongjia.github.io/2021/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2/"/>
    <id>https://luoyongjia.github.io/2021/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2/</id>
    <published>2021-03-18T02:08:37.000Z</published>
    <updated>2021-03-18T04:01:39.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>计算机上非数值的处理对象。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><strong>Copy(&amp;T, s)</strong> 就是copy操作，将一个地址里的东西取出来，存到新的字符串里面。<br><strong>length()</strong> 字符串的长度。<br><strong>Index(S, T)</strong> 定位t的初始位置。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h2><p>顺序存储结构，分配一个定长的空间存储字符串。</p><h2 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h2><p>是在程序运行的过程中，动态分配形成的。当程序请求一块空间之后，在堆空间中分配一块区域。不成功返回null。</p><h2 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h2><p>类似于链式存储。多个节点，每个节点里面放几个字符。空的用“#”补全。</p><h1 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h1><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>老暴力方法了，就两个字符串硬比，没什么技术水平。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>这才是重中之重！<br>为什么有这种方法呢，因为在暴力算法中重复了大量的比较，这种方法能够减少这种重复的出现。</p><h3 id="先来一个文字描述"><a href="#先来一个文字描述" class="headerlink" title="先来一个文字描述"></a>先来一个文字描述</h3><blockquote><p><strong>什么是next数组</strong><br>next数组就是匹配字串的每一位所在的最长前后缀相同的长度。<br><br><strong>如何构建呢？<br></strong></p><ol><li>我使用的是动态规划的方法。前后两个指针。前指针指向后缀的最后一个字符，后指针指向后缀的最后一个字符。比较这两个指针存的内容，<br></li><li>当前指针为0，且前指针与后指针内容不相等的时候，后指针所指下标next数组存为0<br></li><li>相同则后指针所在位置等于前指针前一位next数组存的数字+1<br></li><li>不同则将前指针移动到前指针前一位next数组存的数字地址再做比较，直到前指针到0。<br><br><strong>如何匹配<br></strong></li><li>正常匹配<br></li><li>当遇到两个字符不相等的时候，将母串与子串的next数组对应的前一位的内容做对比，相当于将子串移动到前一next位。这样就减少了前一next之前的那些重复的比较。</li></ol></blockquote><h3 id="再来一个代码"><a href="#再来一个代码" class="headerlink" title="再来一个代码"></a>再来一个代码</h3><p>代码再说吧，有时间再写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;计算机上非数值的处理对象。&lt;/p&gt;
&lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【TOEFL】 口语Task1、Task2</title>
    <link href="https://luoyongjia.github.io/2021/03/11/%E3%80%90TOEFL%E3%80%91-%E5%8F%A3%E8%AF%ADTask1%E3%80%81Task2/"/>
    <id>https://luoyongjia.github.io/2021/03/11/%E3%80%90TOEFL%E3%80%91-%E5%8F%A3%E8%AF%ADTask1%E3%80%81Task2/</id>
    <published>2021-03-11T02:28:33.000Z</published>
    <updated>2021-03-11T02:54:07.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="review"><a href="#review" class="headerlink" title="review"></a>review</h1><h2 id="口语的评分标准"><a href="#口语的评分标准" class="headerlink" title="口语的评分标准"></a>口语的评分标准</h2><ol><li>dilivery: 表达，语言表达是否准确</li><li>language use: 用词和语法是否恰当</li><li>topic development: <ol><li>独立：每个点都要有一定的展开</li><li>综合：文中或者是听力中的每个细节都要提到 </li></ol></li></ol><h1 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h1><p>主要是如何展开，想论据这样子。</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="立场"><a href="#立场" class="headerlink" title="立场"></a>立场</h4><p>不同的角色有不同的立场，从不同的立场去考虑这个问题。比如说，junk food AD，就有parents和children两个方面去考虑这个广告的影响。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>不同的角色有不同的特点。还是那个junk food的例子，可能children就有容易被影响的特点。</p><h3 id="其他名词"><a href="#其他名词" class="headerlink" title="其他名词"></a>其他名词</h3><p>分析有没有具体的细节、具体的功能、具体的表现。比如那题，现代科技代替图书馆的题，就可以分析现代科技的功能，分析图书馆的功能，从这些角度来答题。</p><h1 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>校方通知，学生建议</p><h2 id="阅读中的注意点"><a href="#阅读中的注意点" class="headerlink" title="阅读中的注意点"></a>阅读中的注意点</h2><ul><li>改变：正文标题，第一句话。</li><li>数字：如果文中有数字，一定要记下来，在答题中打出来显得十分细节</li><li>姓名：写信的学生的姓名，然后就是教授的名字</li><li>借口：一般会有两个接口，记个大概，因为有时候会让重复、总结文中的理由。学生的建议有时候会需要答。</li></ul><h2 id="答题模版"><a href="#答题模版" class="headerlink" title="答题模版"></a>答题模版</h2><ol><li>The university gives an announcement that/of do/doing …<br>Student xxx suggests/proposes the university to do …</li><li>agrees: feels happy with, infovor of <br>disagrees: feels sorry for</li><li>attrcting, enhence: 文中的理由和听力中的相同，就增强。不同就另说。</li></ol><h2 id="增长时间利器"><a href="#增长时间利器" class="headerlink" title="增长时间利器"></a>增长时间利器</h2><p>如果答完自己记录的细节还有5s多，那就来一句废话，就是关于第2个理由的废话，时间就够啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;review&quot;&gt;&lt;a href=&quot;#review&quot; class=&quot;headerlink&quot; title=&quot;review&quot;&gt;&lt;/a&gt;review&lt;/h1&gt;&lt;h2 id=&quot;口语的评分标准&quot;&gt;&lt;a href=&quot;#口语的评分标准&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="TOEFL" scheme="https://luoyongjia.github.io/categories/TOEFL/"/>
    
    
    <category term="口语" scheme="https://luoyongjia.github.io/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】栈和队列</title>
    <link href="https://luoyongjia.github.io/2021/03/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://luoyongjia.github.io/2021/03/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-03-10T12:51:00.000Z</published>
    <updated>2021-03-11T02:26:17.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是线性表的应用和推广。是受限的线性表。栈，就是“先进后出”。就像一个只有一个出口的桶，先进去的人只能等后进去的人走了才能出去。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>isEmpty()</strong> 栈是否为空<br><strong>push(&amp;s, T elem)</strong> 压入栈<br><strong>pop(&amp;s, T elem)</strong> 吐出最顶上那个元素<br><strong>getTop(s, &amp;x)</strong>  把最顶上那个复制一份给x<br><strong>destroyStack()</strong> 毁灭吧，栈</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储—-gt-顺序栈"><a href="#顺序存储—-gt-顺序栈" class="headerlink" title="顺序存储—&gt;顺序栈"></a>顺序存储—&gt;顺序栈</h3><p>就是用数组来存，然后有一个位置指针来操作。</p><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>顺序栈的抠门做法。一个空间俩栈用。一个从头开始，一个从尾巴开始这样子。</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>就叫链栈。便于多个栈共享存储空间，提高效率。不存在放不下的问题，反正链式，可以无限扩展。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>算式转换，中序转后序。这个不好怎么解释，就来个🌰体会一下。</p><blockquote><p>中序表达式 <code>a + b - a * ((c + d) / e - f) + g</code>转换为等价的后缀表达式为<code>ab+acd+e/f-*-g+</code><br><br>过程大约是这个样子的：<br></p><ol><li>最先压入一个“#”<br></li><li>然后遇到数字直接输出<br></li><li>遇到符号根据优先级来，如果后一个的优先级高于栈顶的，则直接压入；如果后一个的优先级低于栈顶的，则弹出栈顶的，再做比较。</li></ol></blockquote><p>来一道例题吧</p><blockquote><p>假设栈初始为空，将中序表达式<code>a / b + (c * d - e * f) / g</code>转换为等价的后缀表达式的过程中，当扫描到<code>f</code>时，栈中的元素依次是<br><br>A.<code>+(*-</code> B. <code>+(-*</code> C. <code>/+(*-*</code> D. <code>/+-*</code><br><br><br><br>直接来个答案吧，B</p></blockquote><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><blockquote><ol><li>设链表不带头节点，且所有操作均在表头进行，则下列最不适合作为链栈的是（ ）<br><br> A. 只有表头节点指针，没有表尾指针的双向循环链表<br> B. 只有表尾节点指针，没有表头指针的双向循环链表<br>C. 只有表头节点指针，没有表尾指针的单项循环链表<br>D.只有表尾节点指针，没有表头指针的单项循环链表<br><br><br><br>C. 因为这里只有表头，没有表尾。每次对于栈的操作都是在头上做的。但是为了维持循环链表，所以得找到尾，所以所有操作至少都是<script type="math/tex">O(n)</script>，所以它不合适。<br><br></li><li><p>若已知一个栈的入栈序列是1，2，3，4，其出栈序列为<script type="math/tex">P_{1}, P_{2}, P_{3}, P_{4}</script>, 则<script type="math/tex">P_{2}, P_{4}</script>不可能是（ ）<br><br>A. 2，4  B. 2，1 C. 4，3 D.<br><br><br><br>这种题目，就只有一种方法，那就是自己一个个举例子。<br><br></p></li><li><p>设栈的初始状态为空，当字符序列“n1_”作为栈的输入时，输出长度为3，且可用作C语言标识符的序列有（ ）<br><br>A. 4 B. 5 C. 3 D. 6<br><br><br><br>这个题我个人觉得出的还挺好的，结合了数据结构和C语言的知识。这里，C语言标识符的要求是“第1个字符只能是字母或是下划线。”</p></li></ol></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>也是特殊的线性表。先进先出，就跟那吸管一样，只有一头可以进，另一头可以出。</p><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>front</strong> 头<br><strong>rear</strong> 尾<br><strong>enQueue()</strong> 压入<br><strong>deQueue()</strong> 出队列<br><strong>getHead()</strong> 获取头</p><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>“假溢出”。要是用传统的一条的那种数组来存队列的话，进进出出几次，下标就给整没了，但是其实那时候队列里面还是有空间存储元素的。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>所以人们就变聪明了，用环形的来存储队列。这就涉及一个下标计算的问题，这个问题常考，所以要记得一些公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">队首指针进1: front &#x3D; (front + 1) % MaxSize</span><br><span class="line">队尾指针进1:rear &#x3D; (rear + 1) %MaxSize</span><br><span class="line">队列长度:(rear + MaxSize - front) %MaxSize</span><br><span class="line">队满：(rear + 1) % MaxSize &#x3D;&#x3D; front</span><br><span class="line">空：front &#x3D;&#x3D; rear</span><br></pre></td></tr></table></figure><h3 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h3><p>带头节点单链表。有一个头头节点，然后有一个rear节点，这样子就能够很好的表示队列。</p><h2 id="奇奇怪怪的队列增加了"><a href="#奇奇怪怪的队列增加了" class="headerlink" title="奇奇怪怪的队列增加了"></a>奇奇怪怪的队列增加了</h2><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>就是两端都可以出栈和入栈。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>解决主机与外设之间速度不匹配的问题，解决由多用户引起的cpu资源竞争问题。<br>eg：设置一个打印数据缓冲区。cpu中的任务排成一个队列。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;是线性表的应用</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【数据结构】线性表</title>
    <link href="https://luoyongjia.github.io/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://luoyongjia.github.io/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2021-03-08T09:32:27.000Z</published>
    <updated>2021-03-08T15:00:48.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>相同数据类型</strong>的数据元素，<strong>有限</strong>长的序列。是一种逻辑结构，表示元素之间一对一的相邻关系。</p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>使用连续地址存储。这里有一个<strong>位序</strong>，位序是从1开始的。</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>最开始的时候分配的一定量的空间，是不可以扩充的。</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>开始分配一定量的空间。在存满之后，会开辟更大一个空间，然后替换之前那个小空间。</p><h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><p>纯属，只是写了，没有测试是否正确。VSCode的c++配置太难了，就这样吧。我试着去把JetBrains的工具下下来。果然白嫖就是有点难…</p><p>SeqList.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># ifndef CIRCLE_H</span><br><span class="line"># define CIRCLE_H</span><br><span class="line">int defaultSize &#x3D; 100;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SeqList</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T *data;</span><br><span class="line">    int maxSize;</span><br><span class="line">    int last;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    SeqList(int len &#x3D; defaultSize);</span><br><span class="line">    SeqList(const SeqList&lt;T&gt; &amp;L);   &#x2F;&#x2F; 拷贝构造</span><br><span class="line">    ~SeqList();</span><br><span class="line">    &#x2F;&#x2F; ostream &amp;operator&#x3D;(const SeqList&lt;T&gt; &amp;L);</span><br><span class="line"></span><br><span class="line">    bool Add(T elem);</span><br><span class="line">    bool Insert(int i, T elem);</span><br><span class="line">    bool Remove(int i, T elem);</span><br><span class="line">    int Search(T elem);</span><br><span class="line">    void SetData(int i, T elem);</span><br><span class="line">    void Show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>SeqList.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SeqList.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(int len)&#123;</span><br><span class="line">    maxSize &#x3D; len;</span><br><span class="line">    data &#x3D; new T[maxSize];</span><br><span class="line">    last &#x3D; -1;  &#x2F;&#x2F;线性表为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(const SeqList&lt;T&gt; &amp;L)&#123;</span><br><span class="line">    maxSize &#x3D; L.maxSize;</span><br><span class="line">    last &#x3D; L.last;</span><br><span class="line">    data &#x3D; new T[maxSize];</span><br><span class="line"></span><br><span class="line">    if(data &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;存储分配失败&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~SeqList()&#123;</span><br><span class="line">    delete[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Add(T elem)&#123;</span><br><span class="line">    if((last + 1)&gt;maxSize)</span><br><span class="line">        return false;</span><br><span class="line">    data[last++] &#x3D; elem;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Insert(int i, T elem)&#123;</span><br><span class="line">    if(last &#x3D;&#x3D; maxSize-1)&#123;</span><br><span class="line">        &#x2F;&#x2F; 表满，不能再存</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &lt; 0 || i &gt;last+1)&#123;</span><br><span class="line">        &#x2F;&#x2F; i越界了</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; last; j &gt;&#x3D; i; j--)&#123;</span><br><span class="line">        data[j + 1] &#x3D; data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    data[i] &#x3D; elem;</span><br><span class="line">    last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::Remove(int i, T elem)&#123;</span><br><span class="line">    if(i &lt; 0|| i &gt; last)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; i; j &lt; last; j++)&#123;</span><br><span class="line">        data[j] &#x3D; data[j + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    last--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int SeqList&lt;T&gt;::Search(T elem)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; last; i++)&#123;</span><br><span class="line">        if(data[i] &#x3D;&#x3D; elem)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::SetData(int i, T elem)&#123;</span><br><span class="line">    &#x2F;&#x2F; 检查i的合法性</span><br><span class="line">    if(i &lt; 0|| i &gt; last)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[i] &#x3D; elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::Show()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; last; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>插入： <script type="math/tex">O(n)</script><br>删除： <script type="math/tex">O(n)</script><br>查找： <script type="math/tex">O(1)</script><br>修改： <script type="math/tex">O(1)</script>    </p><h2 id="错题环节"><a href="#错题环节" class="headerlink" title="错题环节"></a>错题环节</h2><blockquote><ol><li>线性表的顺序存储结构是一种（ ）<br><br>A. 随机存取的存储结构        B. 顺序存取的存储结构  C. 索引存储的存储结构  D.散列存取的存储结构<br><br><br>⚠️选项中写的是<strong>存取</strong>。顺序存储，就是可以瞎取（按照下标直接存取），所以是随机的存取结构。而顺序的存取结构，是链式存储的，就是说只可以按照一定的顺序来存取。</li></ol></blockquote><h1 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h1><p>其实就是用链式存储来存顺序表，这其中不过是分配的空间不连续了。</p><h2 id="静态链表与动态链表"><a href="#静态链表与动态链表" class="headerlink" title="静态链表与动态链表"></a>静态链表与动态链表</h2><p>静态链表：初始化的时候，每个节点都初始化了。不能改变长短的。但是存储地址不一定是连续的。<br>动态链表：就，日常的链表</p><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><h3 id="头与尾"><a href="#头与尾" class="headerlink" title="头与尾"></a>头与尾</h3><p>头节点与尾节点，可有可无。里面不存内容，单纯定个位。有时候计算链表的长度可以考虑下是否有头、尾的情况。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>日常的，单向的链表。</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>就是不仅仅有指向下一个节点的指针，还有指向上一个节点的指针。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>尾部的next是头节点。就是，形成一个环了的链表。</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>一个表，跟顺序表差不多。存的指针是节点的相对地址，也就是下一个元素的index。-1时结束。</p><p><img src="/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/1.jpg" alt="f1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;相同数据类型&lt;/strong&gt;的数据元素，&lt;strong&gt;有限&lt;/strong&gt;长的序列。是一种逻辑结构，表示元素之间一对一</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>503. 下一个更大的元素2</title>
    <link href="https://luoyongjia.github.io/2021/03/06/503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A02/"/>
    <id>https://luoyongjia.github.io/2021/03/06/503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A02/</id>
    <published>2021-03-06T15:37:15.000Z</published>
    <updated>2021-03-07T08:35:14.909Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看题，这题…有点绕。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组（首尾相接那种），输出每个元素的下一个更大元素。如果搜完了整个数组，都没有找到比它大的数字，就输出-1。</p><blockquote><p><strong>输入：</strong>[1, 2, 1]<br><br><strong>输出：</strong>[2, -1, 2]<br><br><strong>解释：</strong>第一个1的下一个更大的数是2；<br><br>数字2找不到下一个更大的数；<br>第二个1的下一个最大的数循环搜索，结果就是2</p></blockquote><h2 id="自己一想"><a href="#自己一想" class="headerlink" title="自己一想"></a>自己一想</h2><p>简单，粗暴的方法。这样时间复杂度到了<script type="math/tex">O(n^{2})</script></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">    int[] ans &#x3D; new int[nums.length];</span><br><span class="line">    boolean forhead;</span><br><span class="line">    &#x2F;&#x2F; 找每一个数字的下一个更大的元素</span><br><span class="line">    for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        forhead &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 先找i后面的元素</span><br><span class="line">        for(int j &#x3D; i+1; j &lt; nums.length; j++)&#123;</span><br><span class="line">            if(nums[j] &gt; nums[i])&#123;</span><br><span class="line">                ans[i] &#x3D; nums[j];</span><br><span class="line">                forhead &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 再找i前面的元素</span><br><span class="line">        if(forhead &#x3D;&#x3D; true)&#123;</span><br><span class="line">            int k;</span><br><span class="line">            for(k &#x3D; 0; k &lt; i; k++)&#123;</span><br><span class="line">                if(nums[k] &gt; nums[i])&#123;</span><br><span class="line">                    ans[i] &#x3D; nums[k];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k &#x3D;&#x3D; i)&#123;</span><br><span class="line">                ans[i] &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="然后解析里的“单调栈”"><a href="#然后解析里的“单调栈”" class="headerlink" title="然后解析里的“单调栈”"></a>然后解析里的“单调栈”</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>栈里面的元素从栈底到栈顶是单调的。</p><ul><li>如果栈空，当前元素入栈</li><li>栈非空，判断当前和栈顶元素的大小<ul><li>如果比栈顶元素大，那么逐个弹出比较，构建ans</li><li>如果比栈顶元素小，则当前元素入栈</li></ul></li></ul><h3 id="循环数组实现方法："><a href="#循环数组实现方法：" class="headerlink" title="循环数组实现方法："></a>循环数组实现方法：</h3><p><strong>Way1:</strong>  把数组复制一份到数组的末尾<br><strong>Way2:</strong> 使用取模运算，把下表为<script type="math/tex">i</script>映射到数组<script type="math/tex">nums</script>的长度<script type="math/tex">0-N</script>中</p><h2 id="重写代码"><a href="#重写代码" class="headerlink" title="重写代码"></a>重写代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    int[] ans &#x3D; new int[n];</span><br><span class="line">    &#x2F;&#x2F;将ans用-1初始化</span><br><span class="line">    Arrays.fill(ans, -1);</span><br><span class="line">    Deque&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 栈非空,且比栈顶元素大，逐个弹出比较，构建ans</span><br><span class="line">        while(!stack.isEmpty() &amp;&amp; nums[stack.peek()]&lt;nums[i%n])&#123;</span><br><span class="line">            ans[stack.pop()] &#x3D; nums[i%n];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 不比栈顶元素大了，或者小了，或者栈空了，压入</span><br><span class="line">        stack.push(i%n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/">动画讲解：单调栈</a></p><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/">code来源-LeetCode-Solution</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来看看题，这题…有点绕。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个循环数组（首尾相接那种），输出每个元素的下一个更大元素。如果搜完了整个数组，都没有找到比它</summary>
      
    
    
    
    <category term="leetcode" scheme="https://luoyongjia.github.io/categories/leetcode/"/>
    
    
    <category term="单调栈" scheme="https://luoyongjia.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】绪论</title>
    <link href="https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/"/>
    <id>https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/</id>
    <published>2021-03-06T12:27:22.000Z</published>
    <updated>2021-03-08T09:33:24.559Z</updated>
    
    <content type="html"><![CDATA[<p>我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>很好，记不住的东西。</p><p><strong>数据</strong> 是信息，是数据，是程序直接处理的原料。<br><strong>数据元素</strong> 数据元素含有数据，是由一群数据组成的最小的、不可分割的最小单位。比如说，一个学生（包括他的姓名、学号、年龄等）就是一个数据元素。<br><strong>数据对象</strong> 一群同类型的数据元素组成的。比如说，学生对象，就是由一群学生对象组成的。<br><strong>数据类型</strong> 就比如说<code>byte, short, int, long</code>这些。就是一种数值的集合。其下面又有<strong>原子类型</strong>、<strong>结构类型</strong>、<strong>抽象数据类型</strong>，分别表示值不可分，值可以分，数据和与之相关的操作。<br><strong>数据结构</strong> 诶嘿，终于到它了。数据结构是有关系的数据元素的集合。包括<strong>逻辑结构</strong>，<strong>存储结构</strong>和<strong>数据的运算</strong>（个人理解为方法）。</p><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><p>我觉得这里主要是在讲逻辑结构与存储结构。还有一个名词叫“物理结构”，我在这里将会把他们仨分清楚。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑逻辑嘛，那当然是一种抽象的东西，我们不考虑他们的实际应该怎么样，只去考虑这样子特性的数据有些什么特色，可以怎么操作。</p><p><img src="/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/逻辑结构.png" alt="f1"></p><p>这里要解释一下<strong>集合</strong>，就是一群数据挤到一起，没有其他联系这样子。</p><h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>就是解决如何将数据存储的问题。</p><p><img src="/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/存储结构.png" alt="f1"></p><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>个人理解，就是操作、方法这种东西。</p><h3 id="这里来几道错题加深理解"><a href="#这里来几道错题加深理解" class="headerlink" title="这里来几道错题加深理解"></a>这里来几道错题加深理解</h3><blockquote><ol><li>可以用（ ）来定义一个完整的数据结构<br><br>A. 数据元素        B.数据对象        C.数据关系        D. 抽象数据类型<br><br>这里，👀上面的基本概念，就能得出答案D<br><br><br></li><li>以下属于逻辑结构的是（ ）<br><br>A. 顺序表    B. 哈希表    C. 有序表    D. 单链表<br><br><br>顺序表、哈希表、单链表，既可以表示逻辑结构，又可以表示存储结构。只有有序表是单纯的。<br><br><br></li><li>以下数据与数据的存储结构无关的术语是（ ）<br><br>A. 循环队列 B. 链表 C. 哈希表 D. 栈<br><br><br>B和C都很好排除。循环队列为一种数据结构？（这里存疑，之后来解决）可能是因为，他包含顺序表的逻辑结构，和顺序存储的存储结构，以及一些操作方法。讲真，<strong>不知道如何区分数据结构和逻辑结构的区别</strong>。问问后来补充。<br><br><br></li><li>在存储数据时，通常不仅要存储个数据元素的值，而且要存储( )<br><br>A. 数据的操作方法 B. 数据元素的类型 C. 数据元素之间的关系 D. 数据存取的方法<br><br><br>D，这没啥好说的，记住就好。</li></ol></blockquote><h2 id="算法评价"><a href="#算法评价" class="headerlink" title="算法评价"></a>算法评价</h2><p>算法，对于一个问题的解决方法逐步描述。</p><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><p><strong>有穷性</strong> 是不是有穷时间能跑完<br><strong>确定性</strong> 描述是不是无歧义的<br><strong>可行性</strong> 电脑能不能跑起来<br><strong>I/O</strong> 输入输出<br><strong>正确性</strong> 能不能正确解决问题<br><strong>可读性</strong> 是不是很好理解<br><strong>健壮性</strong> 能不能面对攻击<br><strong>效率</strong> 效率就是效率，时间、空间效率</p><h3 id="时间复杂度、空间复杂度"><a href="#时间复杂度、空间复杂度" class="headerlink" title="时间复杂度、空间复杂度"></a>时间复杂度、空间复杂度</h3><p>这种主要考：给段代码，然后让算复杂度。</p><p>注意点：O(1)的可以是常数级别的复杂度。</p><h6 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h6><hr><p><a href="https://blog.csdn.net/YangTongA/article/details/78244252">数据结构之逻辑结构与物理结构（存储结构）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;很</summary>
      
    
    
    
    <category term="数据结构" scheme="https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>再开公告</title>
    <link href="https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/"/>
    <id>https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/</id>
    <published>2021-03-06T11:56:28.000Z</published>
    <updated>2021-03-06T12:19:28.588Z</updated>
    
    <content type="html"><![CDATA[<p>很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。</p><p>之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找别人讨论；看元学习那篇大论文的时候，因为很多数学知识不了解，又放弃（过了一段时间明白了之中的大概原理）。当然，可能因为当初想的很多的时候，人还很小；来到大学了之后接触了更多的东西，选择多了，人也就迷惑了。</p><p>但是我觉得，我的绝望，很多是来源与我自己。我总觉得自己应该成为一个了不起的人，但是，大多数人最终不是还是普通人吗？我打算认命的，但是我做了什么呢？在家摸鱼摸了俩月。看出来了吧，就是因为自己骨子里的懒惰。考研的时候也是这样，学了两天之后，得休息上三天，才能继续。恨自己的不争气，却又一再地放纵。还有遇见了困难，总是想逃避，总想过着当下混沌又舒适的生活。可是这样的生活，我过得也很难受。总的来说，就是想要摆脱现状，但是又没有行动这样子。</p><p>认识到问题，当然得改。我试着去改改吧，这样下去不是个事儿。就从这次准备复试开始吧。</p><p>接下来想要在blog上分享一下我每天为复试准备的知识，以及每次上完TOEFL课的小总结这样子。</p><p><img src="/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/1.jpg" alt="figer1"></p><p>偷偷放一张喜欢的焦糖太太的图。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。&lt;/p&gt;
&lt;p&gt;之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="随笔" scheme="https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>String，StringBuffer和StringBuilder类</title>
    <link href="https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/"/>
    <id>https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/</id>
    <published>2021-01-08T10:14:09.000Z</published>
    <updated>2021-01-08T10:16:39.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String，StringBuffer和StringBuilder类"><a href="#String，StringBuffer和StringBuilder类" class="headerlink" title="String，StringBuffer和StringBuilder类"></a>String，StringBuffer和StringBuilder类</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String对象的值是无法改变的！要改变，请找String Buffer和String Builer</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str0 &#x3D; &quot;Gugugu&quot;;</span><br><span class="line">String str1 &#x3D; &quot;Gugugu&quot;;</span><br><span class="line">String str2 &#x3D; new String(&quot;Gugugu&quot;);</span><br><span class="line">String str3 &#x3D; new String(&quot;Gugugu&quot;);</span><br></pre></td></tr></table></figure><p>str0和str1都是指向公共池中相同的地址，而str2和str3指向堆中的不同地址。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>str0.length()</strong>    获取长度</p><p><strong>str0.concat(str1)</strong>    连接两个字符串，返回的是创建的一个新字符串，可以自己连自己。</p><p><strong>String.format(“balabalabala是%f”, floatVar)</strong>    就跟printf一样。String（java）里面是百分号诶。</p><p><strong>char charAt(int index)</strong> 返回指定下标的字符</p><p><strong>int indexOf(int ch)</strong> 返回第一次出现ch（or str）的下标，如果没有就-1</p><p><strong>int compareTo(String str)</strong> 字典序比较字符串</p><p><strong>int compareTolgnoreCase(String str)</strong>    不考虑大小写的比较字符串</p><p><strong>boolean contentEquals(StringBuffer sb)</strong>    与指定的StringBuffer有相同顺序的字符时返回true</p><p><strong>static String copyValueOf(char[] data, int offset, int count)</strong>    返回指定数组中表示改字符的序列的String。offset是开始点。</p><p><strong>char[] toCharArray()</strong>    转换为字符数组</p><p><strong>String toLowerCase()</strong>    全部转小写</p><p><strong>String toUpperCase()</strong>    全部转大写</p><p><strong>isEmpty()</strong>    判断字符串是否为空</p><h2 id="String-Buffer和String-Builder"><a href="#String-Buffer和String-Builder" class="headerlink" title="String Buffer和String Builder"></a>String Buffer和String Builder</h2><p>StringBuffer和StringBuilder类的对象能够被多次修改，不产生新的未使用对象。</p><p>StringBuilder和StringBuffer最大的不同在于StringBuilder的方法不是线程安全的（不能同步访问）。</p><p>StringBuilder运行速度比StringBuffer快。</p><p><img src="/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/1.png" alt="figer1"></p><p><img src="/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/2.png" alt="figer2"></p><p>refer:<br><a href="https://www.runoob.com/java/java-string.html">Java String 类</a><br><a href="https://www.runoob.com/java/java-stringbuffer.html">Java StringBuffer 和 StringBuilder 类</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String，StringBuffer和StringBuilder类&quot;&gt;&lt;a href=&quot;#String，StringBuffer和StringBuilder类&quot; class=&quot;headerlink&quot; title=&quot;String，StringBuffer和Stri</summary>
      
    
    
    
    <category term="Java" scheme="https://luoyongjia.github.io/categories/Java/"/>
    
    
    <category term="常用类" scheme="https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月3日</title>
    <link href="https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/</id>
    <published>2021-01-03T15:43:55.000Z</published>
    <updated>2021-01-03T15:52:06.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Character类、Math类、Number类</li><li>动态规划问题，三道题</li><li>练字</li></ul><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天感觉还是很充实的，虽然看下来没有做些什么，但是其实又做了一点什么。感觉需要上计网和机组了…想要找一点对应的题做，不知道去年的王道的书被我丢哪儿了…没事儿，从网上找点对应题应该也不错。今天发现了一个写leetCoded总结很好的项目，之后就跟这个吧。我感觉明天常用类也能差不多，感觉在常用类上耗太久了，之后边用边学吧。今天终于是不咕鸟了，早点休息，想要拥有正常的作息。</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>leetcode一个专题</li><li>Java集合、IO</li><li>计网和机组</li><li>练字</li></ol><hr><p>♨️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Character类、Math类、Number类&lt;/li&gt;
</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划问题</title>
    <link href="https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-03T06:04:03.000Z</published>
    <updated>2021-03-07T08:34:39.144Z</updated>
    
    <content type="html"><![CDATA[<p>一般形式是求最值，比如说最长递增子序列，最小编辑距离。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>求最值，把所有的可行答案穷举出来，然后找最值就ok。</p><p><em>动态规划</em>不是简单的穷举，因为动态规划问题存在<strong>「重叠子问题」</strong>，暴力穷举会效率很低，所以需要「备忘录」或者「DP table」来优化穷举的过程，避免不必要的计算。</p><p>并且动态规划一定会具备<strong>「最优子结构」</strong>，才能通过子问题的最值的到原问题的最值。<br>需要列出正确的<strong>「状态转移方程」</strong>才能正确的穷举。在实际的算法问题中，写出「状态转移方程」是最困难的。所以提供了一个思维框架辅助思考状态转移方程：</p><p><strong>明确base case -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义</strong></p><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h2><h3 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法"></a>暴力递归法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法十分的低效，假设n = 20，画出递归树：</p><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure1.png" alt="figure1"></p><p>PS：画出递归树是分析递归问题的好方法。</p><h4 id="递归算法的时间复杂度计算"><a href="#递归算法的时间复杂度计算" class="headerlink" title="递归算法的时间复杂度计算"></a>递归算法的时间复杂度计算</h4><p>首先计算子问题数，由图可以看出斐波那契数列是满二叉树，所以子问题的个数为<script type="math/tex">O(2^n)</script></p><p>然后计算每个子问题的时间，此算法没有循环，只有一个递归基和<code>f(n - 1) + f(n - 2)</code>，所以时间复杂度为<script type="math/tex">O(1)</script></p><p>递归算法的时间复杂度为子问题数 <script type="math/tex">\times</script> 子问题的时间。由此可得：斐波那契的暴力递归解法的时间复杂度为 <script type="math/tex">O(2^n)</script></p><p>观察递归树，可以发现：存在了大量的重复计算，比如<code>f(18)</code>被计算了两次，而<code>f(18)</code>为根的递归树体量巨大，多算一遍会耗费巨大的时间，在递归中出现了多次这样的情况，使得重复进行了多次相同的运算，使得这个算法十分低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。</p><h3 id="如何解决「重叠子问题」的问题"><a href="#如何解决「重叠子问题」的问题" class="headerlink" title="如何解决「重叠子问题」的问题"></a>如何解决「重叠子问题」的问题</h3><h4 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h4><p>我们可以造一个「备忘录」，每次计算出某个子问题的答案之后，先记入「备忘录」，然后再返回。每次遇到一个子问题先去「备忘录」中查查，如果发现已经解决过这个问题，就直接把答案拿出来用，就不用再次计算了。</p><p>一般使用数组充当这个「备忘录」，当然也可以用哈希表（字典）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int memoFib(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">&#x2F;&#x2F; 为了提高代码的可读性，所以开辟了n+1，这样每个fib数将会与相应的下标对应</span><br><span class="line">int[] memoArray() &#x3D; new int[n+1];</span><br><span class="line"></span><br><span class="line">return helper(memoArray(), n);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造memArray()</span><br><span class="line">public int memArray(int[] memo, int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line">if(memo[n] !&#x3D; 0)</span><br><span class="line">return memo[n];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归体</span><br><span class="line">memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2);</span><br><span class="line"></span><br><span class="line">return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><h4 id="dp数组迭代解法"><a href="#dp数组迭代解法" class="headerlink" title="dp数组迭代解法"></a>dp数组迭代解法</h4><p>有了上一步「备忘录」的启发，我们可以把「备忘录」独立出来成为一张表，就叫做DP table。在这张表上完成「自底向上」的推算岂不美哉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int dpTable(int n)&#123;</span><br><span class="line">if(n &lt; 0)</span><br><span class="line">return 0;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)</span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构建dpTable</span><br><span class="line">int[] dp &#x3D; new int[n + 1];</span><br><span class="line">dp[1] &#x3D; 1;</span><br><span class="line">dp[2] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">dp[i] &#x3D; dp[i - 1] + dp[1 - 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/figure2.jpg" alt="figure2"></p><p><strong>「状态转移方程」</strong>：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}1, n = 1,2 \\f(n-1) + f(n-2), n>2 \\\end{aligned}\right.</script><p>这里把<code>f(n)</code>想做状态<code>n</code>，状态<code>n</code>是由状态<code>n-1</code>和状态<code>n-2</code>相加转移而来的，这就叫状态转移。</p><p>所以要先想出暴力解，然后通过暴力解的到转移方程，再通过备忘录或者DP table优化。</p><p><strong>fib还可以优化</strong><br>甚至不需要整个dpTable，只需要记载n，n-1，n-2三个值就ok，此时的复杂度降到了<em>O(1)</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int bestFib(int n)&#123;</span><br><span class="line">int num1 &#x3D; 1;</span><br><span class="line">int num2 &#x3D; 1;</span><br><span class="line">int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">num &#x3D; num1 + num2;</span><br><span class="line">num1 &#x3D; num2;</span><br><span class="line">num2 &#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法叫做「状态压缩」，当我们发现状态转移时只需要用上DP table中的一部分，那样就可以尝试用状态压缩来缩小DP table。</p><h2 id="322-凑零钱"><a href="#322-凑零钱" class="headerlink" title="322.凑零钱"></a>322.凑零钱</h2><p>题目：给你<code>k</code>中面值的硬币，面值分别为<code>c1, c2, ...,ck</code>，美中硬币的数量无限，再给一个总金额<code>amount</code>，问最少需要几枚硬币来凑出这个金额，如果凑不出，返回<code>-1</code>。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合<strong>「最优子结构」</strong>，<strong>子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p><p>比如说，假设考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><h3 id="如何列出正确的状态转移方程"><a href="#如何列出正确的状态转移方程" class="headerlink" title="如何列出正确的状态转移方程"></a>如何列出正确的状态转移方程</h3><ol><li><p><strong>确定 base case</strong>，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p><strong>确定「状态」</strong>，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p></li><li><strong>确定「选择」</strong>，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li><li><strong>明确 dp 函数/数组的定义</strong>。这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：</li></ol><p><code>dp(n)</code> ：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p><p>然后就可以得到状态转移方程</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}0, n=0 \\-1, n<0 \\min\{dg(n-coin) + 1|coin \in coins\}, n>0\end{aligned}\right.</script><h3 id="带备忘录的递归解法-1"><a href="#带备忘录的递归解法-1" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public int getCoinsMemo(int[] coins, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int[] memo &#x3D; new int[n + 1];</span><br><span class="line">    return helper(coins, memo, n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public int helper(int[] coins, int[] memo, int n) &#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[n] !&#x3D; 0)</span><br><span class="line">        return memo[n];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;得到当💰需要的coin数</span><br><span class="line">    int cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int coinNum &#x3D; 0;</span><br><span class="line">    for (int coin : coins) &#123;</span><br><span class="line">        coinNum &#x3D; helper(coins, memo, n - coin);</span><br><span class="line">        &#x2F;&#x2F; 当小于0或者这个子方法表示不出的时候</span><br><span class="line">        if (n - coin &lt; 0 || coinNum &#x3D;&#x3D; -1)</span><br><span class="line">            continue;</span><br><span class="line">        if (coinNum + 1 &lt; cur) &#123;</span><br><span class="line">            cur &#x3D; coinNum + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cur &#x3D;&#x3D; Integer.MAX_VALUE)&#123;</span><br><span class="line">        cur &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] &#x3D; cur;</span><br><span class="line">    return cur;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自底向上的DPtable方法"><a href="#自底向上的DPtable方法" class="headerlink" title="自底向上的DPtable方法"></a>自底向上的DPtable方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自底向上DPtable方法</span><br><span class="line">public int getCoinsDP(int[] coins, int sum) &#123;</span><br><span class="line">    if (sum &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if (sum &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp[] &#x3D; new int[sum + 1];</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    int cur;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; sum; i++) &#123;</span><br><span class="line">        cur &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            if (i - coin &lt; 0 || dp[i - coin] &#x3D;&#x3D; -1)</span><br><span class="line">                continue;</span><br><span class="line">            if (dp[i - coin] + 1 &lt; cur)</span><br><span class="line">                cur &#x3D; dp[i - coin] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur &#x3D;&#x3D; Integer.MAX_VALUE)</span><br><span class="line">            dp[i] &#x3D; -1;</span><br><span class="line">        else</span><br><span class="line">            dp[i] &#x3D; cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就是那个步骤：</p><p><strong>明确base case（递归基） -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 -&gt;优化</strong></p><h3 id="「备忘录」自上而下的方法"><a href="#「备忘录」自上而下的方法" class="headerlink" title="「备忘录」自上而下的方法"></a>「备忘录」自上而下的方法</h3><p>其实就是一种递归的优化方法，消除了很多重复计算的部分，所以优化了方法，但是还是没有自下而上好。</p><h3 id="「DPtable」自下而上的方法"><a href="#「DPtable」自下而上的方法" class="headerlink" title="「DPtable」自下而上的方法"></a>「DPtable」自下而上的方法</h3><p>当我们分析出「状态转移方程」后，就可以自下而上构造<code>dp[]</code>（其实就是备忘录），然后直接从中取得就OK。</p><hr><p>refer：<br><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架</a></p><p><a href="https://github.com/Luoyongjia/leetCode/tree/main/src/dynamicProgramming">Code</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般形式是求最值，比如说最长递增子序列，最小编辑距离。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;求最值，把所有的可行答案穷举出来，然后找最值就ok。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://luoyongjia.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月2日</title>
    <link href="https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/"/>
    <id>https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/</id>
    <published>2021-01-02T15:04:58.000Z</published>
    <updated>2021-03-06T12:00:52.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天干了些什么"><a href="#今天干了些什么" class="headerlink" title="今天干了些什么"></a>今天干了些什么</h2><ul><li>英语听力</li><li>Object类</li></ul><h2 id="过程中遇见的问题"><a href="#过程中遇见的问题" class="headerlink" title="过程中遇见的问题"></a>过程中遇见的问题</h2><p>Object类太难了，套娃一样，lei了。从Object到String到Integer…希望明天能简单一点。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>方法有问题，明日改方法。希望每天的时间能够均匀一点，不要总扑在一件事情上。明天中午睡觉不脱裤子，不然又会睡过，今天中午就睡了一个半小时，起床之后还泡了一杯奶茶…但是还是消除不了Object带来的心累。害，明天一定不会这么苦，希望拥有正常的作息。☕️</p><h2 id="明日规划"><a href="#明日规划" class="headerlink" title="明日规划"></a>明日规划</h2><ol><li>英语听力</li><li>letcode中的3题，一定要开始！</li><li>Java两个类的使用</li><li>剑指offer的2题</li><li>练字</li></ol><hr><p>今天又是鸽子精，希望明天能做不咕鸟🐦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天干了些什么&quot;&gt;&lt;a href=&quot;#今天干了些什么&quot; class=&quot;headerlink&quot; title=&quot;今天干了些什么&quot;&gt;&lt;/a&gt;今天干了些什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;英语听力&lt;/li&gt;
&lt;li&gt;Object类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;过程中</summary>
      
    
    
    
    <category term="日记" scheme="https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
