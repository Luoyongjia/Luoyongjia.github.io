{"meta":{"title":"Gugugu's blog","subtitle":"","description":"","author":"罗咏佳","url":"https://luoyongjia.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-29T09:46:39.905Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"/404.html","permalink":"https://luoyongjia.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-29T09:50:25.856Z","updated":"2020-12-29T09:50:25.846Z","comments":false,"path":"about/index.html","permalink":"https://luoyongjia.github.io/about/index.html","excerpt":"","text":"是鸽子精本精"},{"title":"书单","date":"2020-12-29T09:45:56.166Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"books/index.html","permalink":"https://luoyongjia.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-29T15:52:32.625Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"categories/index.html","permalink":"https://luoyongjia.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-29T09:45:56.181Z","updated":"2020-12-29T06:21:42.127Z","comments":true,"path":"links/index.html","permalink":"https://luoyongjia.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-29T09:45:56.196Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"repository/index.html","permalink":"https://luoyongjia.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-29T09:45:56.211Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"tags/index.html","permalink":"https://luoyongjia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【数据结构】绪论","slug":"【数据结构】绪论","date":"2021-03-06T12:27:22.000Z","updated":"2021-03-06T13:21:35.100Z","comments":true,"path":"2021/03/06/【数据结构】绪论/","link":"","permalink":"https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。 基本概念很好，记不住的东西。 数据 是信息，是数据，是程序直接处理的原料。数据元素 数据元素含有数据，是由一群数据组成的最小的、不可分割的最小单位。比如说，一个学生（包括他的姓名、学号、年龄等）就是一个数据元素。数据对象 一群同类型的数据元素组成的。比如说，学生对象，就是由一群学生对象组成的。数据类型 就比如说byte, short, int, long这些。就是一种数值的集合。其下面又有原子类型、结构类型、抽象数据类型，分别表示值不可分，值可以分，数据和与之相关的操作。数据结构 诶嘿，终于到它了。数据结构是有关系的数据元素的集合。包括逻辑结构，存储结构和数据的运算（个人理解为方法）。 数据结构三要素我觉得这里主要是在讲逻辑结构与存储结构。还有一个名词叫“物理结构”，我在这里将会把他们仨分清楚。 逻辑结构逻辑逻辑嘛，那当然是一种抽象的东西，我们不考虑他们的实际应该怎么样，只去考虑这样子特性的数据有些什么特色，可以怎么操作。 这里要解释一下集合，就是一群数据挤到一起，没有其他联系这样子。 存储结构（物理结构）就是解决如何将数据存储的问题。 数据的运算个人理解，就是操作、方法这种东西。 这里来几道错题加深理解 可以用（ ）来定义一个完整的数据结构A. 数据元素 B.数据对象 C.数据关系 D. 抽象数据类型这里，👀上面的基本概念，就能得出答案D 以下属于逻辑结构的是（ ）A. 顺序表 B. 哈希表 C. 有序表 D. 单链表顺序表、哈希表、单链表，既可以表示逻辑结构，又可以表示存储结构。只有有序表是单纯的。 以下数据与数据的存储结构无关的术语是（ ）A. 循环队列 B. 链表 C. 哈希表 D. 栈B和C都很好排除。循环队列为一种数据结构？（这里存疑，之后来解决）可能是因为，他包含顺序表的逻辑结构，和顺序存储的存储结构，以及一些操作方法。讲真，不知道如何区分数据结构和逻辑结构的区别。问问后来补充。 在存储数据时，通常不仅要存储个数据元素的值，而且要存储( )A. 数据的操作方法 B. 数据元素的类型 C. 数据元素之间的关系 D. 数据存取的方法D，这没啥好说的，记住就好。 算法评价算法，对于一个问题的解决方法逐步描述。 一些性质有穷性 是不是有穷时间能跑完确定性 描述是不是无歧义的可行性 电脑能不能跑起来I/O 输入输出正确性 能不能正确解决问题可读性 是不是很好理解健壮性 能不能面对攻击效率 效率就是效率，时间、空间效率 时间复杂度、空间复杂度这种主要考：给段代码，然后让算复杂度。 注意点：O(1)的可以是常数级别的复杂度。 refer 数据结构之逻辑结构与物理结构（存储结构）","categories":[{"name":"考研复试","slug":"考研复试","permalink":"https://luoyongjia.github.io/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"}],"tags":[]},{"title":"再开公告","slug":"再开公告","date":"2021-03-06T11:56:28.000Z","updated":"2021-03-06T12:19:28.588Z","comments":true,"path":"2021/03/06/再开公告/","link":"","permalink":"https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/","excerpt":"","text":"很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。 之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找别人讨论；看元学习那篇大论文的时候，因为很多数学知识不了解，又放弃（过了一段时间明白了之中的大概原理）。当然，可能因为当初想的很多的时候，人还很小；来到大学了之后接触了更多的东西，选择多了，人也就迷惑了。 但是我觉得，我的绝望，很多是来源与我自己。我总觉得自己应该成为一个了不起的人，但是，大多数人最终不是还是普通人吗？我打算认命的，但是我做了什么呢？在家摸鱼摸了俩月。看出来了吧，就是因为自己骨子里的懒惰。考研的时候也是这样，学了两天之后，得休息上三天，才能继续。恨自己的不争气，却又一再地放纵。还有遇见了困难，总是想逃避，总想过着当下混沌又舒适的生活。可是这样的生活，我过得也很难受。总的来说，就是想要摆脱现状，但是又没有行动这样子。 认识到问题，当然得改。我试着去改改吧，这样下去不是个事儿。就从这次准备复试开始吧。 接下来想要在blog上分享一下我每天为复试准备的知识，以及每次上完TOEFL课的小总结这样子。 偷偷放一张喜欢的焦糖太太的图。","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"String，StringBuffer和StringBuilder类","slug":"String，StringBuffer和StringBuilder类","date":"2021-01-08T10:14:09.000Z","updated":"2021-01-08T10:16:39.200Z","comments":true,"path":"2021/01/08/String，StringBuffer和StringBuilder类/","link":"","permalink":"https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/","excerpt":"","text":"String，StringBuffer和StringBuilder类StringString对象的值是无法改变的！要改变，请找String Buffer和String Builer 创建1234String str0 &#x3D; &quot;Gugugu&quot;;String str1 &#x3D; &quot;Gugugu&quot;;String str2 &#x3D; new String(&quot;Gugugu&quot;);String str3 &#x3D; new String(&quot;Gugugu&quot;); str0和str1都是指向公共池中相同的地址，而str2和str3指向堆中的不同地址。 方法str0.length() 获取长度 str0.concat(str1) 连接两个字符串，返回的是创建的一个新字符串，可以自己连自己。 String.format(“balabalabala是%f”, floatVar) 就跟printf一样。String（java）里面是百分号诶。 char charAt(int index) 返回指定下标的字符 int indexOf(int ch) 返回第一次出现ch（or str）的下标，如果没有就-1 int compareTo(String str) 字典序比较字符串 int compareTolgnoreCase(String str) 不考虑大小写的比较字符串 boolean contentEquals(StringBuffer sb) 与指定的StringBuffer有相同顺序的字符时返回true static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示改字符的序列的String。offset是开始点。 char[] toCharArray() 转换为字符数组 String toLowerCase() 全部转小写 String toUpperCase() 全部转大写 isEmpty() 判断字符串是否为空 String Buffer和String BuilderStringBuffer和StringBuilder类的对象能够被多次修改，不产生新的未使用对象。 StringBuilder和StringBuffer最大的不同在于StringBuilder的方法不是线程安全的（不能同步访问）。 StringBuilder运行速度比StringBuffer快。 refer:Java String 类Java StringBuffer 和 StringBuilder 类","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"2021年1月3日","slug":"2021年1月3日","date":"2021-01-03T15:43:55.000Z","updated":"2021-01-03T15:52:06.734Z","comments":true,"path":"2021/01/03/2021年1月3日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 Character类、Math类、Number类 动态规划问题，三道题 练字 今日总结今天感觉还是很充实的，虽然看下来没有做些什么，但是其实又做了一点什么。感觉需要上计网和机组了…想要找一点对应的题做，不知道去年的王道的书被我丢哪儿了…没事儿，从网上找点对应题应该也不错。今天发现了一个写leetCoded总结很好的项目，之后就跟这个吧。我感觉明天常用类也能差不多，感觉在常用类上耗太久了，之后边用边学吧。今天终于是不咕鸟了，早点休息，想要拥有正常的作息。 明日规划 英语听力 leetcode一个专题 Java集合、IO 计网和机组 练字 ♨️","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"动态规划问题","slug":"动态规划问题","date":"2021-01-03T06:04:03.000Z","updated":"2021-01-03T09:06:02.478Z","comments":true,"path":"2021/01/03/动态规划问题/","link":"","permalink":"https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"一般形式是求最值，比如说最长递增子序列，最小编辑距离。 基本原理求最值，把所有的可行答案穷举出来，然后找最值就ok。 动态规划不是简单的穷举，因为动态规划问题存在「重叠子问题」，暴力穷举会效率很低，所以需要「备忘录」或者「DP table」来优化穷举的过程，避免不必要的计算。 并且动态规划一定会具备「最优子结构」，才能通过子问题的最值的到原问题的最值。需要列出正确的「状态转移方程」才能正确的穷举。在实际的算法问题中，写出「状态转移方程」是最困难的。所以提供了一个思维框架辅助思考状态转移方程： 明确base case -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 509.斐波那契数列暴力递归法1234int fib(int n)&#123; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; return fib(n - 1) + fib(n - 2);&#125; 这种方法十分的低效，假设n = 20，画出递归树： PS：画出递归树是分析递归问题的好方法。 递归算法的时间复杂度计算首先计算子问题数，由图可以看出斐波那契数列是满二叉树，所以子问题的个数为O(2^n) 然后计算每个子问题的时间，此算法没有循环，只有一个递归基和f(n - 1) + f(n - 2)，所以时间复杂度为O(1) 递归算法的时间复杂度为子问题数 \\times 子问题的时间。由此可得：斐波那契的暴力递归解法的时间复杂度为 O(2^n) 观察递归树，可以发现：存在了大量的重复计算，比如f(18)被计算了两次，而f(18)为根的递归树体量巨大，多算一遍会耗费巨大的时间，在递归中出现了多次这样的情况，使得重复进行了多次相同的运算，使得这个算法十分低效。 这就是动态规划问题的第一个性质：重叠子问题。 如何解决「重叠子问题」的问题带备忘录的递归解法我们可以造一个「备忘录」，每次计算出某个子问题的答案之后，先记入「备忘录」，然后再返回。每次遇到一个子问题先去「备忘录」中查查，如果发现已经解决过这个问题，就直接把答案拿出来用，就不用再次计算了。 一般使用数组充当这个「备忘录」，当然也可以用哈希表（字典）。 1234567891011121314151617181920public int memoFib(int n)&#123; if(n &lt; 0) return 0; &#x2F;&#x2F; 为了提高代码的可读性，所以开辟了n+1，这样每个fib数将会与相应的下标对应 int[] memoArray() &#x3D; new int[n+1]; return helper(memoArray(), n);&#125;&#x2F;&#x2F; 构造memArray()public int memArray(int[] memo, int n)&#123; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; if(memo[n] !&#x3D; 0) return memo[n]; &#x2F;&#x2F; 递归体 memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2); return memo[n];&#125; 这种方法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。 dp数组迭代解法有了上一步「备忘录」的启发，我们可以把「备忘录」独立出来成为一张表，就叫做DP table。在这张表上完成「自底向上」的推算岂不美哉。 12345678910111213141516public int dpTable(int n)&#123; if(n &lt; 0) return 0; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; &#x2F;&#x2F; 构建dpTable int[] dp &#x3D; new int[n + 1]; dp[1] &#x3D; 1; dp[2] &#x3D; 1; for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123; dp[i] &#x3D; dp[i - 1] + dp[1 - 2]; &#125; return dp[n];&#125; 「状态转移方程」： f(x)=\\left\\{ \\begin{aligned} 1, n = 1,2 \\\\ f(n-1) + f(n-2), n>2 \\\\ \\end{aligned} \\right.这里把f(n)想做状态n，状态n是由状态n-1和状态n-2相加转移而来的，这就叫状态转移。 所以要先想出暴力解，然后通过暴力解的到转移方程，再通过备忘录或者DP table优化。 fib还可以优化甚至不需要整个dpTable，只需要记载n，n-1，n-2三个值就ok，此时的复杂度降到了O(1)。 12345678910111213public int bestFib(int n)&#123; int num1 &#x3D; 1; int num2 &#x3D; 1; int num &#x3D; 0; for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123; num &#x3D; num1 + num2; num1 &#x3D; num2; num2 &#x3D; num; &#125; return num;&#125; 这种方法叫做「状态压缩」，当我们发现状态转移时只需要用上DP table中的一部分，那样就可以尝试用状态压缩来缩小DP table。 322.凑零钱题目：给你k中面值的硬币，面值分别为c1, c2, ...,ck，美中硬币的数量无限，再给一个总金额amount，问最少需要几枚硬币来凑出这个金额，如果凑不出，返回-1。 暴力解法首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？用一个直观的例子来讲解。 比如说，假设考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。 回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。 如何列出正确的状态转移方程 确定 base case，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。 确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。 确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。 明确 dp 函数/数组的定义。这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数： dp(n) ：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。 然后就可以得到状态转移方程 f(x)=\\left\\{ \\begin{aligned} 0, n=0 \\\\ -1, n0 \\end{aligned} \\right.带备忘录的递归解法123456789101112131415161718192021222324252627282930313233343536373839public int getCoinsMemo(int[] coins, int n) &#123; if(n &lt; 0) return -1; if(n &#x3D;&#x3D; 0) return 0; int[] memo &#x3D; new int[n + 1]; return helper(coins, memo, n);&#125;public int helper(int[] coins, int[] memo, int n) &#123; if(n &lt; 0) return -1; if(n &#x3D;&#x3D; 0) return 0; if(memo[n] !&#x3D; 0) return memo[n]; &#x2F;&#x2F;得到当💰需要的coin数 int cur &#x3D; Integer.MAX_VALUE; int coinNum &#x3D; 0; for (int coin : coins) &#123; coinNum &#x3D; helper(coins, memo, n - coin); &#x2F;&#x2F; 当小于0或者这个子方法表示不出的时候 if (n - coin &lt; 0 || coinNum &#x3D;&#x3D; -1) continue; if (coinNum + 1 &lt; cur) &#123; cur &#x3D; coinNum + 1; &#125; &#125; if(cur &#x3D;&#x3D; Integer.MAX_VALUE)&#123; cur &#x3D; -1; &#125; memo[n] &#x3D; cur; return cur; &#125; 自底向上的DPtable方法12345678910111213141516171819202122232425&#x2F;&#x2F;自底向上DPtable方法public int getCoinsDP(int[] coins, int sum) &#123; if (sum &lt; 0) return -1; if (sum &#x3D;&#x3D; 0) return 0; int dp[] &#x3D; new int[sum + 1]; dp[0] &#x3D; 0; int cur; for (int i &#x3D; 1; i &lt;&#x3D; sum; i++) &#123; cur &#x3D; Integer.MAX_VALUE; for (int coin : coins) &#123; if (i - coin &lt; 0 || dp[i - coin] &#x3D;&#x3D; -1) continue; if (dp[i - coin] + 1 &lt; cur) cur &#x3D; dp[i - coin] + 1; &#125; if (cur &#x3D;&#x3D; Integer.MAX_VALUE) dp[i] &#x3D; -1; else dp[i] &#x3D; cur; &#125; return dp[sum];&#125; 总结就是那个步骤： 明确base case（递归基） -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 -&gt;优化 「备忘录」自上而下的方法其实就是一种递归的优化方法，消除了很多重复计算的部分，所以优化了方法，但是还是没有自下而上好。 「DPtable」自下而上的方法当我们分析出「状态转移方程」后，就可以自下而上构造dp[]（其实就是备忘录），然后直接从中取得就OK。 refer：动态规划解题套路框架 Code","categories":[{"name":"算法","slug":"算法","permalink":"https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/tags/leetcode/"}]},{"title":"2021年1月2日","slug":"2021年1月2日","date":"2021-01-02T15:04:58.000Z","updated":"2021-03-06T12:00:52.711Z","comments":true,"path":"2021/01/02/2021年1月2日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 Object类 过程中遇见的问题Object类太难了，套娃一样，lei了。从Object到String到Integer…希望明天能简单一点。 今日总结方法有问题，明日改方法。希望每天的时间能够均匀一点，不要总扑在一件事情上。明天中午睡觉不脱裤子，不然又会睡过，今天中午就睡了一个半小时，起床之后还泡了一杯奶茶…但是还是消除不了Object带来的心累。害，明天一定不会这么苦，希望拥有正常的作息。☕️ 明日规划 英语听力 letcode中的3题，一定要开始！ Java两个类的使用 剑指offer的2题 练字 今天又是鸽子精，希望明天能做不咕鸟🐦","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Object类","slug":"Object类","date":"2021-01-02T14:59:11.000Z","updated":"2021-01-02T15:07:15.747Z","comments":true,"path":"2021/01/02/Object类/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/","excerpt":"","text":"java.lang.Object 是一个根类，是老祖宗。 lang包不用导入，直接使用。 boolean equals(object obj)判断对象的地址是否相等。 123public boolean myEquals(MyObject obj)&#123;return this &#x3D;&#x3D; obj;&#125; 这里==比较的是两个对象在内存中的地址。 使用1objectName.equals(anOtherObject); equals()和==的区别 equals()是方法，==是操作符 ==能用于基本类型变量(byte, short, int, long, float, double)，但是equals()不能，equals()只能用于继承Object类的类的对象。 ==在基本类型变量的比较过程中比较的是基本类型变量值，==、equale()在对象的比较中都是比较的地址。可以将equals()重写来使其比较值。 对于String类的equals()重写重写euqals()应该遵循JavaSE的通用约定 自反性（reflexive）：对于任何非null引用值x，x.equals(x)必须返回true 对称性（symmetric）：对于任何非null引用值x和y，当且仅当x.equals(y)返回true时，y.equals(x)返回true 传递性（transitive）: 对于任何非null的引用值x, y和z， 如果x.equals(y)返回true, 并且y.equals(z)也返回true, 那么x.equals(z)也必须返回true。 一致性（consistent）: 对于任何非null的引用值x和y, 只要equals()的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true, 或者一致的返回false。 对于任何非null的引用值x，x.equals(null)必须返回false。 重写我搜了搜原码，发现在String类中的equals()没有写@Override，然后就去搜了一下，发现@Override是伪代码，可写可不写的，写上可以方便阅读、适合编译器给你检查。 String类中private final char[] value存储输入的值 123456789101112131415161718192021222324252627public boolean equals(Object anObject)&#123; &#x2F;&#x2F;判断地址是否相同 if(this &#x3D;&#x3D; anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anOtherString &#x3D; (String) anObject; int n &#x3D; value.length; &#x2F;&#x2F;判断长度是否相同 if(n &#x3D;&#x3D; anOtherString.value.length)&#123; char v1[] &#x3D; value; char v2[] &#x3D; anOtherString.value; int i &#x3D; 0; while(n-- !&#x3D; 0)&#123; if(v1[i] !&#x3D; v2[i]) return false; i++; &#125; &#x2F;&#x2F;当所有都比对过之后跳出while return true; &#125; &#x2F;&#x2F;当传入的Object都不是String类的情况 return false;&#125; final native Class&lt;?&gt; getClass();使用返回的是当前引用指向的实例的类。 1234567public static void main(String[] args) &#123; TestClass test1 &#x3D; new TestClass(); Object test2 &#x3D; new TestClass(); System.out.println(&quot;test1 class &#x3D; &quot; + test1.getClass()); System.out.println(&quot;test2 class &#x3D; &quot; + test2.getClass());&#125; 输出的结果为： 12test1 class &#x3D; class src.TestClasstest2 class &#x3D; class src.TestClass nativenative是与C++联合开发时去使用的。使用native关键字说明这个方法是原生函数，也就是这个方法使用C/C++语言实现的，并且被便衣成了dll，由java去调用。 C++源码挖坑 native int hashCode();使用1objectName.hashCode(); C++源码挖坑 重写hashCode()方法应该遵循JavaSE的通用约定 在应用程序的执行期间，只要对象的equals()的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次hashCode()，它必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同。 如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode()必须产生同样的整数结果。 如果两个对象根据equals(Object)是不相等的，那么调用这两个对象中任一个对象的hashCode()，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。 所以根据第2条可以看出，重写了equals()方法之后必须重写hashCode()方法，这两个方法相互对应。 String重写hashCode()方法在原String类中，其直接改变了hashCode的生成方式。 12345678910111213141516public int hashCode()&#123; &#x2F;&#x2F;hash的默认值为0，为String类的一个private属性 int h &#x3D; hash; &#x2F;&#x2F;当String实例中value不为空时，hashCode根据value的内容产生 if(h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0)&#123; char val[] &#x3D; value; for(int i &#x3D; 0; i &lt; value.length; i++)&#123; h &#x3D; 31 * h + val[i]; &#125; hash &#x3D; h; &#125; return h;&#125; String toString()把对象中的值以字符串的形式展示出来 源码套中套中套中套 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;&#x2F;哈希码转Stringpublic String toString()&#123;return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;...&#x2F;&#x2F;Integer类&#x2F;&#x2F;toHexString(int i)方法public static String toHexString(int i)&#123; return toUsignedString0(i, 4);&#125;&#x2F;* * toUnsignedString0方法 * Convert the integer to an unsigned number. * 将一群数字变成String *&#x2F; private static String toUnsignedString0(int val, int shift)&#123; &#x2F;&#x2F;assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D; 5 : &quot;Illegal shift value&quot;; &#x2F;&#x2F;删除头部的0 int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val); &#x2F;&#x2F;私以为：判断一共有几位（一位有shift个码），最小为1 int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1); &#x2F;&#x2F;创建字符串容器了，用来装输出的String char[] buf &#x3D; new char[chars]; formatUnsignedInt(val, shift, buf, 0, chars); return new String(buf, true); &#125; &#x2F;* 将一串unsigned数据转换为字符串 val, 需要被转换的unsigned int shift，分组的过程(4 for hex, 3 for octal, 1 for binary) buf, 存储内容的对应2^shift进制的数字 offset，开始读val的位置 len，要写入的char的数量 return 写入第一个char的下标*&#x2F;static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)&#123; int charPos &#x3D; len; &#x2F;&#x2F;得到对应进制的掩码 &#x2F;&#x2F;eg: 16-&gt;1 0000 int radix &#x3D; 1 &lt;&lt; shift; &#x2F;&#x2F;1 0000 - 1 -&gt; 1111 int mask &#x3D; radix - 1; &#x2F;&#x2F;当val非空且还有未读的位时 do&#123; &#x2F;&#x2F;将当前位置的值与掩码做比较，存下这一位的值 buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask]; &#x2F;&#x2F;下一位，val右移shif位 val &gt;&gt;&gt;&#x3D; shift; &#125;while(val !&#x3D; 0 &amp;&amp; charPos &gt; 0) return charPos;&#125;&#x2F;&#x2F;就是一个进制转换表final static char[] digits &#x3D; &#123; &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; , &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; , &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; , &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; , &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; , &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39; &#125;; 使用普通的： 123objectName.toString()return: className@地址 重写了hashCode的类，可能也会重写这个函数，这个函数主要还是根据哈希值来得到内容的。 refer： JDK源码阅读（一）：Object源码分析 说说如何重写Java的equals方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"2021年1月1日","slug":"2021年1月1日","date":"2021-01-01T16:14:30.000Z","updated":"2021-01-03T15:45:17.287Z","comments":true,"path":"2021/01/02/2021年1月1日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 年度计划（永远立不起来的flag） Java基础语法 过程中遇见的问题无，详情请见Java基础语法以及易忽略点总结 今日总结今天睡得很开心，中午也睡了午觉。任务太多了，完不成。所以决定调整计划，明天希望过得轻松一点。空调温度果然还是需要调高一点，下午20度真的冻死我了。（附：还是好想去自习室，元旦特惠没有了，有点可惜）。 明日规划flag永不倒！！！！ 找2个类学学 英语听力 leetcode-3个题 开题报告开题报告开题报告开题报告 剑指offer2个题 练字 明天一定是 不 咕 鸟🐦！！！","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Java基础语法以及易忽略点总结","slug":"Java基础语法以及易忽略点总结","date":"2021-01-01T16:09:10.000Z","updated":"2021-01-01T16:10:40.570Z","comments":true,"path":"2021/01/02/Java基础语法以及易忽略点总结/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"非常主观 非常主观 非常主观！ 类型基本类型： byte, short, int, long, float, double, char, boolean（low —— high）引用类型：类，接口，数组 类型转换在运算中，不同类型的数据都会先转化为较高的那一类，然后再进行运算 而由高转低 1((低类型) 变量名) 变量Java是一种强类型语言，也就是说每个东西都要有它明确的属性，不像Js、Python。 作用域个人jio得这个可以去康康我之前那篇由JVM内存划分与职能到值传递和引用传递。这里就做一个简单的描述。 静态变量：也就是类变量，当类加载时就存在的变量，只加载一次，不能改变。 实例变量：也就是成员变量，在类实例化时加载，存在那个实例里面。 局部变量：一次性变量，即用即删。生存周期同存在的方法时间相同。 数字里面可以带_，更容易理解，JDK新功能。 常量就是特殊的变量，在程序运行过程中保持不变。 1final Type name &#x3D; xxx; 命名不要以_或$开始或者结束。不要用拼音（除非国际通用的国内代名词）。 类名 开头大写的驼峰式。 方法名、参数名、成员变量、局部变量 同一使用开头小写的驼峰式。 常量 全部大写，单词之间用_隔开。 抽象类用Abstract或Base开头；异常类用Exception结尾；测试类用Test结尾。 运算符自增自减运算符a++ 先加，再拿a进行操作 ++a 先拿a进行操作，再加 — 同理 位运算符&amp; 将两个数字都转换为二进制后，两个数字在当位上都为1时此位为1，否则则为0 | 两个数字在当位上只需要有一个为1，则此位为1。 ^ 当两个数字当位上的数字不一样，则为1，相同则为0 ～ 当前数字二进制取逆 1234567A &#x3D; 0011 1001B &#x3D; 0000 0101A &amp; B &#x3D; 0000 0001A | B &#x3D; 0011 1101A ^ B &#x3D; 0011 1100~B &#x3D; 1111 1010 移位运算&lt;&lt; 向左移，高位溢出舍弃高位。补码啊…我都忘记了，等我机组学到这里再来补。负数无符号右移，用1填补。正数用0填补。 &gt;&gt; 向右移，同&lt;&lt; &gt;&gt;&gt; 无符号版本，都是补0 包机制导包： import 命名：通常用域名的倒置座位包名 12eg: www.baidu.com包的格式就为：com.baidu.www Java Doc生成文档，超级6。文档注释。首先来个Doc.java 123456789101112131415161718192021&#x2F;**** @author name* @ version 1.0* @since 1.8 *&#x2F;public class Doc&#123; String name; &#x2F;** * * @author xxx * @param name * @return * @throws Exception *&#x2F; public String test(String name)&#123; &#125;&#125; 方法中/**回车自动生成。 主要的有些： 123456@author@version@since jdk支持的最老版本@palam 参数名@return@throw 异常抛出 然后命令行当前路径 1javadoc -encoding UTF-8 -charaset UTF-8 Doc.java javadoc生成文档命令。 Scanner来自于java.util.Scanner的输入 Scanner对象的常用操作： 12345scanner.next() &#x2F;&#x2F;读取输入的字符，空格断开scanner.nextLine() &#x2F;&#x2F;读取当前行的输入scanner.hasNext() &#x2F;&#x2F;判断之后还有没有输入scanner.hasNextLine() &#x2F;&#x2F;判断是否还有下一行的输入&#x2F;&#x2F;next后还可以加基本类名，则限定输入的类 Scanner读取规则next() 要读到有效字符后的第一个空格或者换行符后结束。光标指向此空格之后 nextLine() 读完一行之后，光标指向下一行的开头 scanner.close()慎用！慎用！慎用！ 只要调用了这个函数后，之后新建的Scanner对象就无效了。但是也不能忘记在程序的结尾处，开了几个Scanner就关几个Scanner。 反编译VSCode还不知道怎么搞，坑先挖这儿吧。 重载就是名称相同，通过输入的参数的类型不同而调用不同的方法的功能。（写好几个相同名字的方法） 命令行参数你是否还记得： 1234...public static void main(String[] args)&#123;&#125; 中的args，这里就是用来实现命令行参数的，先在当前路径javac **.java编译。然后退到src文件夹（根文件夹）再 1java 此文件所在的相对位置.**.class 输入输入输入 可变参数在参数的最后， 1dataType ...a) 就可以输入多个这个类型的参数。 数组动态数组： 12dataType[] name &#x3D; new dataType[size];dataType[][] name1 &#x3D; new dataType[rowNum][colNum]; 初始化为0.. 静态数组： 12dataType[] name2 &#x3D; &#123;1, 2, 3, 4, 5&#125;;dataType[][] name3 &#x3D; &#123;&#123;1, 2&#125;,&#123;3, 4&#125;&#125;; 方法方法之间的调用当两个方法都为静态方法或者非静态方法的时候，它们之间可以相互调用，但一个静态一个非静态时，不可以相互调用。 构造器1public ClassName(); 当重写了构造器（有输入）之后需要重写一个没输入的才能实现继承。 多态假设现在这里有Father类，Son类继承Father类。假设他们都有eat()方法。 12345Father fater &#x3D; new Son();Son son &#x3D; new Son();father.eat(); &#x2F;&#x2F;执行的是son中的eatson.eat(); &#x2F;&#x2F;执行的是son中的eat Father类引用只能调用Father类中存在的方法，father不能调用Son中独有的方法。两个类都有的方法调用实例化那个类的方法。 instanceof类之间是否存在关系。父子ok，对象作实例化类来判断 1A instance of B 静态作用域执行顺序 1234567static&#123; &#x2F;&#x2F; 静态代码块&#125;&#123; &#x2F;&#x2F; 匿名代码块&#125;&#x2F;&#x2F;构造方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月31日","slug":"12月31日","date":"2020-12-31T16:37:41.000Z","updated":"2021-01-03T15:45:30.262Z","comments":true,"path":"2021/01/01/12月31日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 hexo上传图片问题 Java基础语法 过程中遇见的问题hexo上传本地图片在尝试调用url无效之后，开始打起了装插件的想法，没想到又是个大坑。不过终究是解决了。 Step 1修改根目录的_config.ym中的 1post_asset_folder:true Step 2 安装正确版本的插件注意注意注意，我直接安装hexo-asset-image出现了图片被多加了一个/的问题，再搜，发现是这个包的问题，尝试了改index.js，发现无效，所以就卸载了： 1npm unisntall -g hexo-asset-image 然后安装正确版本hexo-asset-image-0.0.5.git 1npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save Step 3 插入图片🎉1![1](文章名字对应文件夹&#x2F;图片名) Java内容明日再更新，之后再加链接到这里今日总结其实一上午都没有学习，因为起得晚，再🐟一下就到十点了，好像因为晚上睡得晚，导致早上也起不来…无解。有点想去自习室，但是爹妈就是不同意，不知道为什么。新的一年到来了，希望一切都能变得好起来。 明日规划 英语听力 Java基础过完 新年计划（今天真的太困了…只能咕） Java基础的blog总结一下 开题报告开题报告开题报告！ 练字 letcode-3题（or more） refer：hexo本地图片不显示","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"由JVM内存划分与职能到值传递和引用传递","slug":"由JVM内存划分与职能到值传递和引用传递","date":"2020-12-31T14:52:00.000Z","updated":"2021-01-01T03:43:56.656Z","comments":true,"path":"2020/12/31/由JVM内存划分与职能到值传递和引用传递/","link":"","permalink":"https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"","text":"课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。 JVM内存划分与职能在java第一课中我们认识到了java程序都是运行在jvm上的，那jvm里面到底干了些什么呢？这里给出一个更加详细的程序执行图 内存划分由图可以得出，当java代码被翻译成字节码后，jvm开辟了一片新的内存空间（运行时数据区），下面依次来介绍其中的功能。 虚拟机栈方法被执行的地方，虚拟基站中存放着栈帧，方法调用的过程对应着栈帧在虚拟机中入栈到出栈的过程。 栈时私有的，也就是线程之间栈是隔离的。当程序某个线程开始执行一个方法，就会创建一个栈帧并入栈（于栈顶），方法结束后，栈帧出栈 下图为Java栈的模型及栈帧的组成： 局部变量表：储存方法中的局部变量，变量为基本数据类型时，存储值，变量为引用类时，存储引用类对象的地址 操作数栈：Java虚拟机的解释执行引擎常被称为“基于栈的执行引擎”，其中的栈为这个操作栈 指向运行时常量池的引用：可能用到的常量的引用 方法返回地址：存储方法执行完之后的返回地址 堆存储对象本身和数组，JVM中只有一个堆，所以堆是被所有线程共享的。 方法区一块线程共享的内存逻辑区域，JVM中只有一个方法区，存放一些线程可共享的内容。它是线程安全的，多个线程访问一个内容时，只有一个线程装载其数据，其他线程等待。 本地方法栈本地方法栈和虚拟机栈功能大约相同，线程私有。它和虚拟机栈之间的差别在于它主要为本地方法服务而虚拟机栈为Java方法服务。 程序计数器线程私有。记录当前线程所执行的字节码（*.class）的行号和指示器。字节码解释器工作就是通过改变计数器的值来选去下一条需要执行的字节码指令。个人认为程序计数器实现了Java的解释型语言性质。 数据存储数据基础知识 基本类型：byte, short, int, long, float, double, char, boolean 引用类型：类，接口，数组 12345678910111213public class Example&#123; public static PI &#x3D; 3.14;&#x2F;&#x2F;静态变量 private int name; &#x2F;&#x2F;成员变量 public void static main(String[] args)&#123; int a; &#x2F;&#x2F;局部变量 &#125; public int sum(int num1, int num2)&#123; int sum &#x3D; 0; &#x2F;&#x2F;局部变量 sum &#x3D; num1 + num2; return sum &#125; 数据在内存中存储方法基本数据局部变量直接存储在内存中的栈上，也就是之前提到过的“虚拟机栈”。 所以当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 成员变量也就是class中的一些属性变量，这些变量的生命周期同对象是一致的。 静态变量当类开始纯在，静态变量就储存在了堆中，当类被消灭的时候，它们才会被消灭。 引用数据引用数据传入时，传入的是存放变量内容的地址。 值传递与引用传递值传递可以简单的理解为上面对于成员变量的定义，一次性的变量。 当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 引用传递很好理解，就是将存变量值的堆中的地址给传进方法了，所以方法中对于传入的变量的更改实质上就是更改那个地址中存储的内容，一改则全改。eg: 123456789101112131415161718192021public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 结果将会是： 123传入的person的name：小明方法内重新赋值后的name：小红方法执行后的name：小红 在那篇博客中还发现了一片很好玩的问题： 还是刚刚那段代码 1234567891011121314151617181920212223public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); &#x2F;&#x2F;改变的地方 person &#x3D; new Person(); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 这个地方在PersonCrossTest方法里，person由原来指向小明的地址1改为了在方法中new Person()创建的临时的一个Person对象的地址2，在PersonCrossTest方法结束时地址2就被删除了，地址1中的内容并没有改变。 所以说，这里的引用传递其实是一个虚假的引用传递，不过是在栈帧中创建了一个变量存储传进来变量的地址。 终于写完了，今天就只加个总结吧，Java基础内容明日再更。 refer:这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"我的Java第一课","slug":"我的JAVA第一课","date":"2020-12-30T15:31:50.000Z","updated":"2020-12-31T03:42:56.384Z","comments":true,"path":"2020/12/30/我的JAVA第一课/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"基础概念不同的javaJavaSE: 标准版，适用于桌面程序与控制台的开发 JavaME: 嵌入式开发 JavaEE: 企业级开发，如Web服务器 动态性、多线程 Write Once, Run Anywhere JDK、JRE、JVMJVM(Java Virtual Machine)简单的来说，就是一个虚拟机，java程序都是基于这个虚拟机来跑的。 正是这个虚拟机使得Java能够屏蔽底层的差异，实现跨平台开发 JRE(Java Runtime Environment)包，JRE提供了Java的类库，其中包含了JVM JDK(Java Development Kit)开发者需要的东西，其中包括了很多开发工具 所以综上所述，它们仨的关系可以用这个图来表示： 接下来就开始上机操作了 配置环境JDK袜，这个真的，也有一点坑，我在官网上找了好久才找到下载的地方。这里直接指路吧。选择自己相应的版本然后注册（登陆）oracle账号就👌。 然后配置环境变量（仅限mac）。打开终端 1open -e .bash_profile 然后输入： 123456JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk你的版本.jdk&#x2F;Contents&#x2F;HomePATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 最后用： 1java-version 看java版本是不是跟自己的jdk装的版本一样就🉑️了 JDK内部探秘因为课里面讲了一点，所以也记了一下。就几个主要的文件夹。 \\bin 可执行的程序，比如说java、javac的运行程序就在这里面 \\include 因为Java是基于C、C++的嘛，这里面就有调用的一些C、C++的包 \\jre 运行环境 \\lib Java的库 \\src 一些Java类 我感觉这一块儿还不是太懂，之后有更深入了解了再来补充与修改 Hello world文本编辑器版本创建Hello.java写入： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 然后命令行进入对应文件夹 12javac Hello.javajava Hello 这里就出现一个问题了，为什么要先javac，然后再java呢这就不得不说一下Java的运行机制了。Java是集编译型与解释型的语言。javac就是起编译器的作用。生成字节码Hello.class，然后再进行之后的操作 VSCode版本step 1 下载插件 Language Support for Java™ by Red Hat Debugger for Java Java Test Runner Maven for Java Java Dependency Viewer Java Extension Pack step 2Ctrl+Shift+P输入Java: Configure Java Runtime修改默认JDK版本与路径 step 3可以开始创建工程，输入代码，然后run辣 其中遇见了一个奇葩问题我看课程中使用IDEA写的，在project/src/pakageName中直接写代码就能跑，但是在VSCode中不一样，需要在*.java文件的开头添加package src.pakageName; 具体是什么原因我也不大清楚，先记下来吧。 Refer：Java JDK, JRE and JVM 太懒了，图片先不整了，有缘再整 图片调整好辣，今天晚上一定要记一下这个坑 配置就到这儿啦，希望明天能过完基础语法🤡","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月30日","slug":"12-30","date":"2020-12-30T14:31:54.000Z","updated":"2021-01-03T15:45:45.812Z","comments":true,"path":"2020/12/30/12-30/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-30/","excerpt":"","text":"今天干了些什么 昨天规划的大约的工作安排做了 git就只学会了初始化，上传这样子 Java环境搭建，以及写了个hello world 过程中遇见的问题git就是从一个空白项目怎么配置到本地这样子 先创建一个空白的文件夹，我习惯是创建一个同名的，然后进入此文件夹的目录 1234git initgit remote add origin git@github.com: ... &#x2F;&#x2F;...是项目的路径git add .git push -u origin master &#x2F;&#x2F;这里要注意此电脑是master 或者用这种方法，在git add .之后 12git branch -M maingit push -u origin main 这样子就是main路径了。 删除了user文件夹下初始化过的.gith文件夹，vscode的sourceControl终于不现实5k+ changes了，我就觉得肯定是因为有个.git的问题 Java开发相关的问题这个我想重新写一篇blog来更全面的描述。 今日总结今日没有出门学习，感觉在家果然还是有点🐟的。也还行吧，早上起来床了，任务也完成得七七八八。Java的课上着感觉有点简单，但是还是跟着上下去吧，熟悉的就2倍速，不熟悉的再仔细听，我怕出现那种像高数课一样，突然什么都听不懂了。还是希望明天能够更高效吧。搞这些整得我觉得手机都不好玩了，真好。明天想要写一个年度总结，不知道有没有时间，或许就同日记一起写了，但是我觉得这俩还是有挺大区别的，日记主要还是记一下当日遇见的问题以及解决的方法。 明日规划 英语听力 letcode中的3题 Java语法学完（这个任务视难度而调整） 剑指offer-2题 至少把自己的开题报告好好康康 练字练字练字！ 每天都要开心哦🥳","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"春招准备规划【实时更新】","slug":"春招准备规划【实时更新】","date":"2020-12-30T04:02:12.000Z","updated":"2020-12-30T06:04:17.838Z","comments":true,"path":"2020/12/30/春招准备规划【实时更新】/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/","excerpt":"","text":"春招准备规划【实时更新】第一阶段（12.30-1.31）基础：算法基础这里采用剑指offer中的题和算法面试题汇总结合，每天做一定量（2+3） 手写代码手写代码手写代码！ Java基础上网课同时实践 其他基础看书+练题 方法针对性，手写代码。 目标：历届的笔试面试题 通过小公司面试积累经验，先从小公司开始 说话能力 每日任务 3+2 算法题 网络一课 机组一课 英语听力 练字","categories":[{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"2020年12月29日","slug":"12-29日总结","date":"2020-12-29T16:44:36.000Z","updated":"2021-01-03T15:45:53.849Z","comments":true,"path":"2020/12/30/12-29日总结/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-29%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天干了些什么 大约将博客搭起来了 了解了毕设中期需要做一些什么 开了蓝灯 过程中遇见的问题搭建博客git在post的过程中出现帐号错误原因：当初作死，就想换个github帐号重新开始，导致电脑中默认的git帐号密码有问题 解决方法：不仅仅是说我使用 123git config -list \\\\查询信息git config --global user.namegit config --global user.email 就可以了的，在不同的系统下操作不同，我此仅代表mac用户。 还需要删除钥匙串访问中的github.com项 关于hexo pure主题配置的一堆破事所以在这里写下从头开始应该怎么配置pure主题，附上官方文档 修改基本信息基本信息 hexofolder\\themes\\hexo-theme-pure\\source\\images中替换头像的那张图片，然后在hexo-theme-pure\\_config.ym中配置 icon 删除了hexofolder\\themes\\hexo-theme-pure\\source\\中的favicon.png，然后在images文件夹下 添加了icon的图片，将hexofolder\\themes\\hexo-theme-pure\\_config.yml中favicon对应的路径改成了\\images\\favicon。这真的是一个大坑，因为在hexo创建新的文章后路径上会加上日期，所以使用相对路径就会找不到icon图标 comment 这部分肥肠简单，我选择的是valine。大约步骤如下 注册一个LeanCloud帐号 创建一个工程 在设置中找应用keys填进去 在安全中心添加blog的url 今日总结明明感觉自己做了很多事情，写起来又发现自己其实只做了一点点。毕设的中期答辩想要开始准备了，但是感觉还是无从下手。未来几个月怎么准备找工作的规划也还没做。可能是处理问题的速度太慢了。但是我也没有办法，只能慢慢来。 明日规划 做好找工作的整体安排，安排了当天就做点吧 写git的常用操作并实践 毕设的概要了解，工作量估计","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-29T06:07:19.495Z","updated":"2020-12-29T06:07:19.495Z","comments":true,"path":"2020/12/29/hello-world/","link":"","permalink":"https://luoyongjia.github.io/2020/12/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"考研复试","slug":"考研复试","permalink":"https://luoyongjia.github.io/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"},{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"},{"name":"算法","slug":"算法","permalink":"https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"},{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/tags/leetcode/"},{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]}