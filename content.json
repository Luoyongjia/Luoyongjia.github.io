{"meta":{"title":"Gugugu's blog","subtitle":"","description":"","author":"罗咏佳","url":"https://luoyongjia.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-29T09:46:39.905Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"/404.html","permalink":"https://luoyongjia.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-29T09:50:25.856Z","updated":"2020-12-29T09:50:25.846Z","comments":false,"path":"about/index.html","permalink":"https://luoyongjia.github.io/about/index.html","excerpt":"","text":"是鸽子精本精"},{"title":"书单","date":"2020-12-29T09:45:56.166Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"books/index.html","permalink":"https://luoyongjia.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-29T15:52:32.625Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"categories/index.html","permalink":"https://luoyongjia.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-29T09:45:56.181Z","updated":"2020-12-29T06:21:42.127Z","comments":true,"path":"links/index.html","permalink":"https://luoyongjia.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-29T09:45:56.196Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"repository/index.html","permalink":"https://luoyongjia.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-29T09:45:56.211Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"tags/index.html","permalink":"https://luoyongjia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2021年1月1日","slug":"2021年1月1日","date":"2021-01-01T16:14:30.000Z","updated":"2021-01-01T16:22:33.199Z","comments":true,"path":"2021/01/02/2021年1月1日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 年度计划（永远立不起来的flag） Java基础语法 过程中遇见的问题无，详情请见Java基础语法以及易忽略点总结 今日总结今天睡得很开心，中午也睡了午觉。任务太多了，完不成。所以决定调整计划，明天希望过得轻松一点。空调温度果然还是需要调高一点，下午20度真的冻死我了。（附：还是好想去自习室，元旦特惠没有了，有点可惜）。 明日规划flag用不倒！！！！ 找2个类学学 英语听力 leetcode-3个题 开题报告开题报告开题报告开题报告 剑指offer2个题 练字 明天一定是 不 咕 鸟🐦！！！","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"Java基础语法以及易忽略点总结","slug":"Java基础语法以及易忽略点总结","date":"2021-01-01T16:09:10.000Z","updated":"2021-01-01T16:10:40.570Z","comments":true,"path":"2021/01/02/Java基础语法以及易忽略点总结/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"非常主观 非常主观 非常主观！ 类型基本类型： byte, short, int, long, float, double, char, boolean（low —- high）引用类型：类，接口，数组 类型转换在运算中，不同类型的数据都会先转化为较高的那一类，然后再进行运算 而由高转低 1((低类型) 变量名) 变量Java是一种强类型语言，也就是说每个东西都要有它明确的属性，不像Js、Python。 作用域个人jio得这个可以去康康我之前那篇由JVM内存划分与职能到值传递和引用传递。这里就做一个简单的描述。 静态变量：也就是类变量，当类加载时就存在的变量，只加载一次，不能改变。 实例变量：也就是成员变量，在类实例化时加载，存在那个实例里面。 局部变量：一次性变量，即用即删。生存周期同存在的方法时间相同。 数字里面可以带_，更容易理解，JDK新功能。 常量就是特殊的变量，在程序运行过程中保持不变。 1final Type name &#x3D; xxx; 命名不要以_或$开始或者结束。不要用拼音（除非国际通用的国内代名词）。 类名 开头大写的驼峰式。 方法名、参数名、成员变量、局部变量 同一使用开头小写的驼峰式。 常量 全部大写，单词之间用_隔开。 抽象类用Abstract或Base开头；异常类用Exception结尾；测试类用Test结尾。 运算符自增自减运算符a++ 先加，再拿a进行操作 ++a 先拿a进行操作，再加 – 同理 位运算符&amp; 将两个数字都转换为二进制后，两个数字在当位上都为1时此位为1，否则则为0 | 两个数字在当位上只需要有一个为1，则此位为1。 ^ 当两个数字当位上的数字不一样，则为1，相同则为0 ～ 当前数字二进制取逆 1234567A &#x3D; 0011 1001B &#x3D; 0000 0101A &amp; B &#x3D; 0000 0001A | B &#x3D; 0011 1101A ^ B &#x3D; 0011 1100~B &#x3D; 1111 1010 移位运算&lt;&lt; 向左移，高位溢出舍弃高位。补码啊…我都忘记了，等我机组学到这里再来补。负数无符号右移，用1填补。正数用0填补。 &gt;&gt; 向右移，同&lt;&lt; &gt;&gt;&gt; 无符号版本，都是补0 包机制导包： import 命名：通常用域名的倒置座位包名 12eg: www.baidu.com包的格式就为：com.baidu.www Java Doc生成文档，超级6。文档注释。首先来个Doc.java 123456789101112131415161718192021&#x2F;**** @author name* @ version 1.0* @since 1.8 *&#x2F;public class Doc&#123; String name; &#x2F;** * * @author xxx * @param name * @return * @throws Exception *&#x2F; public String test(String name)&#123; &#125;&#125; 方法中/**回车自动生成。 主要的有些： 123456@author@version@since jdk支持的最老版本@palam 参数名@return@throw 异常抛出 然后命令行当前路径 1javadoc -encoding UTF-8 -charaset UTF-8 Doc.java javadoc生成文档命令。 Scanner来自于java.util.Scanner的输入 Scanner对象的常用操作： 12345scanner.next() &#x2F;&#x2F;读取输入的字符，空格断开scanner.nextLine() &#x2F;&#x2F;读取当前行的输入scanner.hasNext() &#x2F;&#x2F;判断之后还有没有输入scanner.hasNextLine() &#x2F;&#x2F;判断是否还有下一行的输入&#x2F;&#x2F;next后还可以加基本类名，则限定输入的类 Scanner读取规则next() 要读到有效字符后的第一个空格或者换行符后结束。光标指向此空格之后 nextLine() 读完一行之后，光标指向下一行的开头 scanner.close()慎用！慎用！慎用！ 只要调用了这个函数后，之后新建的Scanner对象就无效了。但是也不能忘记在程序的结尾处，开了几个Scanner就关几个Scanner。 反编译VSCode还不知道怎么搞，坑先挖这儿吧。 重载就是名称相同，通过输入的参数的类型不同而调用不同的方法的功能。（写好几个相同名字的方法） 命令行参数你是否还记得： 1234...public static void main(String[] args)&#123;&#125; 中的args，这里就是用来实现命令行参数的，先在当前路径javac **.java编译。然后退到src文件夹（根文件夹）再 1java 此文件所在的相对位置.**.class 输入输入输入 可变参数在参数的最后， 1dataType ...a) 就可以输入多个这个类型的参数。 数组动态数组： 12dataType[] name &#x3D; new dataType[size];dataType[][] name1 &#x3D; new dataType[rowNum][colNum]; 初始化为0.. 静态数组： 12dataType[] name2 &#x3D; &#123;1, 2, 3, 4, 5&#125;;dataType[][] name3 &#x3D; &#123;&#123;1, 2&#125;,&#123;3, 4&#125;&#125;; 方法方法之间的调用当两个方法都为静态方法或者非静态方法的时候，它们之间可以相互调用，但一个静态一个非静态时，不可以相互调用。 构造器1public ClassName(); 当重写了构造器（有输入）之后需要重写一个没输入的才能实现继承。 多态假设现在这里有Father类，Son类继承Father类。假设他们都有eat()方法。 12345Father fater &#x3D; new Son();Son son &#x3D; new Son();father.eat(); &#x2F;&#x2F;执行的是son中的eatson.eat(); &#x2F;&#x2F;执行的是son中的eat Father类引用只能调用Father类中存在的方法，father不能调用Son中独有的方法。两个类都有的方法调用实例化那个类的方法。 instanceof类之间是否存在关系。父子ok，对象作实例化类来判断 1A instance of B 静态作用域执行顺序 1234567static&#123; &#x2F;&#x2F; 静态代码块&#125;&#123; &#x2F;&#x2F; 匿名代码块&#125;&#x2F;&#x2F;构造方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月31日","slug":"12月31日","date":"2020-12-31T16:37:41.000Z","updated":"2021-01-01T02:56:37.563Z","comments":true,"path":"2021/01/01/12月31日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 hexo上传图片问题 Java基础语法 过程中遇见的问题hexo上传本地图片在尝试调用url无效之后，开始打起了装插件的想法，没想到又是个大坑。不过终究是解决了。 Step 1修改根目录的_config.ym中的 1post_asset_folder:true Step 2 安装正确版本的插件注意注意注意，我直接安装hexo-asset-image出现了图片被多加了一个/的问题，再搜，发现是这个包的问题，尝试了改index.js，发现无效，所以就卸载了： 1npm unisntall -g hexo-asset-image 然后安装正确版本hexo-asset-image-0.0.5.git 1npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save Step 3 插入图片🎉1![1](文章名字对应文件夹&#x2F;图片名) Java内容明日再更新，之后再加链接到这里今日总结其实一上午都没有学习，因为起得晚，再🐟一下就到十点了，好像因为晚上睡得晚，导致早上也起不来…无解。有点想去自习室，但是爹妈就是不同意，不知道为什么。新的一年到来了，希望一切都能变得好起来。 明日规划 英语听力 Java基础过完 新年计划（今天真的太困了…只能咕） Java基础的blog总结一下 开题报告开题报告开题报告！ 练字 letcode-3题（or more） refer：hexo本地图片不显示","categories":[{"name":"总结","slug":"总结","permalink":"https://luoyongjia.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"由JVM内存划分与职能到值传递和引用传递","slug":"由JVM内存划分与职能到值传递和引用传递","date":"2020-12-31T14:52:00.000Z","updated":"2021-01-01T03:43:56.656Z","comments":true,"path":"2020/12/31/由JVM内存划分与职能到值传递和引用传递/","link":"","permalink":"https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"","text":"课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。 JVM内存划分与职能在java第一课中我们认识到了java程序都是运行在jvm上的，那jvm里面到底干了些什么呢？这里给出一个更加详细的程序执行图 内存划分由图可以得出，当java代码被翻译成字节码后，jvm开辟了一片新的内存空间（运行时数据区），下面依次来介绍其中的功能。 虚拟机栈方法被执行的地方，虚拟基站中存放着栈帧，方法调用的过程对应着栈帧在虚拟机中入栈到出栈的过程。 栈时私有的，也就是线程之间栈是隔离的。当程序某个线程开始执行一个方法，就会创建一个栈帧并入栈（于栈顶），方法结束后，栈帧出栈 下图为Java栈的模型及栈帧的组成： 局部变量表：储存方法中的局部变量，变量为基本数据类型时，存储值，变量为引用类时，存储引用类对象的地址 操作数栈：Java虚拟机的解释执行引擎常被称为“基于栈的执行引擎”，其中的栈为这个操作栈 指向运行时常量池的引用：可能用到的常量的引用 方法返回地址：存储方法执行完之后的返回地址 堆存储对象本身和数组，JVM中只有一个堆，所以堆是被所有线程共享的。 方法区一块线程共享的内存逻辑区域，JVM中只有一个方法区，存放一些线程可共享的内容。它是线程安全的，多个线程访问一个内容时，只有一个线程装载其数据，其他线程等待。 本地方法栈本地方法栈和虚拟机栈功能大约相同，线程私有。它和虚拟机栈之间的差别在于它主要为本地方法服务而虚拟机栈为Java方法服务。 程序计数器线程私有。记录当前线程所执行的字节码（*.class）的行号和指示器。字节码解释器工作就是通过改变计数器的值来选去下一条需要执行的字节码指令。个人认为程序计数器实现了Java的解释型语言性质。 数据存储数据基础知识 基本类型：byte, short, int, long, float, double, char, boolean 引用类型：类，接口，数组 12345678910111213public class Example&#123; public static PI &#x3D; 3.14;&#x2F;&#x2F;静态变量 private int name; &#x2F;&#x2F;成员变量 public void static main(String[] args)&#123; int a; &#x2F;&#x2F;局部变量 &#125; public int sum(int num1, int num2)&#123; int sum &#x3D; 0; &#x2F;&#x2F;局部变量 sum &#x3D; num1 + num2; return sum &#125; 数据在内存中存储方法基本数据局部变量直接存储在内存中的栈上，也就是之前提到过的“虚拟机栈”。 所以当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 成员变量也就是class中的一些属性变量，这些变量的生命周期同对象是一致的。 静态变量当类开始纯在，静态变量就储存在了堆中，当类被消灭的时候，它们才会被消灭。 引用数据引用数据传入时，传入的是存放变量内容的地址。 值传递与引用传递值传递可以简单的理解为上面对于成员变量的定义，一次性的变量。 当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 引用传递很好理解，就是将存变量值的堆中的地址给传进方法了，所以方法中对于传入的变量的更改实质上就是更改那个地址中存储的内容，一改则全改。eg: 123456789101112131415161718192021public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 结果将会是： 123传入的person的name：小明方法内重新赋值后的name：小红方法执行后的name：小红 在那篇博客中还发现了一片很好玩的问题： 还是刚刚那段代码 1234567891011121314151617181920212223public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); &#x2F;&#x2F;改变的地方 person &#x3D; new Person(); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 这个地方在PersonCrossTest方法里，person由原来指向小明的地址1改为了在方法中new Person()创建的临时的一个Person对象的地址2，在PersonCrossTest方法结束时地址2就被删除了，地址1中的内容并没有改变。 所以说，这里的引用传递其实是一个虚假的引用传递，不过是在栈帧中创建了一个变量存储传进来变量的地址。 终于写完了，今天就只加个总结吧，Java基础内容明日再更。 refer:这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"我的Java第一课","slug":"我的JAVA第一课","date":"2020-12-30T15:31:50.000Z","updated":"2020-12-31T03:42:56.384Z","comments":true,"path":"2020/12/30/我的JAVA第一课/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"基础概念不同的javaJavaSE: 标准版，适用于桌面程序与控制台的开发 JavaME: 嵌入式开发 JavaEE: 企业级开发，如Web服务器 动态性、多线程 Write Once, Run Anywhere JDK、JRE、JVMJVM(Java Virtual Machine)简单的来说，就是一个虚拟机，java程序都是基于这个虚拟机来跑的。 正是这个虚拟机使得Java能够屏蔽底层的差异，实现跨平台开发 JRE(Java Runtime Environment)包，JRE提供了Java的类库，其中包含了JVM JDK(Java Development Kit)开发者需要的东西，其中包括了很多开发工具 所以综上所述，它们仨的关系可以用这个图来表示： 接下来就开始上机操作了 配置环境JDK袜，这个真的，也有一点坑，我在官网上找了好久才找到下载的地方。这里直接指路吧。选择自己相应的版本然后注册（登陆）oracle账号就👌。 然后配置环境变量（仅限mac）。打开终端 1open -e .bash_profile 然后输入： 123456JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk你的版本.jdk&#x2F;Contents&#x2F;HomePATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 最后用： 1java-version 看java版本是不是跟自己的jdk装的版本一样就🉑️了 JDK内部探秘因为课里面讲了一点，所以也记了一下。就几个主要的文件夹。 \\bin 可执行的程序，比如说java、javac的运行程序就在这里面 \\include 因为Java是基于C、C++的嘛，这里面就有调用的一些C、C++的包 \\jre 运行环境 \\lib Java的库 \\src 一些Java类 我感觉这一块儿还不是太懂，之后有更深入了解了再来补充与修改 Hello world文本编辑器版本创建Hello.java写入： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 然后命令行进入对应文件夹 12javac Hello.javajava Hello 这里就出现一个问题了，为什么要先javac，然后再java呢这就不得不说一下Java的运行机制了。Java是集编译型与解释型的语言。javac就是起编译器的作用。生成字节码Hello.class，然后再进行之后的操作 VSCode版本step 1 下载插件 Language Support for Java™ by Red Hat Debugger for Java Java Test Runner Maven for Java Java Dependency Viewer Java Extension Pack step 2Ctrl+Shift+P输入Java: Configure Java Runtime修改默认JDK版本与路径 step 3可以开始创建工程，输入代码，然后run辣 其中遇见了一个奇葩问题我看课程中使用IDEA写的，在project/src/pakageName中直接写代码就能跑，但是在VSCode中不一样，需要在*.java文件的开头添加package src.pakageName; 具体是什么原因我也不大清楚，先记下来吧。 Refer：Java JDK, JRE and JVM 太懒了，图片先不整了，有缘再整 图片调整好辣，今天晚上一定要记一下这个坑 配置就到这儿啦，希望明天能过完基础语法🤡","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月30日","slug":"12-30","date":"2020-12-30T14:31:54.000Z","updated":"2020-12-31T03:40:59.048Z","comments":true,"path":"2020/12/30/12-30/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-30/","excerpt":"","text":"今天干了些什么 昨天规划的大约的工作安排做了 git就只学会了初始化，上传这样子 Java环境搭建，以及写了个hello world 过程中遇见的问题git就是从一个空白项目怎么配置到本地这样子 先创建一个空白的文件夹，我习惯是创建一个同名的，然后进入此文件夹的目录 1234git initgit remote add origin git@github.com: ... &#x2F;&#x2F;...是项目的路径git add .git push -u origin master &#x2F;&#x2F;这里要注意此电脑是master 删除了user文件夹下初始化过的.gith文件夹，vscode的sourceControl终于不现实5k+ changes了，我就觉得肯定是因为有个.git的问题 Java开发相关的问题这个我想重新写一篇blog来更全面的描述。 今日总结今日没有出门学习，感觉在家果然还是有点🐟的。也还行吧，早上起来床了，任务也完成得七七八八。Java的课上着感觉有点简单，但是还是跟着上下去吧，熟悉的就2倍速，不熟悉的再仔细听，我怕出现那种像高数课一样，突然什么都听不懂了。还是希望明天能够更高效吧。搞这些整得我觉得手机都不好玩了，真好。明天想要写一个年度总结，不知道有没有时间，或许就同日记一起写了，但是我觉得这俩还是有挺大区别的，日记主要还是记一下当日遇见的问题以及解决的方法。 明日规划 英语听力 letcode中的3题 Java语法学完（这个任务视难度而调整） 剑指offer-2题 至少把自己的开题报告好好康康 练字练字练字！ 每天都要开心哦🥳","categories":[{"name":"总结","slug":"总结","permalink":"https://luoyongjia.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"https://luoyongjia.github.io/tags/%E7%9E%8E%E5%86%99/"},{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"春招准备规划【实时更新】","slug":"春招准备规划【实时更新】","date":"2020-12-30T04:02:12.000Z","updated":"2020-12-30T06:04:17.838Z","comments":true,"path":"2020/12/30/春招准备规划【实时更新】/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/","excerpt":"","text":"春招准备规划【实时更新】第一阶段（12.30-1.31）基础：算法基础这里采用剑指offer中的题和算法面试题汇总结合，每天做一定量（2+3） 手写代码手写代码手写代码！ Java基础上网课同时实践 其他基础看书+练题 方法针对性，手写代码。 目标：历届的笔试面试题 通过小公司面试积累经验，先从小公司开始 说话能力 每日任务 3+2 算法题 网络一课 机组一课 英语听力 练字","categories":[{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"2020年12月29日","slug":"12-29日总结","date":"2020-12-29T16:44:36.000Z","updated":"2020-12-30T14:38:16.277Z","comments":true,"path":"2020/12/30/12-29日总结/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-29%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天干了些什么 大约将博客搭起来了 了解了毕设中期需要做一些什么 开了蓝灯 过程中遇见的问题搭建博客git在post的过程中出现帐号错误原因：当初作死，就想换个github帐号重新开始，导致电脑中默认的git帐号密码有问题 解决方法：不仅仅是说我使用 123git config -list \\\\查询信息git config --global user.namegit config --global user.email 就可以了的，在不同的系统下操作不同，我此仅代表mac用户。 还需要删除钥匙串访问中的github.com项 关于hexo pure主题配置的一堆破事所以在这里写下从头开始应该怎么配置pure主题，附上官方文档 #####修改基本信息基本信息 hexofolder\\themes\\hexo-theme-pure\\source\\images中替换头像的那张图片，然后在hexo-theme-pure\\_config.ym中配置 icon 删除了hexofolder\\themes\\hexo-theme-pure\\source\\中的favicon.png，然后在images文件夹下 添加了icon的图片，将hexofolder\\themes\\hexo-theme-pure\\_config.yml中favicon对应的路径改成了\\images\\favicon。这真的是一个大坑，因为在hexo创建新的文章后路径上会加上日期，所以使用相对路径就会找不到icon图标 comment 这部分肥肠简单，我选择的是valine。大约步骤如下 注册一个LeanCloud帐号 创建一个工程 在设置中找应用keys填进去 在安全中心添加blog的url 今日总结明明感觉自己做了很多事情，写起来又发现自己其实只做了一点点。毕设的中期答辩想要开始准备了，但是感觉还是无从下手。未来几个月怎么准备找工作的规划也还没做。可能是处理问题的速度太慢了。但是我也没有办法，只能慢慢来。 明日规划 做好找工作的整体安排，安排了当天就做点吧 写git的常用操作并实践 毕设的概要了解，工作量估计","categories":[{"name":"总结","slug":"总结","permalink":"https://luoyongjia.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"https://luoyongjia.github.io/tags/%E7%9E%8E%E5%86%99/"},{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-29T06:07:19.495Z","updated":"2020-12-29T06:07:19.495Z","comments":true,"path":"2020/12/29/hello-world/","link":"","permalink":"https://luoyongjia.github.io/2020/12/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"},{"name":"总结","slug":"总结","permalink":"https://luoyongjia.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"瞎写","slug":"瞎写","permalink":"https://luoyongjia.github.io/tags/%E7%9E%8E%E5%86%99/"}]}