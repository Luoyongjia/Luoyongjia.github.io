{"meta":{"title":"Gugugu's blog","subtitle":"","description":"","author":"罗咏佳","url":"https://luoyongjia.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-29T09:46:39.905Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"/404.html","permalink":"https://luoyongjia.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-29T09:50:25.856Z","updated":"2020-12-29T09:50:25.846Z","comments":false,"path":"about/index.html","permalink":"https://luoyongjia.github.io/about/index.html","excerpt":"","text":"是鸽子精本精"},{"title":"分类","date":"2020-12-29T15:52:32.625Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"categories/index.html","permalink":"https://luoyongjia.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-29T09:45:56.181Z","updated":"2020-12-29T06:21:42.127Z","comments":true,"path":"links/index.html","permalink":"https://luoyongjia.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-12-29T09:45:56.166Z","updated":"2020-12-29T06:21:42.126Z","comments":false,"path":"books/index.html","permalink":"https://luoyongjia.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-29T09:45:56.196Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"repository/index.html","permalink":"https://luoyongjia.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-29T09:45:56.211Z","updated":"2020-12-29T06:21:42.127Z","comments":false,"path":"tags/index.html","permalink":"https://luoyongjia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【RL】概念列表","slug":"【RL】概念列表","date":"2021-06-22T09:12:54.000Z","updated":"2021-06-23T01:44:43.820Z","comments":true,"path":"2021/06/22/【RL】概念列表/","link":"","permalink":"https://luoyongjia.github.io/2021/06/22/%E3%80%90RL%E3%80%91%E6%A6%82%E5%BF%B5%E5%88%97%E8%A1%A8/","excerpt":"","text":"感谢大大推荐的王树森老师！这里附上课程链接。 数学背景概率随机变量：随机事件的数量表现，eg：抛100次硬币，其中正面朝上的次数，就是一个随机变量。分布函数：表示随机变量在分布域上的分布情况。 基础概念state: 当前的状态Action: 可以采取的行为Agent: 采取行动的个体Policy: 基于当前状态，决定下一个行为的策略Reward：回报，采取这一行为之后获得的奖励state transition: 表示在当前环境下根据Policy选择行为后，环境发生的改变。 就如图中这个马里奥游戏为例子。其中state就是当前的环境，有金币，有龟龟等。Action表示这个马里奥可以选择向左，或是向右，或是上跳。Agent就是马里奥，而Policy是根据当前环境，对于下一个Action的选择。Reward，比如说做了这个行为，马里奥吃到了金币，那就是1， 如果马里奥碰到了龟龟死了，就是-10000这种。当选择向上跳之后，环境中的龟龟向左（or向右）移动了，金币减少了，这就是state transition。 随机性体现Action的选择Policy得出来的是选择每个Action的概率，而不是直接选择概率最大的行为，所以这里行为的选取具有一定的随机性 环境的变化做出当前行为后，环境可能会发生不同的变化；比如说马里奥里面，龟龟可以向左走，也可以向右走。 Reward一系return: U_{t} = R_{t} + R_{t + 1} + R_{t + 2} + \\cdots 由于对于越远的reward来说，当前的action的影响越小，所以给它加一个U_{t} = R_{t} + \\gamma R_{t + 1} + \\gamma^{2} R_{t + 2} + \\cdots 在强化学习的问题中，有两个分布函数，分别是在某环境下每个action的分布函数；和在某环境下做了某行为后的state transition 分布。 \\mathbb{P}[A=a | S=s] = \\pi (a | s)\\mathbb{p} [S = s' | S= s, A = a] = p(s'|s,a)value functionAction functionQ_{\\pi} (s_{\\tau}, a_{\\tau}) = \\mathbb{E}[U_{\\tau} | S = s_{\\tau}, A = a_{\\tau}]]其中，U_{\\tau}为reward中的reward，使用action分布函数和state transition分布函数将非\\tau的后续行为积分消去。 所以，这个函数是在使用\\pi这个policy，S_{\\tau}这个情况下，对于各个a进行打分。 Q^{*} (s_{\\tau}, a_{\\tau}) = \\max_{\\pi} Q_{\\pi} (s_{\\tau}, a_{\\tau})这里通过使用最好的policy对于行为进行打分，至于这个最好的policy是如何获得的还并不清楚。 所以学习有两个选项，一个是学习policy，一个是学习这个拥有最好policy的打分函数。具体还不清楚，后续课程补充。 state value functionV_{\\pi}(s_{\\tau}) = \\mathbb{E}_{A} [Q_{\\pi}(s_{\\tau}, A)]对于所有的a求期望，消除A。 也就是说这个函数只是一个S的函数，用于判断当前的形势是好是坏。 同时，我们也可以计算： \\mathbb{E}_{s}[V_{\\pi}(s)]用于计算\\pipolicy的好坏。当policy越好的时候，这个期望值将会越大。 那是否，通过这个函数可以选出最好的policy？","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】GNN","slug":"【ML】GNN","date":"2021-06-11T04:16:59.000Z","updated":"2021-06-11T05:15:35.643Z","comments":true,"path":"2021/06/11/【ML】GNN/","link":"","permalink":"https://luoyongjia.github.io/2021/06/11/%E3%80%90ML%E3%80%91GNN/","excerpt":"","text":"李宏毅机器学习基础2021 应用背景GNN主要是从一个分布投射到另一个分布上。比如说现实的人照片是一个分布，动漫人像是一个分布，由现实生成动漫人像就是一种映射。不同于传统的机器学习方法，投射到的分布也是一个比较复杂的域。生成出的，或许是同一风格的图像（风格迁移），可能是现实的图像组合（生成图像）。其大概可以概括如下图。 其需要在一个简单分布中随机取种子，将这个种子和输入的x作为输入，通过生成器就可以投射到复杂的分布中某个个体了。 为什么一定要GNN呢？比如说预测糖豆人在分叉路口下一步该怎么走的问题，有两个方面的问题：1. 传统的方法相同的输入一定会有相同的输出，但是糖豆可能向左也可能向右； 2. 由于两个方向都有可能，所以输出的糖豆人会被分裂，两边都出现。 所以GNN能够在所有可能的输出中选取一个，而且每个方向都有可能被选到。 方法 GNN主要分布为两个部分，生成器和监督器。就是两个模型相互干架。生成器生成目标域的输出，监督器分辨向量是生成器生成的还是真实存在的，越真实得分越高。 Discriminator其方法就是计算生成器生成的分布与目标分布的距离。最基础的方法是JS距离，但是这个距离吧，只要两个不相交，值就是相同的。所以就提出了Wasserstein distance。 Wassertein distance计算从一个分布移动到另一个分布的所有方法的距离和的均值，从而有效解决了不相交的情况下没办法有效更新的问题。 Conditional GAN毕竟输出是要根据输入的x产生的，上述的方法中只是针对随机提取的向量到目标域的方法。所以这里在Discriminator中，计算距离的输入中增加了x与输出是否匹配的部分。 Cycle GAN对于不成对的数据，之前的做法是通过一个反向的网络来生成成对数据，而GAN的做法是形成一个环。 判断Generator是否能够根据自己生成出的图像复原到输入。同时将前一个Generator的输出交给Discriminator来监督生成目标域的图像。等于就是训练了一个反向的Generator。 Evaluation查看生成目标的分类过一次分类，是否非常集中的分布到某一个类上。 当然这种方法也会出现Generator发现盲点，就集中到一个种类上。 Tips存在的问题 生成类不够丰富 在某个盲点上了解决计算种类的多样性，将其加入Discriminator的判断标准。 refer GNNppt","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Transformer","slug":"【ML】Transformer","date":"2021-05-31T03:56:11.000Z","updated":"2021-05-31T05:15:21.747Z","comments":true,"path":"2021/05/31/【ML】Transformer/","link":"","permalink":"https://luoyongjia.github.io/2021/05/31/%E3%80%90ML%E3%80%91Transformer/","excerpt":"","text":"李宏毅机器学习2021笔记 应用场景主要应用在输入队列与输出队列长短不确定的时刻。输出队列的长短不确定的情况。 就比如说，输入一段5s的语音，将这段语音翻译成汉字。在这个任务中，5s的语音可能只对应“你好”两个字，也可能对应“机器学习”四个字，这个输出长度就是不确定的。 在图像的问题中，可以是多标签分类任务。一张图片，它可以同时属于多个类，但是这个类的数量是不确定的，这时候就需要模型自己去判断需要给这张图片几个类这样子。 再比如说，物体识别的方向上。假设这个马的图像，我们需要让模型自己去判断图像中有几只马这样子。paper 方法Transformer 主要分成两部分，Encoder和Decoder. Encoder的功能就类似于编码，对于输入的序列进行编码。然后Decoder根据编码产生输出，判断输出序列的长度。 EncoderEncoder是基于上一课中提到的self-attention操作来构成的，但是又有一点不同。它的流程如下图所示。 Multi-Head Attention就是在self-attention中提到过的多头的attention策略。这里与其不同的是，在attention之后进行了一个residual的操作。如图所示。 在此操作之后，再过一个layer Norm，输出。之后便是全联接+layer norm。当然，这个流程是可以更改的，比如将norm的位置调换一下等等，可能会出其不意得到好的结果。 DecoderDecoder, 有两种方法。第一种是和RNN方法很相近的一种，基于之前的输入，然后判断下一个的输出，最开始用begin开始。还有一种是我直接输入很多个（n）占位符，然后直接产生n个输出，找其中最先出现end的位置作为结束。但其主要过程差不多，只是产生结果的方式不同。如下图所示 其中的attention部分和Encoder部分不同，这里的attention特指了masked attention, 也就是说其只考虑左边的输入，这是由于其特性所决定的，每一次attention的输入是上一个输出，这样子右方的信息是缺失的，所以只使用左边的输入。 其连接的方式如图所示： 基于Encoder的输出，以及当前经过mask self-attention的当前输出，做self-attention操作，再输出，进入FC层判断输出，这样子。 如何学习输出长度Decoder对于每一个可能输出用vector表示，加入了end标签，当Decoder的结果是end时，就让这个模型停止输出这样子。 Tipstrain在train的过程中，Decoder的输入是正确答案的序列。当然这种情况在test过程中是不可能出现的，所以在正确答案中添加一些噪声信息。 chat-bot有的时候输出只是对于输入的一个简单复制，这时候就需要Chat-bot，占个位置，啥都不干，至于具体怎么加的，我并不清楚。 referAttention Is All You Need","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Batch Normalization","slug":"【ML】Batch-Normalization","date":"2021-05-12T13:52:02.000Z","updated":"2021-05-13T04:36:30.526Z","comments":true,"path":"2021/05/12/【ML】Batch-Normalization/","link":"","permalink":"https://luoyongjia.github.io/2021/05/12/%E3%80%90ML%E3%80%91Batch-Normalization/","excerpt":"","text":"问题原因还记得当初Gradient Descent中提到的，因为输入的不同维度的Feature之间分布差距过大从而引发的训练困难吗？ 这里，Batch Normalization将更加深化一点讲，以及BN层的操作方法。 具体操作Normalize对于维度i，求相应的平均值m_{i}，方差\\sigma_{i}，然后对于每一个元素做 \\tilde{x} \\gets \\frac{x^{r}_{i} - m_{i}}{\\sigma_{i}}由于过了一层参数之后，他们的分布又有可能会变得不同，所以有时候在不同层之后都加了BN的操作。 Batch Noemalization批处理。这里的求平均，求方差都不是一个数据就能算的。这里的批，一次性输入Batch_size个数据，然后通过这一批所有的数据对于每一个维度进行处理。 test部分怎么做呢？在training过程中，pytorch会自动地将\\bar{\\mu}以\\bar{\\mu}\\gets p\\bar{\\mu} + (1-p)\\mu^{t}存下来，方差也一样。测试时直接将这两个数字作为测试集的分布。 为什么有效这种方法能够让error surface更加的不崎岖，从而能够很好的训练。 refer 【機器學習2021】類神經網路訓練不起來怎麼辦 (五)： 批次標準化 (Batch Normalization) 簡介","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Self-attention","slug":"【ML】Self-attention","date":"2021-05-07T02:53:21.000Z","updated":"2021-05-07T03:56:51.377Z","comments":true,"path":"2021/05/07/【ML】Self-attention/","link":"","permalink":"https://luoyongjia.github.io/2021/05/07/%E3%80%90ML%E3%80%91Self-attention/","excerpt":"","text":"在2020课程看到RNN的时候，突然在旁边发现了2021的一个讲transformer的，诶嘿，就找到2021的课程了。大约之前的都是一样的，所以就直接从cnn之后的self-attention开始了。 适用的任务大致框架输入的是一个序列的vector，不同的序列之间很可能长短不一。输出可以是和输入的vector数量相同，也可以是不同的。 Examples文字输入，判断每个词的词性。分子输入（图），判断这个分子的有效性。 可以是一段音频，也可以是一个图，只要是vector序列，就可以作为输入。 目标比如说输入一句话：I saw a saw.这里两个saw分别代表不同的词性。但是就之前的神经网络来说，这两个输入是相同的，所以输出也应该是相同的。就不对了。这里就需要结合更多的相关信息（比如说前面是什么词性，比如说在整句中是一个什么位置）来判断这个saw是什么词性了。 Window有一种方法是增加一个window，使得每次的输入包括的vector增加，增加一个前后的输入。 但是这种方法很明显存在一个缺陷，就是我的感受范围是确定的，也就是说没办法很好地覆盖每一个输入。 Self-attention它做了一个什么操作呢？假设我们这个序列里有n个vector, 然后通过self-attention后，每个vector都根据与其他vector的相关性进行了一定的融合，然后生成了一个新的vector，输出对应的n个vector。是不是很像当时logistic regression最后提到的，换一个分布。但是这里是根据全局的其他相关信息换的。从名字也可以知道，attention，就是关注更多与自己相关的输入。 这个self-attention可以在网络中多次出现，可以在不同位置出现。 具体操作基本原理假设我们现在想算a^{1}的输出。那么首先，我们需要计算出a^{1}与其他几个vector的相关度。这里采用Dot-product方法计算相关度。当然也存在其他的计算相关度的方法，仅是这里采用此方法。 第一步算出a^{1}与其他的相关度 然后过一层normalization层。 计算出每个vector对应的v之后与经过normalization的相关度相乘再相加。 就算a^{1}对应的输出b^{1}啦。由于每个v乘的系数是经过normalization的相关度，所以说再b^{1}中相关度高的影响就大，相关度低的影响较小，从而做到了关注相关的。 课上老师提出的：是否可以删除计算自己的相关度？我认为是不行的，因为我认为输出主要的部分还是原输入，如果抛弃了原输入只关注周围信息，肯定是没办法得到想要的结果的。 矩阵运算对于每一个输入的向量，都做了上述的操作。那，理所当然，我们就想到了用矩阵加速。 对于每一个输入，我们都需要乘系数W^{q}, W^{k}, W^{v}，那么，就可以得到： 求相关度可以合并为： 最后再乘一个V： 也就是说，这个运算最后可以简化为：O = VK^{T}Q这样子。 multi-head self-attention上面的都是基于一个head的。就称他们为一套吧。我现在可以有多套，然后出来多个b，最后乘个系数得到唯一输出b。就是这样子。 位置信息从上面的操作我们可以看出，这么一操作，位置信息就全咩了。所以如果需要位置信息，我们可以给每个输入加上一个位置向量。这个向量可以是学出来的，也可以是手动设置的。当然，这个还在研究中这样子。 一些应用Speech语音任务，一段语音特别长，我们可以把attention的范围缩小到一定范围中 Image就是把每个点的不同通道数值作为一个vector，整个图片就有很多vector了。（这样是不是就可以把不同大小的图片作为输入了？） Self-attention v.s. CNNCNN像是有很多先验的self-attention。如果数据集较小可以选择CNN，大的数据选Self-attention Self-attention v.s. RNNRNN的范围扩大是通过储存之前的输出。这样子导致输出具有序列性。并且不能够并行。 refer An Image is Worth 16x16 Words: Transformers for Image Recognition at ScaleAttention 1Attention 2","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Colab使用基础指南","slug":"Colab使用基础指南","date":"2021-05-05T11:57:50.000Z","updated":"2021-05-05T12:32:35.341Z","comments":true,"path":"2021/05/05/Colab使用基础指南/","link":"","permalink":"https://luoyongjia.github.io/2021/05/05/Colab%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97/","excerpt":"","text":"嫖嫖嫖，就硬嫖。香香香！白嫖的显卡就是香！ 这里来几个基础操作。 IO可以看到，Colab是基于Google Drive的。要读取我们云端的数据，就需要： 12345from google.colab import drivedrive.mount(&#39;&#x2F;content&#x2F;drive&#x2F;&#39;)# 设置工作路径，个人觉得可以咩import osos.chdir(&quot;&#x2F;content&#x2F;drive&#x2F;My Drive&#x2F;YourWorkPath&quot;) 这是每一个ipynb文件都需要先执行一下下得。 读取文件就是路径读取。我们先将文件上传到云上面。然后在Colab的左侧，文件那一栏，就可以看到我们的文件都路径。通过路径读取就ok。 shell查看已安装的包: ! pip list安装新的包： ! pip install packegeName查看嫖到什么显卡：! /opt/bin/nvidia-smi进入bash: ! bash推出：exit 保持连接没开pro最长就是12h，不够用了再说吧。如何保持12h不断开？F12看网页代码，打开console输入这行代码： 12345function ClickConnect()&#123; console.log(&quot;Clicked on connect button&quot;); document.querySelector(&quot;colab-connect-button&quot;).click()&#125;setInterval(ClickConnect,60000) 每60s按一次colab-connecte-button，保持连接。每次刷新之后需要再次输入。 常用快捷键 refer Google Colab入门（一）Google Colab 如何查看显卡配置和驱动情况？colab保持连接的方法20种小技巧，玩转Google Colab","categories":[{"name":"基本操作","slug":"基本操作","permalink":"https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Colab","slug":"Colab","permalink":"https://luoyongjia.github.io/tags/Colab/"}]},{"title":"【ML】CNN","slug":"【ML】CNN","date":"2021-04-23T13:54:40.000Z","updated":"2021-04-25T12:00:04.216Z","comments":true,"path":"2021/04/23/【ML】CNN/","link":"","permalink":"https://luoyongjia.github.io/2021/04/23/%E3%80%90ML%E3%80%91CNN/","excerpt":"","text":"李宏毅机器学习笔记 图像的特点 图像的特征很小，比如说鸟嘴，鸟尾巴，鸟眼睛这种，对于一整张图片来说，这知识一部分 同一个特征可能出现在一张图片的不同位置 subsampling，一个图片放大缩小旋转这些操作，并不会影响特征的提取 所以，可以使用卷积来提取特征。 CNN的整个框架 卷积操作可以对应图像的特征1和特征2。卷积核可以在不同位置识别出较小的特征。 maxPooling对应图片缩小并不会影响判断的特征。 然后这个过程可以重复好多遍，从底层的特征提取到高层的特征。 Convolution（基础卷积）就是使用多个卷积核，在输入的图片上进行卷积操作。需要注意到：卷积核的channel数应该和输入的channel数相同，卷积核的个数对应输出的channel数。具体怎么算我就不赘述了，我的汇报ppt上有，并且还有各种奇奇怪怪的卷积。以及对应的参数，功能，时间、空间复杂度的计算，复习复习就行。 就是对应位置相乘，然后取和。输出就是：Feature Map 注意卷积计算，filter的channel数和输入的channel数是一样的，输出channel数等于filter的个数。 conv和全连接的区别老师课程中说得非常清楚，这个图很好的表现了conv和全连接之间的区别。 其实就是消除了全连接之中的一些我们根据图像特征判断出的无效的连接，并且实现了一些参数共享，从而减少了参数量。 max pooling就是对于图像进行一个缩小。从而减少计算量。主要操作有max，或是average。一般为变长为2的，就是直接缩少到一半。 Flatten将所有的输出拉长，然后进行分类这样子。 CNN在干什么？如何去分析一个filter在干嘛？ 先确定这个函数被激活的程度： a^{k} = \\sum_{i = 1}^{11} \\sum_{j = 1}^{11} a_{ij}^{k}然后我们将这个作为指标，来设计loss： x* = arg \\substack{\\max\\\\x} a^{k}然后通过gradient ascent来求这个x* 底层的大多去学一个简单的特征，比如说线啊，重复的波纹啊。然后对于较高的层，我们能够识别比较复杂的特征，比如说是一只猫，还是一只狗，它们特征集合的这样子。 CNN的应用我们可以根据任务来设计我们的CNN模型。CNN不仅仅可以应用于图片，还可以应用于alpha go。 但是从alpha go的任务出发，我们可以发现，棋谱并没有那个可以缩小放大的性能。所以在alpha go的模型中可以发现，并没有pooling层。 其他两个例子我也没有太理解。","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】How to train DNN","slug":"【ML】How-to-train-DNN","date":"2021-04-23T07:14:54.000Z","updated":"2021-04-25T08:43:57.973Z","comments":true,"path":"2021/04/23/【ML】How-to-train-DNN/","link":"","permalink":"https://luoyongjia.github.io/2021/04/23/%E3%80%90ML%E3%80%91How-to-train-DNN/","excerpt":"","text":"李宏毅机器学习笔记袜，这课真的，老师讲得超好！👍👍👍超推荐去看！ Process要了解如何训练自己的深度网络模型，第一步需要了解训练的整个过程。 从图中可以看出，在最初的设置模型，设置loss，解loss了之后，我们需要现在训练集上测试我们这个模型的效果。如果效果还行，我们就可以使用测试集的数据来测试模型的效果。 如果在训练集上我们的模型效果一直都不行，那这样肯定是左侧的三个步骤中某个出问题了。 当在训练集效果还行，但是在测试集效果不怎么行，则很可能是出现了过拟合的问题。 左侧三步调整也就是对于我们建的模进行调整。在training set上都没效果，还对于testing set做什么奢望？ Activation function给予网络一种非线性的关系。 sigmoid当网络很深的时候，因为每一个sigmoid都会将输出控制到0-1之间，所以我们可以预见性的看见，当网络非常深的时候，接近输入层的参数对于结果的影响会被变得非常小，这时候对于接近输入层的参数会发生梯度小时的问题。当接近输出层的参数已经comverge了的时候，接近输入层的参数可能还是原来随机初始化的那几个，所以，这种激活函数根本不合适较深的网络。 我们如何去估计这种情况呢？我们可以知道，参数的更新是和\\frac{\\partial l}{\\partial w}直接相关的，所以我们只需要看\\Delta l与\\Delta w的关系就👌啦。比如说sigmoid函数，我们就可以看出，当网络深的时候，接近输出层的\\frac{\\partial l}{\\partial w}大，接近输入层的\\frac{\\partial l}{\\partial w}小。所以，网络深了接近输入的w根本更新不了输入层的参数，就导致网络效果不好。这时候，有一个解决办法就是换激活函数。 ReLu函数 这东西好多理由的，真是，有理有据。在一些输出小于0的神经元，等于直接把它们给删了，然后训练一个简单的框架。多次训练，删不同的神经元，从而使得所有的神经元都得到了训练。并且，对于留下的神经元，是一个线形的关系，就不存在sigmoid的梯度消失的问题。（多个不同的线形关系组合从而给了网络非线性关系。） 回传的时候求导，我们默认无0点。所以非1即0。 几种变种Leaky ReLu: ReLu中负数部分用0.01*output表示 Parametric ReLu: 负数部分作为一个参数来学习 Maxout学习激活函数（但是不知道为什么，我总觉着这东西不怎么靠谱，这也要学，neural的参数也要学，那岂不是很慢。） 它的过程大约是这样: 输入，通过线形变化了之后，在预先设置的群组中选择最大值作为输出。然后每一层都这么整。通过这种方法是可以学出ReLu的，比如说将两个输出，其中一个恒等于0 其中红色和蓝色是两个输出，然后学出来就是绿色的，就跟ReLu是一个样子了。 通过这种方法可以根据不同的数据集、自己设置的群组的不同，学习出各种各样的激活函数。有效性我没有验证，但是有一篇paper(Learning Activation Functions)，感兴趣的童鞋可以去康康。 大约，可以学出各种各样的激活函数： optimizerAdagrad之前在GD中就已经介绍了Adagrad，详情可以移步【ML】Gradient Descent。这里简单介绍一下，大约就是对于梯度下降中所有之前的梯度求一个均方根，然后让现梯度乘learning rate，再除这个均方根。 RMSProp是对Adagrad的一个升级版本。可以调整过去的梯度对于当前梯度的影响大小。 \\begin{equation*} \\begin{aligned} &w^{t + 1} \\gets w^{t} - \\frac{\\eta}{\\sigma^{t}}g^{t} \\\\ &\\sigma^{t} = \\sqrt{\\alpha(\\sigma^{t-1})^{2} + (1 - \\alpha)(g^{t})^{2}}\\\\ \\end{aligned} \\end{equation*}所以说是可以通过调整\\alpha的大小，来对于当前的learning rate进行更新，从而适应更加复杂的loss问题。相当于增加了一个衰减系数来控制历史信息的获取多少。 就，更加关注最近的几次梯度下降。那么如果当前参数空间比较平缓，那么这个均方和较小，那么就能走得更快。 Momentum动量的方法。考虑前一次梯度下降的方向。过程大约是： 初始化参数，和动能 计算参数所在点的梯度 动能 = \\lambda上一次移动 - \\eta梯度 有的时候，可能之前的动能能够帮助它走出局部最优（当然，局部最优是很难出现的） Adam就是Monmentum和RMSProp的一个结合。算法长这样： 过拟合调整Early stopping很好理解，我们就提前结束训练。简单、粗暴的方法。通常我们用验证集来验证我们是否过拟合。看它错误率上去了的时候，就cut。 regularization在loss后面添加二范式，从而达到，使我们拟合出来的函数更加平滑。 范式一范\\| \\theta \\|_{1} = |w_{1})| + |w_{2}| + \\cdots二范\\| \\theta \\|_{2} = (w_{1})^{2} + (w_{2})^{2} + \\cdots参数更新一范：w^{t+1} \\gets w^{t} - \\eta \\frac{\\partial L}{\\partial w} - \\eta\\lambda sgn(w^{t})二范：w^{t+1} \\gets (1-\\eta\\lambda)w^{t} - \\eta \\frac{\\partial L}{\\partial w} 通过公式可以看出来，一范对于较大的参数没有办法很快的变小，但是二范能够做到，所以常用的还是二范，一范没什么用。 dropout假设每个神经元被丢掉的可能性是p%。每次训练中，随机的丢掉一些神经元，然后训练。这样，就形成了不同的网络结构。这些结构都被训练了。等于说，我用较少的神经元想要实现较多神经元要实现的任务。打个比方就像是负重训练一样。 然后在test的时候，将所有的神经元都启用，并且输出需要乘以（1-p%）因为我训练的时候神经元的数量相较于现在少p%，它们的输出就会被训练得放大，所以这里要恢复常值。 等于说，我训练了多个网络结构来做这一个task，然后我对于这些网络的输出做一个求和，诶嘿，刚好就等于（1-p%）所有神经元都用起来的网络的输出。 这里有个思考，这种方法和NAS的区别。会不会是NAS是对于n个网络结构训练了之后取效果最好的，但是这里直接就做平均了？暂时还不是特别清楚，以后再补充。 refer ML Lecture 9-1: Tips for Training DNN【优化算法】一文搞懂RMSProp优化算法 Adam的paper","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】DNN","slug":"【ML】DNN","date":"2021-04-21T13:19:14.000Z","updated":"2021-04-23T07:13:01.730Z","comments":true,"path":"2021/04/21/【ML】DNN/","link":"","permalink":"https://luoyongjia.github.io/2021/04/21/%E3%80%90ML%E3%80%91DNN/","excerpt":"","text":"李宏毅机器学习笔记 发展史1958: Preceptron(线形模型)1980s: Multi-layer perceptorn1986: Backpropagation1989: 1 hidden layer is “good enough”, why deep2006: RBM initializaiton(breakthrough)2009: GPU2011: speech recognition2012: win ILSVRC image competition 步骤与机器学习步骤相同，只不过第一步换成了设计一个网络结构 Why Deep?有种模块化的意思。就像软件设计中，会有很多基础功能，然后基础功能一层层结合，实现更加复杂的功能这样子。 课程中举了一个例子：一个分类网络，需要分辨出这个人是长发女，长发男，短发女还是短发男。假设现在长发男的数据特别少，我们想要一层分辨出长发男就很难。但是如果我们将网络搭两层，就能第一层学习是男还是女，是长发还是短发；然后第二层再做排列组合细分这样子。 在图像方面，就比如第一层学习了图中是否有横线、斜线等，然后第二层学习是否有某个花纹，第三层学习是否有某个物体一部分…逐步提高识别的细粒度。 在语音方面，首先学习这个音是怎样发出的，然后学习这些音的组合，然后再学习内容这样子。 所以deep，能够让网络将复杂的任务分解，使本需要大量数据训练的函数，现在需要较少的数据，也能做到较好的效果。网络，就是一个大型特征提取器。也可以简单的端到端，这样，网络能够通过一定量的数据，自动地学到如何去模组化这个任务。 refer DLWhy Deep","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Classification and Logistic Regression","slug":"【ML】Classification-and-Logistic-Regression","date":"2021-04-18T05:45:22.000Z","updated":"2021-04-19T08:14:44.665Z","comments":true,"path":"2021/04/18/【ML】Classification-and-Logistic-Regression/","link":"","permalink":"https://luoyongjia.github.io/2021/04/18/%E3%80%90ML%E3%80%91Classification-and-Logistic-Regression/","excerpt":"","text":"李宏毅机器学习笔记 是什么classification嘛，很好理解，就是分类问题。它和回归问题的最大差别在于，回归问题出来的结果是连续的，分类问题的结果是离散的。课中通过概率大约介绍了这个分类的过程。 How?Input: 一个个体的各个特征。Output: 把这个体分到哪一类。 假设一个二分类的问题Model set现在有一个数据过来啦，我们怎么判断它是哪一类呢？ P(C_{1}|x) = \\frac{P(x|C_{1})P(C_{1})}{P(x|C_{1})P(C_{1}) + P(x|C_{2})P(C_{2})}1 P(C_{1}\\mid x)：当前有一个x，那么它是C_{1}类的可能性,2 P(C_{n})：class n在整个数据集中占多大比例,3 P(x\\mid C_{n})：在class n中取到x的概率, 所以这两个参数都是已知的，现在未知的只有P(x|C_{1})。通常我们假设这个class是一种分布，然后把x的feature值代进去，就可以取出来在这个模型的前提下，取到x到的概率是多少。 softmax就是对于预测结果的一个放大。 Loss function然后根据这个公式计算出的某个类作为预测结果，对于正确的个数求和（我觉得求百分比能够更加直观的看出效果），来评估预测效果。因为这个正确率我们是想要越大越好，而loss，求极小值为普遍方法，所以我们在loss之前加个负号。这里使用交叉熵loss。 L = -[ylog\\hat{y} +(1 - y)log(1 - \\hat{y})]Optimition反正，我们到最后可以把这个离散的关系化做 \\sigma(wx + b)然后还是用梯度下降。且，\\sigma(z)只是一种代表的激活函数，激活函数之后会有一个总结。 logistic Regression从上文化简之后，可以看出来也就是一个wx + b，就和linear regression很像了。怎么构造非线形的关系呢，激活函数。这种方法就是逻辑回归，用于分类。逻辑回归相较于线性回归，模型，loss不同，优化方法差不多。 关系可以大概表示为这样子，是不是，很眼熟？？对，你想得没错，就是神经元，就是神经网络里面的神经元。 feature Transformation有一些数据，他们原本的分布无法很好地进行分类，这时候就需要对他们进行调整。可以通过这种方法： 诶嘿，是不是有神经网络那味儿了。神经网络其实就是隐藏层做一个好的特征提取器，跟这个差不多。 refer 李宏毅DL/ML 袜，过分，我几个公式调整了好久，发现一行没办法以latex公式开头。暂时还不知道怎么才能用latex作为头。","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Gradient Descent","slug":"【ML】Gradient-Descent","date":"2021-04-12T13:39:07.000Z","updated":"2021-04-19T07:31:51.687Z","comments":true,"path":"2021/04/12/【ML】Gradient-Descent/","link":"","permalink":"https://luoyongjia.github.io/2021/04/12/%E3%80%90ML%E3%80%91Gradient-Descent/","excerpt":"","text":"李宏毅机器学习3-1笔记。 是什么是一种得到loss最优值的一种方法。 随机取一点 求这一点的梯度 根据梯度以及learning rate来更新参数从而得到最小的loss==得到最佳的参数 为什么有效GD其实是通过取局部loss下降最多的点，来决定参数的变化方向的。 如何快速地取到这个局部最优呢？这时候就引入了泰勒公式，将一个复杂的函数在一个很小的范围内取： h(x) \\approx h(x_{0}) + h'(x_{0})(x - x_{0})假设u、v为loss对于两个参数的偏微分，则： L(\\theta) \\approx s + u(\\theta_{1} - a) + v(\\theta_{2} - b)想要L(\\theta)取得最小值，则如图所示(\\Delta \\theta_{1}, \\Delta \\theta_{2})取(u, v)反方向，最大值。所以Gradient Descent的过程是\\theta^{1}\\gets \\theta ^{0 } - \\eta \\Delta L Gradient Descent的升级版基于Learning RateLearning rate 这个东西，太大很可能得不到最优值，太小呢效率又低，所以选择一个正确的learning rate是十分重要的。 Adaptive Learning Rate这是基于随着梯度下降的进行，当前点距离最优解是越来越近的理论的。随着梯度下降的进行，learning rate随之减小，比如说像这样的learning rate： \\eta^{t} = \\frac{\\eta}{\\sqrt{n + 1}}Adagrad \\begin{equation*} \\begin{aligned} &w^{t+1} \\gets w^{t} - \\frac{n^{t}}{\\sigma^{t}}\\\\ &\\sigma^{t} = \\sqrt{\\frac{1}{t + 1}\\sum_{i = 0}^{t}(g^{i})^{2}}\\\\ & \\eta^{t} = \\frac{\\eta}{\\sqrt{n + 1}}\\\\ \\end{aligned} \\end{equation*}其中\\sigma^{t}是之前这个w的所有偏微分值的均方根。这样子当t较大的时候，\\sigma^{t}就能十分接近二次微分从而做到对于不同的w有一个将不同参数的分布进行类似归一化的处理。使得不同的参数的取值距离最优点距离的估算都是一个单位的。 对于上述算式进行化简，得到： w^{t+1} \\gets w^{t} - \\frac{\\eta}{\\sqrt{\\sum_{i = 0}^{t} (g^{i})^{2}}}Stochastic Gradient Descent传统的GD是对于所有的训练数据计算梯度，然后更新系数。SGD是从训练数据中随机的抽取几个数据来算梯度，立马更新。显然这种方法更加快，效果也不错。 Normalization当不同参数传入的特征值单位相差很大的时候，不同参数对于结果的影响就会出现偏差，这样是非常不好的，不仅仅会影响到参数的更新，也会影响到训练的效率以及结果。所以需要将不同的特征值进行归一化处理。 将特征的值，通过： x_{i}^{r} \\gets \\frac{x_{i}^{r} - m_{i}}{\\sigma^{2}}其中m_{i}是所有x_{i}这个特征值的平均值，\\sigma^{2}是方差。这样处理之后，此特征的分布平均值为0，方差为1，对于所有的feature都进行这样的处理了之后，就服从相同的分布了。 refer ML Lecture 3-1: Gradient Descent","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【ML】Error","slug":"【ML】Error","date":"2021-04-10T09:52:54.000Z","updated":"2021-04-11T14:02:36.949Z","comments":true,"path":"2021/04/10/【ML】Error/","link":"","permalink":"https://luoyongjia.github.io/2021/04/10/%E3%80%90ML%E3%80%91Error/","excerpt":"","text":"这节课主要是讲，如何调教Average error。为何出现这种情况以及如何针对性解决问题。 我们的目标是—-在testing data上获得更好的表现！！！ Bias and Variance of EstimatorEstimator估算器是用来判断这一群f^{*}跟正确的\\widehat{f}之间的差距。有两个变量，Bias+Variance。 Bias其实就是你定义的函数对于正确函数之间的偏差。比如说正确的是5次函数，但是我们设置的是1次函数，这样子就出现了bias, 不管怎么训练，都没法儿很好的拟合数据。 Variance这个是关于训练的数据是否足够。不同的训练出来的模型是否效果都差不多。如果效果相差很多，就是variance大，这时候就需要更多的数据来训练模型。 总的来说我觉得这个图片能够很好的说明问题 怎么训练都训练不出，无非两个问题： model的原型选的就有问题。 训练的数据不够。 如何快速、有效挑选model？如果说，我每一个model都用所有的训练数据去训练，这样需要耗费大量的资源。然后还有一个问题，就是我们现在训练出来的参数只是针对当先数据的最优，我们怎么去应对未知的数据呢？ Validation set这时候，验证集就出现啦。我们将验证集作为验证参数的有效性的依据，然后用testing set来模拟真实情况下未知的数据。可以一分为二，也可以将数据分为三份，然后每次挑其中一个作为验证集。将验证集拿来检验当前的model的效果，最后挑选效果最好的model用全部已知数据来训练。 私以为，这种方法能够有效降低bias。 refer Where does the error come from?","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"hexo Latex显示问题","slug":"hexo-Latex显示问题","date":"2021-04-07T07:21:08.000Z","updated":"2021-04-07T07:31:36.392Z","comments":true,"path":"2021/04/07/hexo-Latex显示问题/","link":"","permalink":"https://luoyongjia.github.io/2021/04/07/hexo-Latex%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":"近几天突然发现博客上\\latex公式不显示了，前段时间还好好的，并且在本地的locallhost:4000上很正常。来一下解决方案，或许以后还能用到。 我的博客用的是pure主题。它的配置文件中并没有提到mathjax，所以我是手动加的： 1mathjax: true 也用了一段时间。 尝试 安装了插件、false 换了个浏览器、false 肯定不是网的问题，网一直都在墙外呆着、false 解决看到NexT主题中关于mathjax的配置： 12345# MathJax Supportmathjax: enable: false per_page: false cdn: &#x2F;&#x2F;cdn.mathjax.org&#x2F;mathjax&#x2F;latest&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML 把这段整到我的主题的配置文件里面去，就ok惹。🎉🎉 refer 调教Hexo[4]——记一次费劲的改版","categories":[{"name":"基本操作","slug":"基本操作","permalink":"https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://luoyongjia.github.io/tags/hexo/"},{"name":"latex","slug":"latex","permalink":"https://luoyongjia.github.io/tags/latex/"}]},{"title":"【ML】Regression","slug":"【ML】Regression","date":"2021-04-01T13:06:44.000Z","updated":"2021-04-07T07:16:44.293Z","comments":true,"path":"2021/04/01/【ML】Regression/","link":"","permalink":"https://luoyongjia.github.io/2021/04/01/%E3%80%90ML%E3%80%91Regression/","excerpt":"","text":"这是李宏毅深度学习2020的第一课笔记。 Regression在做什么输入数据，输出一个数值。 股票预测 f(StocksInfo) = DowJonesIndustrialAverage atTomorrow 自动驾驶 f(Road Info) = 方向盘的角度 步骤课上用宝可梦的例子来解释了这个步骤。通过一个基础宝可梦的相关数据预测其进化后的Combat Power(CP) Step 1: Model从一堆不同的函数中（一次函数、二次函数、对数函数等），选取合适当前数据的函数。 这里选取了线性模型：y = b + \\sum w_{i}x_{i}feature: x_{i}: x_{cp}, x_{hp}, x_{w}, x_{h}... 挑了x_{cp}作为天选之子，不同的w和b的选择能构成各种各样的函数： \\begin{equation*} \\begin{aligned} &f1: y = 10.0 + 9.0\\cdot x_{cp}\\\\ &f2: y = 9.8 + 9.2\\cdot x_{cp}\\\\ &f3: y = -0.8 - 1.2\\cdot x_{cp}\\\\ \\end{aligned} \\end{equation*}Step 2: Goodness of Function现在有那么多的函式，想要挑出能最好预测宝可梦cp值的函式需要有一个评判标准。这时候，Loss就出来了。 先来观察下Training DataTrain Data由函数输入x^{i}和函数正确的输出\\widehat{y}^{i}。课上老师的数据中有十组宝可梦的数据(x_{cp}^{n}, \\widehat{y}^{n}) Loss functionInput: a functionOutput: how bat it is 这里定义loss为： L(f) = \\sum_{n = 1}^{10}(\\widehat{y}^{n} - f(x_{cp}^{n}))^{2}也就是： L(w,b) = \\sum_{n = 1}^{10}(\\widehat{y}^{n} - (b + w \\cdot x_{cp}^{n}))^{2}Loss function的值越小，表示函数预测cp值的效果越好。 Step 3: Best Function诶嘿，终于要找最好的预测函数了。在上一步中，我们定义了Loss Function，这里需要做的工作就是将Loss Function的值降到最低。课上使用了梯度下降。 工作： \\begin{equation*} \\begin{aligned} f^{*} &= arg \\mathop{min}\\limits_{f}L(f)\\\\ w^{*}, b^{*} &= arg \\mathop{min}\\limits_{w,b} L(w,b)\\\\ & = arg \\mathop{min}\\limits_{w,b} \\sum_{n = 1}^{10}(\\widehat{y}^{n} - (b + w \\cdot x_{cp}^{n}))^{2}\\ \\end{aligned} \\end{equation*}Gradient Descent梯度下降，最简单的梯度下降。 随机初始化w^{0} 计算梯度\\frac{dL}{dw}|_{w = w^{0}}\\begin{equation*} \\begin{aligned} &w^{1} = w^{0} - \\eta \\frac{dL}{dw}|_{w = w^{0}}\\\\ &w^{2} = w^{1} - \\eta \\frac{dL}{dw}|_{w = w^{1}}\\\\ & \\ldots \\end{aligned} \\end{equation*} 梯度为负时，w++，梯度为正时，w—就这样一步步重复计算梯度-&gt;移动w的过程。 Gradient是什么就是对于多个参数组成的向量。 ResultsAverage Error\\frac{1}{n}\\sum_{i = 1}^{n}e^{i}\\sum|真实值-预测值| 探索不同的model的效果这里就不一一举例了，直接来个结果：次数越高的model，对于train data的拟合效果越好，能表示的数据结构更多。但是这样会使得再test data上效果并不好，这就是过拟合。所以要找一个合适的model，能够做到train data和test data两个性能的兼顾。 多feature观察更多的数据，发现并不只当前cp值影响预测结果，还有很多其他的因素。这时候x就不是一个单纯的数值，而是一个能够表现多个特征的向量。暂时，是这么理解的。 refer ML讲座1：回归 - 案例研究","categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"conda常用操作","slug":"conda常用操作","date":"2021-03-30T11:35:27.000Z","updated":"2021-06-06T14:21:59.589Z","comments":true,"path":"2021/03/30/conda常用操作/","link":"","permalink":"https://luoyongjia.github.io/2021/03/30/conda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"升级conda1conda update conda 升级anaconda1conda update anaconda 基本显示config1conda config --show 查看channels1conda config --show channels 移除镜像源1conda config --remove channels (url) 添加镜像源1conda config --add channels (url) 环境创建环境12conda create -n Name python&#x3D;x.x 删除环境1conda remove -n name --all 查看环境列表1conda info --env 进入环境1source activate Name 查看某环境下的包1conda list -n Name 给某环境安装包1conda install -n Name package 退出环境1source deactivate 包搜索指定的包1conda search package 更新当前环境所有包1conda update --all 安装包1conda install package 更新包1conda update package refer conda 基本操作（常用的）利用conda升级Anaconda及其包","categories":[{"name":"基本操作","slug":"基本操作","permalink":"https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"}],"tags":[]},{"title":"Linux查看GPU状态","slug":"Linux查看GPU状态","date":"2021-03-30T02:41:08.000Z","updated":"2021-03-30T11:32:42.549Z","comments":true,"path":"2021/03/30/Linux查看GPU状态/","link":"","permalink":"https://luoyongjia.github.io/2021/03/30/Linux%E6%9F%A5%E7%9C%8BGPU%E7%8A%B6%E6%80%81/","excerpt":"","text":"基本查看显卡信息：1lspci | grep -i vga 然后会显示一条条的显卡信息。然后用lspci -v -s 00:0X:XX，查看相应的显卡信息。nvida GPU查看：1lspci | grep -i nvidia Nvidia表格Nvidia显卡信息及表头解释 1nvidia-smi 上层 Fan: 风扇转速（0-100%），计算机的期望转速。N/A表示计算机不是风冷或风扇坏了。 Temp: 显卡内部温度（摄氏度）。 Perf: 性能状态，P0-P12，P0表示最大性能。 Pwr: 能耗。 Bus-Id: GPU总线相关信息。 Disp.A: Display Active, GPU是否初始化。 Memory Usage: 显存使用率。 Volatile GPU-Util: 浮动的GPU使用率。 Compute M: 计算模式。 Processes显示每块GPU上每个进程所使用的现存情况。 refer Linux查看GPU信息和使用情况","categories":[{"name":"基本操作","slug":"基本操作","permalink":"https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"GPU","slug":"GPU","permalink":"https://luoyongjia.github.io/tags/GPU/"},{"name":"Linux","slug":"Linux","permalink":"https://luoyongjia.github.io/tags/Linux/"}]},{"title":"神经网络结构搜索（NAS）综述0.1","slug":"神经网络结构搜索（NAS）综述0-1","date":"2021-03-29T02:37:04.000Z","updated":"2021-03-30T02:35:23.867Z","comments":true,"path":"2021/03/29/神经网络结构搜索（NAS）综述0-1/","link":"","permalink":"https://luoyongjia.github.io/2021/03/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%90%9C%E7%B4%A2%EF%BC%88NAS%EF%BC%89%E7%BB%BC%E8%BF%B00-1/","excerpt":"","text":"近期读了一篇Nas综述（Neural Architecture Search: A Survey）了，这篇是一篇19年的综述…就这两年Nas的发展可以说是老综述了；但是更新的我也没找到，所以就凑活着看看。 背景首先是深度学习在各个领域的应用。随着深度学习的发展，网络结构的设计对于完成任务至关重要。但是很多网络结构的设计都是基于人的经验的，这很容易出错。所以将构建网络这个过程，也交给数据与机器去自动选择。 目标能够快速地找到适应一个任务的网络结构。如图所示： 经典方法 主要包含三个方向：搜索空间、搜索策略、评价预估。很好理解：搜索空间 从哪些网络结构中搜索搜索策略 怎么针对任务挑出适应的结构评价预估 具像化简单的理解，就是评价搜索策略找出来的这个网络结构的性能。 Search Spacechain-structured neural networks: 链式的网络结构，搜索的可以有：1. 网络的层数；2. 每一层的操作；3. 超参。如图中左边的结构。 multi-branch networks: 就字面意思，多分支，看图中右边结构就懂了。 cells：人工设计的复杂的网络中有很多重复的部分，大约就是，训练小的cell，然后再进行堆叠。 Search Strategy强化学习这个暂时还不懂。 遗传进化算法大约的框架就是： 随机生成一个种群（n个网络结构） 循环：选择、交叉、变异，直到满足最终条件 不同的工作可以聚焦在不同的过程中，比如如何sample种群，如何选择种群等。 我毕设中就是用的这种方法。 基于梯度的方法强化学习和遗传进化算法都是在离散的空间中搜索，这种方法就是把操作与操作之间的路径选择转基于选择某路径的概率，从而使得离散的问题变成了连续的问题，就可以基于梯度优化的方法进行网络结构搜索了。 Performance Estimation Strategy诶嘿，这块儿是一个加快NAS训练的重要点。然后我挑了俩个人觉得还算靠谱的方法。 Weight Inheritance参数级别的迁移，用之前已经训练好的模型权重参数对于目标问题赋值，从一个较高起点的初值开始搜。具体怎么搞的，以后再补充。 One-shot在其他的方法中都需要对于每一个（n）网络结构进行训练。所以One-shot把这n个网络结构使用一个SuperNet表示。SuperNet中，可以表示不同的SubNet，从而覆盖了之前的n个网络结构。通过对于这个SuperNet的训练达到了训练n个网络结构的效果。从而大大减少了训练所需的时间和资源。 自己的碎碎念之前了解得不多，怎么说呢，想要开始就整这个方向。现在看了🤏相关的知识，会发现这其实只是一种方法，也可以说是一种工具吧，并不是一个好的，作为research起点的方向。确实这个方向有很多值得研究的方面，但是我觉得都是需要基于个人对于另一个什么方向有了深刻的理解了，再来，或许是优化NAS的方法，又或许是NAS与某个方面结合，亦或许是使NAS能做到多任务。这都是没有好的其他的基础，做不到的，so. refer 神经网络架构搜索（NAS）综述Neural Architecture Search: A Survey","categories":[{"name":"Research","slug":"Research","permalink":"https://luoyongjia.github.io/categories/Research/"}],"tags":[{"name":"Nas","slug":"Nas","permalink":"https://luoyongjia.github.io/tags/Nas/"}]},{"title":"Mac配置Anaconda环境变量","slug":"Mac配置Anaconda环境变量","date":"2021-03-26T05:15:34.000Z","updated":"2021-03-26T05:23:46.212Z","comments":true,"path":"2021/03/26/Mac配置Anaconda环境变量/","link":"","permalink":"https://luoyongjia.github.io/2021/03/26/Mac%E9%85%8D%E7%BD%AEAnaconda%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"因为好像就是这两年，macOS的系统大更新，把默认shell的bash改成了zsh。导致以前的一些配置环境变量的东西都没法儿用了。今天要开始看python的代码了，所以想着来把anaconda配一下。真的太久没用了，导致版本都……所以需要在终端配置一下，居然发现我的终端的conda, not found了。就来解决了一下。 机器背景mbp2018, bash。 会发现，原来的bash_profile都不管用了而且，anaconda的默认路径也更改了。 解决方法anaconda的路径: /Users/USERNAME/opt/anaconda3/bin bash配置文件路径：/private/etc/bashrc 就，强制在bashrc文件里面加export PATH=&quot;/Users/USERNAME/opt/anaconda3/bin:$PATH&quot;即可。 暂时还没出现问题，后续再说吧。 refer Mac 没有找到 conda命令mac设置全局环境变量","categories":[],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://luoyongjia.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"【数据结构】串","slug":"【数据结构】串","date":"2021-03-18T02:08:37.000Z","updated":"2021-03-18T04:01:39.258Z","comments":true,"path":"2021/03/18/【数据结构】串/","link":"","permalink":"https://luoyongjia.github.io/2021/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2/","excerpt":"","text":"定义计算机上非数值的处理对象。 基本操作Copy(&amp;T, s) 就是copy操作，将一个地址里的东西取出来，存到新的字符串里面。length() 字符串的长度。Index(S, T) 定位t的初始位置。 存储结构定长顺序存储顺序存储结构，分配一个定长的空间存储字符串。 堆分配存储是在程序运行的过程中，动态分配形成的。当程序请求一块空间之后，在堆空间中分配一块区域。不成功返回null。 块链存储类似于链式存储。多个节点，每个节点里面放几个字符。空的用“#”补全。 字符串算法暴力匹配老暴力方法了，就两个字符串硬比，没什么技术水平。 KMP这才是重中之重！为什么有这种方法呢，因为在暴力算法中重复了大量的比较，这种方法能够减少这种重复的出现。 先来一个文字描述 什么是next数组next数组就是匹配字串的每一位所在的最长前后缀相同的长度。如何构建呢？ 我使用的是动态规划的方法。前后两个指针。前指针指向后缀的最后一个字符，后指针指向后缀的最后一个字符。比较这两个指针存的内容， 当前指针为0，且前指针与后指针内容不相等的时候，后指针所指下标next数组存为0 相同则后指针所在位置等于前指针前一位next数组存的数字+1 不同则将前指针移动到前指针前一位next数组存的数字地址再做比较，直到前指针到0。如何匹配 正常匹配 当遇到两个字符不相等的时候，将母串与子串的next数组对应的前一位的内容做对比，相当于将子串移动到前一next位。这样就减少了前一next之前的那些重复的比较。 再来一个代码代码再说吧，有时间再写。1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"【TOEFL】 口语Task1、Task2","slug":"【TOEFL】-口语Task1、Task2","date":"2021-03-11T02:28:33.000Z","updated":"2021-03-11T02:54:07.758Z","comments":true,"path":"2021/03/11/【TOEFL】-口语Task1、Task2/","link":"","permalink":"https://luoyongjia.github.io/2021/03/11/%E3%80%90TOEFL%E3%80%91-%E5%8F%A3%E8%AF%ADTask1%E3%80%81Task2/","excerpt":"","text":"review口语的评分标准 dilivery: 表达，语言表达是否准确 language use: 用词和语法是否恰当 topic development: 独立：每个点都要有一定的展开 综合：文中或者是听力中的每个细节都要提到 task1主要是如何展开，想论据这样子。 名词角色立场不同的角色有不同的立场，从不同的立场去考虑这个问题。比如说，junk food AD，就有parents和children两个方面去考虑这个广告的影响。 特征不同的角色有不同的特点。还是那个junk food的例子，可能children就有容易被影响的特点。 其他名词分析有没有具体的细节、具体的功能、具体的表现。比如那题，现代科技代替图书馆的题，就可以分析现代科技的功能，分析图书馆的功能，从这些角度来答题。 task2主题校方通知，学生建议 阅读中的注意点 改变：正文标题，第一句话。 数字：如果文中有数字，一定要记下来，在答题中打出来显得十分细节 姓名：写信的学生的姓名，然后就是教授的名字 借口：一般会有两个接口，记个大概，因为有时候会让重复、总结文中的理由。学生的建议有时候会需要答。 答题模版 The university gives an announcement that/of do/doing …Student xxx suggests/proposes the university to do … agrees: feels happy with, infovor of disagrees: feels sorry for attrcting, enhence: 文中的理由和听力中的相同，就增强。不同就另说。 增长时间利器如果答完自己记录的细节还有5s多，那就来一句废话，就是关于第2个理由的废话，时间就够啦。","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://luoyongjia.github.io/categories/TOEFL/"}],"tags":[{"name":"口语","slug":"口语","permalink":"https://luoyongjia.github.io/tags/%E5%8F%A3%E8%AF%AD/"}]},{"title":"【数据结构】栈和队列","slug":"【数据结构】栈和队列","date":"2021-03-10T12:51:00.000Z","updated":"2021-03-11T02:26:17.195Z","comments":true,"path":"2021/03/10/【数据结构】栈和队列/","link":"","permalink":"https://luoyongjia.github.io/2021/03/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈定义是线性表的应用和推广。是受限的线性表。栈，就是“先进后出”。就像一个只有一个出口的桶，先进去的人只能等后进去的人走了才能出去。 基本操作isEmpty() 栈是否为空push(&amp;s, T elem) 压入栈pop(&amp;s, T elem) 吐出最顶上那个元素getTop(s, &amp;x) 把最顶上那个复制一份给xdestroyStack() 毁灭吧，栈 存储结构顺序存储—&gt;顺序栈就是用数组来存，然后有一个位置指针来操作。 共享栈顺序栈的抠门做法。一个空间俩栈用。一个从头开始，一个从尾巴开始这样子。 链式存储就叫链栈。便于多个栈共享存储空间，提高效率。不存在放不下的问题，反正链式，可以无限扩展。 应用算式转换，中序转后序。这个不好怎么解释，就来个🌰体会一下。 中序表达式 a + b - a * ((c + d) / e - f) + g转换为等价的后缀表达式为ab+acd+e/f-*-g+过程大约是这个样子的： 最先压入一个“#” 然后遇到数字直接输出 遇到符号根据优先级来，如果后一个的优先级高于栈顶的，则直接压入；如果后一个的优先级低于栈顶的，则弹出栈顶的，再做比较。 来一道例题吧 假设栈初始为空，将中序表达式a / b + (c * d - e * f) / g转换为等价的后缀表达式的过程中，当扫描到f时，栈中的元素依次是A.+(*- B. +(-* C. /+(*-* D. /+-*直接来个答案吧，B 题 设链表不带头节点，且所有操作均在表头进行，则下列最不适合作为链栈的是（ ） A. 只有表头节点指针，没有表尾指针的双向循环链表 B. 只有表尾节点指针，没有表头指针的双向循环链表C. 只有表头节点指针，没有表尾指针的单项循环链表D.只有表尾节点指针，没有表头指针的单项循环链表C. 因为这里只有表头，没有表尾。每次对于栈的操作都是在头上做的。但是为了维持循环链表，所以得找到尾，所以所有操作至少都是O(n)，所以它不合适。 若已知一个栈的入栈序列是1，2，3，4，其出栈序列为P_{1}, P_{2}, P_{3}, P_{4}, 则P_{2}, P_{4}不可能是（ ）A. 2，4 B. 2，1 C. 4，3 D.这种题目，就只有一种方法，那就是自己一个个举例子。 设栈的初始状态为空，当字符序列“n1_”作为栈的输入时，输出长度为3，且可用作C语言标识符的序列有（ ）A. 4 B. 5 C. 3 D. 6这个题我个人觉得出的还挺好的，结合了数据结构和C语言的知识。这里，C语言标识符的要求是“第1个字符只能是字母或是下划线。” 队列定义也是特殊的线性表。先进先出，就跟那吸管一样，只有一头可以进，另一头可以出。 基本操作front 头rear 尾enQueue() 压入deQueue() 出队列getHead() 获取头 存储结构顺序存储“假溢出”。要是用传统的一条的那种数组来存队列的话，进进出出几次，下标就给整没了，但是其实那时候队列里面还是有空间存储元素的。 循环队列所以人们就变聪明了，用环形的来存储队列。这就涉及一个下标计算的问题，这个问题常考，所以要记得一些公式 12345队首指针进1: front &#x3D; (front + 1) % MaxSize队尾指针进1:rear &#x3D; (rear + 1) %MaxSize队列长度:(rear + MaxSize - front) %MaxSize队满：(rear + 1) % MaxSize &#x3D;&#x3D; front空：front &#x3D;&#x3D; rear 链式存储带头节点单链表。有一个头头节点，然后有一个rear节点，这样子就能够很好的表示队列。 奇奇怪怪的队列增加了双端队列就是两端都可以出栈和入栈。 应用解决主机与外设之间速度不匹配的问题，解决由多用户引起的cpu资源竞争问题。eg：设置一个打印数据缓冲区。cpu中的任务排成一个队列。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"【数据结构】线性表","slug":"【数据结构】线性表","date":"2021-03-08T09:32:27.000Z","updated":"2021-03-08T15:00:48.968Z","comments":true,"path":"2021/03/08/【数据结构】线性表/","link":"","permalink":"https://luoyongjia.github.io/2021/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"定义相同数据类型的数据元素，有限长的序列。是一种逻辑结构，表示元素之间一对一的相邻关系。 顺序表使用连续地址存储。这里有一个位序，位序是从1开始的。 分配空间静态分配最开始的时候分配的一定量的空间，是不可以扩充的。 动态分配开始分配一定量的空间。在存满之后，会开辟更大一个空间，然后替换之前那个小空间。 基本操作的实现纯属，只是写了，没有测试是否正确。VSCode的c++配置太难了，就这样吧。我试着去把JetBrains的工具下下来。果然白嫖就是有点难… SeqList.h 1234567891011121314151617181920212223242526# ifndef CIRCLE_H# define CIRCLE_Hint defaultSize &#x3D; 100;template &lt;typename T&gt;class SeqList&#123;private: T *data; int maxSize; int last;public: SeqList(int len &#x3D; defaultSize); SeqList(const SeqList&lt;T&gt; &amp;L); &#x2F;&#x2F; 拷贝构造 ~SeqList(); &#x2F;&#x2F; ostream &amp;operator&#x3D;(const SeqList&lt;T&gt; &amp;L); bool Add(T elem); bool Insert(int i, T elem); bool Remove(int i, T elem); int Search(T elem); void SetData(int i, T elem); void Show();&#125;;#endif SeqList.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &quot;SeqList.h&quot;using namespace std;template&lt;typename T&gt;SeqList&lt;T&gt;::SeqList(int len)&#123; maxSize &#x3D; len; data &#x3D; new T[maxSize]; last &#x3D; -1; &#x2F;&#x2F;线性表为空&#125;template&lt;typename T&gt;SeqList&lt;T&gt;::SeqList(const SeqList&lt;T&gt; &amp;L)&#123; maxSize &#x3D; L.maxSize; last &#x3D; L.last; data &#x3D; new T[maxSize]; if(data &#x3D;&#x3D; NULL)&#123; cout &lt;&lt; &quot;存储分配失败&quot; &lt;&lt; endl; exit(1); &#125;&#125;template&lt;typename T&gt;SeqList&lt;T&gt;::~SeqList()&#123; delete[] data;&#125;template&lt;typename T&gt;bool SeqList&lt;T&gt;::Add(T elem)&#123; if((last + 1)&gt;maxSize) return false; data[last++] &#x3D; elem; return true;&#125;template&lt;typename T&gt;bool SeqList&lt;T&gt;::Insert(int i, T elem)&#123; if(last &#x3D;&#x3D; maxSize-1)&#123; &#x2F;&#x2F; 表满，不能再存 return false; &#125; if(i &lt; 0 || i &gt;last+1)&#123; &#x2F;&#x2F; i越界了 return false; &#125; for (int j &#x3D; last; j &gt;&#x3D; i; j--)&#123; data[j + 1] &#x3D; data[j]; &#125; data[i] &#x3D; elem; last++; return true;&#125;template&lt;typename T&gt;bool SeqList&lt;T&gt;::Remove(int i, T elem)&#123; if(i &lt; 0|| i &gt; last) return false; for (int j &#x3D; i; j &lt; last; j++)&#123; data[j] &#x3D; data[j + 1]; &#125; last--; return true;&#125;template&lt;typename T&gt;int SeqList&lt;T&gt;::Search(T elem)&#123; for (int i &#x3D; 0; i &lt; last; i++)&#123; if(data[i] &#x3D;&#x3D; elem) return true; &#125; return false;&#125;template&lt;typename T&gt;void SeqList&lt;T&gt;::SetData(int i, T elem)&#123; &#x2F;&#x2F; 检查i的合法性 if(i &lt; 0|| i &gt; last)&#123; return; &#125; data[i] &#x3D; elem;&#125;template&lt;typename T&gt;void SeqList&lt;T&gt;::Show()&#123; cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl; for (int i &#x3D; 0; i &lt; last; i++) &#123; cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 复杂度插入： O(n)删除： O(n)查找： O(1)修改： O(1) 错题环节 线性表的顺序存储结构是一种（ ）A. 随机存取的存储结构 B. 顺序存取的存储结构 C. 索引存储的存储结构 D.散列存取的存储结构⚠️选项中写的是存取。顺序存储，就是可以瞎取（按照下标直接存取），所以是随机的存取结构。而顺序的存取结构，是链式存储的，就是说只可以按照一定的顺序来存取。 链式表示其实就是用链式存储来存顺序表，这其中不过是分配的空间不连续了。 静态链表与动态链表静态链表：初始化的时候，每个节点都初始化了。不能改变长短的。但是存储地址不一定是连续的。动态链表：就，日常的链表 链表的分类头与尾头节点与尾节点，可有可无。里面不存内容，单纯定个位。有时候计算链表的长度可以考虑下是否有头、尾的情况。 单链表日常的，单向的链表。 双链表就是不仅仅有指向下一个节点的指针，还有指向上一个节点的指针。 循环链表尾部的next是头节点。就是，形成一个环了的链表。 静态链表一个表，跟顺序表差不多。存的指针是节点的相对地址，也就是下一个元素的index。-1时结束。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"503. 下一个更大的元素2","slug":"503-下一个更大的元素2","date":"2021-03-06T15:37:15.000Z","updated":"2021-03-07T08:35:14.909Z","comments":true,"path":"2021/03/06/503-下一个更大的元素2/","link":"","permalink":"https://luoyongjia.github.io/2021/03/06/503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A02/","excerpt":"","text":"先来看看题，这题…有点绕。 题目给定一个循环数组（首尾相接那种），输出每个元素的下一个更大元素。如果搜完了整个数组，都没有找到比它大的数字，就输出-1。 输入：[1, 2, 1]输出：[2, -1, 2]解释：第一个1的下一个更大的数是2；数字2找不到下一个更大的数；第二个1的下一个最大的数循环搜索，结果就是2 自己一想简单，粗暴的方法。这样时间复杂度到了O(n^{2}) 123456789101112131415161718192021222324252627282930public int[] nextGreaterElements(int[] nums) &#123; int[] ans &#x3D; new int[nums.length]; boolean forhead; &#x2F;&#x2F; 找每一个数字的下一个更大的元素 for(int i &#x3D; 0; i &lt; nums.length; i++)&#123; forhead &#x3D; true; &#x2F;&#x2F; 先找i后面的元素 for(int j &#x3D; i+1; j &lt; nums.length; j++)&#123; if(nums[j] &gt; nums[i])&#123; ans[i] &#x3D; nums[j]; forhead &#x3D; false; break; &#125; &#125; &#x2F;&#x2F; 再找i前面的元素 if(forhead &#x3D;&#x3D; true)&#123; int k; for(k &#x3D; 0; k &lt; i; k++)&#123; if(nums[k] &gt; nums[i])&#123; ans[i] &#x3D; nums[k]; break; &#125; &#125; if(k &#x3D;&#x3D; i)&#123; ans[i] &#x3D; -1; &#125; &#125; &#125; return ans;&#125; 然后解析里的“单调栈”单调栈栈里面的元素从栈底到栈顶是单调的。 如果栈空，当前元素入栈 栈非空，判断当前和栈顶元素的大小 如果比栈顶元素大，那么逐个弹出比较，构建ans 如果比栈顶元素小，则当前元素入栈 循环数组实现方法：Way1: 把数组复制一份到数组的末尾Way2: 使用取模运算，把下表为i映射到数组nums的长度0-N中 重写代码12345678910111213141516public int[] nextGreaterElements(int[] nums) &#123; int n &#x3D; nums.length; int[] ans &#x3D; new int[n]; &#x2F;&#x2F;将ans用-1初始化 Arrays.fill(ans, -1); Deque&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;(); for(int i &#x3D; 0; i &lt; n;i++)&#123; &#x2F;&#x2F; 栈非空,且比栈顶元素大，逐个弹出比较，构建ans while(!stack.isEmpty() &amp;&amp; nums[stack.peek()]&lt;nums[i%n])&#123; ans[stack.pop()] &#x3D; nums[i%n]; &#125; &#x2F;&#x2F; 不比栈顶元素大了，或者小了，或者栈空了，压入 stack.push(i%n); &#125; return ans;&#125; refer 动画讲解：单调栈 code来源-LeetCode-Solution","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/categories/leetcode/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://luoyongjia.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"【数据结构】绪论","slug":"【数据结构】绪论","date":"2021-03-06T12:27:22.000Z","updated":"2021-03-08T09:33:24.559Z","comments":true,"path":"2021/03/06/【数据结构】绪论/","link":"","permalink":"https://luoyongjia.github.io/2021/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"我的数据结构是以《王道 2021数据结构复习指导》为基础。然后其中我认为难理解的点，会拎出来重点分析一下。 基本概念很好，记不住的东西。 数据 是信息，是数据，是程序直接处理的原料。数据元素 数据元素含有数据，是由一群数据组成的最小的、不可分割的最小单位。比如说，一个学生（包括他的姓名、学号、年龄等）就是一个数据元素。数据对象 一群同类型的数据元素组成的。比如说，学生对象，就是由一群学生对象组成的。数据类型 就比如说byte, short, int, long这些。就是一种数值的集合。其下面又有原子类型、结构类型、抽象数据类型，分别表示值不可分，值可以分，数据和与之相关的操作。数据结构 诶嘿，终于到它了。数据结构是有关系的数据元素的集合。包括逻辑结构，存储结构和数据的运算（个人理解为方法）。 数据结构三要素我觉得这里主要是在讲逻辑结构与存储结构。还有一个名词叫“物理结构”，我在这里将会把他们仨分清楚。 逻辑结构逻辑逻辑嘛，那当然是一种抽象的东西，我们不考虑他们的实际应该怎么样，只去考虑这样子特性的数据有些什么特色，可以怎么操作。 这里要解释一下集合，就是一群数据挤到一起，没有其他联系这样子。 存储结构（物理结构）就是解决如何将数据存储的问题。 数据的运算个人理解，就是操作、方法这种东西。 这里来几道错题加深理解 可以用（ ）来定义一个完整的数据结构A. 数据元素 B.数据对象 C.数据关系 D. 抽象数据类型这里，👀上面的基本概念，就能得出答案D 以下属于逻辑结构的是（ ）A. 顺序表 B. 哈希表 C. 有序表 D. 单链表顺序表、哈希表、单链表，既可以表示逻辑结构，又可以表示存储结构。只有有序表是单纯的。 以下数据与数据的存储结构无关的术语是（ ）A. 循环队列 B. 链表 C. 哈希表 D. 栈B和C都很好排除。循环队列为一种数据结构？（这里存疑，之后来解决）可能是因为，他包含顺序表的逻辑结构，和顺序存储的存储结构，以及一些操作方法。讲真，不知道如何区分数据结构和逻辑结构的区别。问问后来补充。 在存储数据时，通常不仅要存储个数据元素的值，而且要存储( )A. 数据的操作方法 B. 数据元素的类型 C. 数据元素之间的关系 D. 数据存取的方法D，这没啥好说的，记住就好。 算法评价算法，对于一个问题的解决方法逐步描述。 一些性质有穷性 是不是有穷时间能跑完确定性 描述是不是无歧义的可行性 电脑能不能跑起来I/O 输入输出正确性 能不能正确解决问题可读性 是不是很好理解健壮性 能不能面对攻击效率 效率就是效率，时间、空间效率 时间复杂度、空间复杂度这种主要考：给段代码，然后让算复杂度。 注意点：O(1)的可以是常数级别的复杂度。 refer 数据结构之逻辑结构与物理结构（存储结构）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"再开公告","slug":"再开公告","date":"2021-03-06T11:56:28.000Z","updated":"2021-03-06T12:19:28.588Z","comments":true,"path":"2021/03/06/再开公告/","link":"","permalink":"https://luoyongjia.github.io/2021/03/06/%E5%86%8D%E5%BC%80%E5%85%AC%E5%91%8A/","excerpt":"","text":"很幸运，考研排到了第十名。听说今年还有三十多的名额。所以开始准备复试了。 之前真的是很绝望，不知道之后该怎么走才好。想了很多年的事情也没有去做。我啊，就是想得很多，做的很少。想要做研究，但是本科一点也没有向这个方向去努力。之前做双目识别，感觉很困难，也不敢去找别人讨论；看元学习那篇大论文的时候，因为很多数学知识不了解，又放弃（过了一段时间明白了之中的大概原理）。当然，可能因为当初想的很多的时候，人还很小；来到大学了之后接触了更多的东西，选择多了，人也就迷惑了。 但是我觉得，我的绝望，很多是来源与我自己。我总觉得自己应该成为一个了不起的人，但是，大多数人最终不是还是普通人吗？我打算认命的，但是我做了什么呢？在家摸鱼摸了俩月。看出来了吧，就是因为自己骨子里的懒惰。考研的时候也是这样，学了两天之后，得休息上三天，才能继续。恨自己的不争气，却又一再地放纵。还有遇见了困难，总是想逃避，总想过着当下混沌又舒适的生活。可是这样的生活，我过得也很难受。总的来说，就是想要摆脱现状，但是又没有行动这样子。 认识到问题，当然得改。我试着去改改吧，这样下去不是个事儿。就从这次准备复试开始吧。 接下来想要在blog上分享一下我每天为复试准备的知识，以及每次上完TOEFL课的小总结这样子。 偷偷放一张喜欢的焦糖太太的图。","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"String，StringBuffer和StringBuilder类","slug":"String，StringBuffer和StringBuilder类","date":"2021-01-08T10:14:09.000Z","updated":"2021-01-08T10:16:39.200Z","comments":true,"path":"2021/01/08/String，StringBuffer和StringBuilder类/","link":"","permalink":"https://luoyongjia.github.io/2021/01/08/String%EF%BC%8CStringBuffer%E5%92%8CStringBuilder%E7%B1%BB/","excerpt":"","text":"String，StringBuffer和StringBuilder类StringString对象的值是无法改变的！要改变，请找String Buffer和String Builer 创建1234String str0 &#x3D; &quot;Gugugu&quot;;String str1 &#x3D; &quot;Gugugu&quot;;String str2 &#x3D; new String(&quot;Gugugu&quot;);String str3 &#x3D; new String(&quot;Gugugu&quot;); str0和str1都是指向公共池中相同的地址，而str2和str3指向堆中的不同地址。 方法str0.length() 获取长度 str0.concat(str1) 连接两个字符串，返回的是创建的一个新字符串，可以自己连自己。 String.format(“balabalabala是%f”, floatVar) 就跟printf一样。String（java）里面是百分号诶。 char charAt(int index) 返回指定下标的字符 int indexOf(int ch) 返回第一次出现ch（or str）的下标，如果没有就-1 int compareTo(String str) 字典序比较字符串 int compareTolgnoreCase(String str) 不考虑大小写的比较字符串 boolean contentEquals(StringBuffer sb) 与指定的StringBuffer有相同顺序的字符时返回true static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示改字符的序列的String。offset是开始点。 char[] toCharArray() 转换为字符数组 String toLowerCase() 全部转小写 String toUpperCase() 全部转大写 isEmpty() 判断字符串是否为空 String Buffer和String BuilderStringBuffer和StringBuilder类的对象能够被多次修改，不产生新的未使用对象。 StringBuilder和StringBuffer最大的不同在于StringBuilder的方法不是线程安全的（不能同步访问）。 StringBuilder运行速度比StringBuffer快。 refer:Java String 类Java StringBuffer 和 StringBuilder 类","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"2021年1月3日","slug":"2021年1月3日","date":"2021-01-03T15:43:55.000Z","updated":"2021-01-03T15:52:06.734Z","comments":true,"path":"2021/01/03/2021年1月3日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/03/2021%E5%B9%B41%E6%9C%883%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 Character类、Math类、Number类 动态规划问题，三道题 练字 今日总结今天感觉还是很充实的，虽然看下来没有做些什么，但是其实又做了一点什么。感觉需要上计网和机组了…想要找一点对应的题做，不知道去年的王道的书被我丢哪儿了…没事儿，从网上找点对应题应该也不错。今天发现了一个写leetCoded总结很好的项目，之后就跟这个吧。我感觉明天常用类也能差不多，感觉在常用类上耗太久了，之后边用边学吧。今天终于是不咕鸟了，早点休息，想要拥有正常的作息。 明日规划 英语听力 leetcode一个专题 Java集合、IO 计网和机组 练字 ♨️","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"动态规划问题","slug":"动态规划问题","date":"2021-01-03T06:04:03.000Z","updated":"2021-03-07T08:34:39.144Z","comments":true,"path":"2021/01/03/动态规划问题/","link":"","permalink":"https://luoyongjia.github.io/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"一般形式是求最值，比如说最长递增子序列，最小编辑距离。 基本原理求最值，把所有的可行答案穷举出来，然后找最值就ok。 动态规划不是简单的穷举，因为动态规划问题存在「重叠子问题」，暴力穷举会效率很低，所以需要「备忘录」或者「DP table」来优化穷举的过程，避免不必要的计算。 并且动态规划一定会具备「最优子结构」，才能通过子问题的最值的到原问题的最值。需要列出正确的「状态转移方程」才能正确的穷举。在实际的算法问题中，写出「状态转移方程」是最困难的。所以提供了一个思维框架辅助思考状态转移方程： 明确base case -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 509.斐波那契数列暴力递归法1234int fib(int n)&#123; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; return fib(n - 1) + fib(n - 2);&#125; 这种方法十分的低效，假设n = 20，画出递归树： PS：画出递归树是分析递归问题的好方法。 递归算法的时间复杂度计算首先计算子问题数，由图可以看出斐波那契数列是满二叉树，所以子问题的个数为O(2^n) 然后计算每个子问题的时间，此算法没有循环，只有一个递归基和f(n - 1) + f(n - 2)，所以时间复杂度为O(1) 递归算法的时间复杂度为子问题数 \\times 子问题的时间。由此可得：斐波那契的暴力递归解法的时间复杂度为 O(2^n) 观察递归树，可以发现：存在了大量的重复计算，比如f(18)被计算了两次，而f(18)为根的递归树体量巨大，多算一遍会耗费巨大的时间，在递归中出现了多次这样的情况，使得重复进行了多次相同的运算，使得这个算法十分低效。 这就是动态规划问题的第一个性质：重叠子问题。 如何解决「重叠子问题」的问题带备忘录的递归解法我们可以造一个「备忘录」，每次计算出某个子问题的答案之后，先记入「备忘录」，然后再返回。每次遇到一个子问题先去「备忘录」中查查，如果发现已经解决过这个问题，就直接把答案拿出来用，就不用再次计算了。 一般使用数组充当这个「备忘录」，当然也可以用哈希表（字典）。 1234567891011121314151617181920public int memoFib(int n)&#123; if(n &lt; 0) return 0; &#x2F;&#x2F; 为了提高代码的可读性，所以开辟了n+1，这样每个fib数将会与相应的下标对应 int[] memoArray() &#x3D; new int[n+1]; return helper(memoArray(), n);&#125;&#x2F;&#x2F; 构造memArray()public int memArray(int[] memo, int n)&#123; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; if(memo[n] !&#x3D; 0) return memo[n]; &#x2F;&#x2F; 递归体 memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2); return memo[n];&#125; 这种方法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。 dp数组迭代解法有了上一步「备忘录」的启发，我们可以把「备忘录」独立出来成为一张表，就叫做DP table。在这张表上完成「自底向上」的推算岂不美哉。 12345678910111213141516public int dpTable(int n)&#123; if(n &lt; 0) return 0; if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; &#x2F;&#x2F; 构建dpTable int[] dp &#x3D; new int[n + 1]; dp[1] &#x3D; 1; dp[2] &#x3D; 1; for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123; dp[i] &#x3D; dp[i - 1] + dp[1 - 2]; &#125; return dp[n];&#125; 「状态转移方程」： f(x)=\\left\\{ \\begin{aligned} 1, n = 1,2 \\\\ f(n-1) + f(n-2), n>2 \\\\ \\end{aligned} \\right.这里把f(n)想做状态n，状态n是由状态n-1和状态n-2相加转移而来的，这就叫状态转移。 所以要先想出暴力解，然后通过暴力解的到转移方程，再通过备忘录或者DP table优化。 fib还可以优化甚至不需要整个dpTable，只需要记载n，n-1，n-2三个值就ok，此时的复杂度降到了O(1)。 12345678910111213public int bestFib(int n)&#123; int num1 &#x3D; 1; int num2 &#x3D; 1; int num &#x3D; 0; for(int i &#x3D; 3; i &lt;&#x3D; n; i++)&#123; num &#x3D; num1 + num2; num1 &#x3D; num2; num2 &#x3D; num; &#125; return num;&#125; 这种方法叫做「状态压缩」，当我们发现状态转移时只需要用上DP table中的一部分，那样就可以尝试用状态压缩来缩小DP table。 322.凑零钱题目：给你k中面值的硬币，面值分别为c1, c2, ...,ck，美中硬币的数量无限，再给一个总金额amount，问最少需要几枚硬币来凑出这个金额，如果凑不出，返回-1。 暴力解法首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？用一个直观的例子来讲解。 比如说，假设考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。 回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。 如何列出正确的状态转移方程 确定 base case，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。 确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。 确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。 明确 dp 函数/数组的定义。这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数： dp(n) ：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。 然后就可以得到状态转移方程 f(x)=\\left\\{ \\begin{aligned} 0, n=0 \\\\ -1, n0 \\end{aligned} \\right.带备忘录的递归解法123456789101112131415161718192021222324252627282930313233343536373839public int getCoinsMemo(int[] coins, int n) &#123; if(n &lt; 0) return -1; if(n &#x3D;&#x3D; 0) return 0; int[] memo &#x3D; new int[n + 1]; return helper(coins, memo, n);&#125;public int helper(int[] coins, int[] memo, int n) &#123; if(n &lt; 0) return -1; if(n &#x3D;&#x3D; 0) return 0; if(memo[n] !&#x3D; 0) return memo[n]; &#x2F;&#x2F;得到当💰需要的coin数 int cur &#x3D; Integer.MAX_VALUE; int coinNum &#x3D; 0; for (int coin : coins) &#123; coinNum &#x3D; helper(coins, memo, n - coin); &#x2F;&#x2F; 当小于0或者这个子方法表示不出的时候 if (n - coin &lt; 0 || coinNum &#x3D;&#x3D; -1) continue; if (coinNum + 1 &lt; cur) &#123; cur &#x3D; coinNum + 1; &#125; &#125; if(cur &#x3D;&#x3D; Integer.MAX_VALUE)&#123; cur &#x3D; -1; &#125; memo[n] &#x3D; cur; return cur; &#125; 自底向上的DPtable方法12345678910111213141516171819202122232425&#x2F;&#x2F;自底向上DPtable方法public int getCoinsDP(int[] coins, int sum) &#123; if (sum &lt; 0) return -1; if (sum &#x3D;&#x3D; 0) return 0; int dp[] &#x3D; new int[sum + 1]; dp[0] &#x3D; 0; int cur; for (int i &#x3D; 1; i &lt;&#x3D; sum; i++) &#123; cur &#x3D; Integer.MAX_VALUE; for (int coin : coins) &#123; if (i - coin &lt; 0 || dp[i - coin] &#x3D;&#x3D; -1) continue; if (dp[i - coin] + 1 &lt; cur) cur &#x3D; dp[i - coin] + 1; &#125; if (cur &#x3D;&#x3D; Integer.MAX_VALUE) dp[i] &#x3D; -1; else dp[i] &#x3D; cur; &#125; return dp[sum];&#125; 总结就是那个步骤： 明确base case（递归基） -&gt; 明确「状态」-&gt; 明确「选择」-&gt;定义dp数组/函数的含义 -&gt;优化 「备忘录」自上而下的方法其实就是一种递归的优化方法，消除了很多重复计算的部分，所以优化了方法，但是还是没有自下而上好。 「DPtable」自下而上的方法当我们分析出「状态转移方程」后，就可以自下而上构造dp[]（其实就是备忘录），然后直接从中取得就OK。 refer：动态规划解题套路框架 Code","categories":[{"name":"算法","slug":"算法","permalink":"https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/tags/leetcode/"}]},{"title":"2021年1月2日","slug":"2021年1月2日","date":"2021-01-02T15:04:58.000Z","updated":"2021-03-06T12:00:52.711Z","comments":true,"path":"2021/01/02/2021年1月2日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%882%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 Object类 过程中遇见的问题Object类太难了，套娃一样，lei了。从Object到String到Integer…希望明天能简单一点。 今日总结方法有问题，明日改方法。希望每天的时间能够均匀一点，不要总扑在一件事情上。明天中午睡觉不脱裤子，不然又会睡过，今天中午就睡了一个半小时，起床之后还泡了一杯奶茶…但是还是消除不了Object带来的心累。害，明天一定不会这么苦，希望拥有正常的作息。☕️ 明日规划 英语听力 letcode中的3题，一定要开始！ Java两个类的使用 剑指offer的2题 练字 今天又是鸽子精，希望明天能做不咕鸟🐦","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Object类","slug":"Object类","date":"2021-01-02T14:59:11.000Z","updated":"2021-01-02T15:07:15.747Z","comments":true,"path":"2021/01/02/Object类/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/Object%E7%B1%BB/","excerpt":"","text":"java.lang.Object 是一个根类，是老祖宗。 lang包不用导入，直接使用。 boolean equals(object obj)判断对象的地址是否相等。 123public boolean myEquals(MyObject obj)&#123;return this &#x3D;&#x3D; obj;&#125; 这里==比较的是两个对象在内存中的地址。 使用1objectName.equals(anOtherObject); equals()和==的区别 equals()是方法，==是操作符 ==能用于基本类型变量(byte, short, int, long, float, double)，但是equals()不能，equals()只能用于继承Object类的类的对象。 ==在基本类型变量的比较过程中比较的是基本类型变量值，==、equale()在对象的比较中都是比较的地址。可以将equals()重写来使其比较值。 对于String类的equals()重写重写euqals()应该遵循JavaSE的通用约定 自反性（reflexive）：对于任何非null引用值x，x.equals(x)必须返回true 对称性（symmetric）：对于任何非null引用值x和y，当且仅当x.equals(y)返回true时，y.equals(x)返回true 传递性（transitive）: 对于任何非null的引用值x, y和z， 如果x.equals(y)返回true, 并且y.equals(z)也返回true, 那么x.equals(z)也必须返回true。 一致性（consistent）: 对于任何非null的引用值x和y, 只要equals()的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true, 或者一致的返回false。 对于任何非null的引用值x，x.equals(null)必须返回false。 重写我搜了搜原码，发现在String类中的equals()没有写@Override，然后就去搜了一下，发现@Override是伪代码，可写可不写的，写上可以方便阅读、适合编译器给你检查。 String类中private final char[] value存储输入的值 123456789101112131415161718192021222324252627public boolean equals(Object anObject)&#123; &#x2F;&#x2F;判断地址是否相同 if(this &#x3D;&#x3D; anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anOtherString &#x3D; (String) anObject; int n &#x3D; value.length; &#x2F;&#x2F;判断长度是否相同 if(n &#x3D;&#x3D; anOtherString.value.length)&#123; char v1[] &#x3D; value; char v2[] &#x3D; anOtherString.value; int i &#x3D; 0; while(n-- !&#x3D; 0)&#123; if(v1[i] !&#x3D; v2[i]) return false; i++; &#125; &#x2F;&#x2F;当所有都比对过之后跳出while return true; &#125; &#x2F;&#x2F;当传入的Object都不是String类的情况 return false;&#125; final native Class&lt;?&gt; getClass();使用返回的是当前引用指向的实例的类。 1234567public static void main(String[] args) &#123; TestClass test1 &#x3D; new TestClass(); Object test2 &#x3D; new TestClass(); System.out.println(&quot;test1 class &#x3D; &quot; + test1.getClass()); System.out.println(&quot;test2 class &#x3D; &quot; + test2.getClass());&#125; 输出的结果为： 12test1 class &#x3D; class src.TestClasstest2 class &#x3D; class src.TestClass nativenative是与C++联合开发时去使用的。使用native关键字说明这个方法是原生函数，也就是这个方法使用C/C++语言实现的，并且被便衣成了dll，由java去调用。 C++源码挖坑 native int hashCode();使用1objectName.hashCode(); C++源码挖坑 重写hashCode()方法应该遵循JavaSE的通用约定 在应用程序的执行期间，只要对象的equals()的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次hashCode()，它必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同。 如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode()必须产生同样的整数结果。 如果两个对象根据equals(Object)是不相等的，那么调用这两个对象中任一个对象的hashCode()，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。 所以根据第2条可以看出，重写了equals()方法之后必须重写hashCode()方法，这两个方法相互对应。 String重写hashCode()方法在原String类中，其直接改变了hashCode的生成方式。 12345678910111213141516public int hashCode()&#123; &#x2F;&#x2F;hash的默认值为0，为String类的一个private属性 int h &#x3D; hash; &#x2F;&#x2F;当String实例中value不为空时，hashCode根据value的内容产生 if(h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0)&#123; char val[] &#x3D; value; for(int i &#x3D; 0; i &lt; value.length; i++)&#123; h &#x3D; 31 * h + val[i]; &#125; hash &#x3D; h; &#125; return h;&#125; String toString()把对象中的值以字符串的形式展示出来 源码套中套中套中套 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;&#x2F;哈希码转Stringpublic String toString()&#123;return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;...&#x2F;&#x2F;Integer类&#x2F;&#x2F;toHexString(int i)方法public static String toHexString(int i)&#123; return toUsignedString0(i, 4);&#125;&#x2F;* * toUnsignedString0方法 * Convert the integer to an unsigned number. * 将一群数字变成String *&#x2F; private static String toUnsignedString0(int val, int shift)&#123; &#x2F;&#x2F;assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D; 5 : &quot;Illegal shift value&quot;; &#x2F;&#x2F;删除头部的0 int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val); &#x2F;&#x2F;私以为：判断一共有几位（一位有shift个码），最小为1 int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1); &#x2F;&#x2F;创建字符串容器了，用来装输出的String char[] buf &#x3D; new char[chars]; formatUnsignedInt(val, shift, buf, 0, chars); return new String(buf, true); &#125; &#x2F;* 将一串unsigned数据转换为字符串 val, 需要被转换的unsigned int shift，分组的过程(4 for hex, 3 for octal, 1 for binary) buf, 存储内容的对应2^shift进制的数字 offset，开始读val的位置 len，要写入的char的数量 return 写入第一个char的下标*&#x2F;static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)&#123; int charPos &#x3D; len; &#x2F;&#x2F;得到对应进制的掩码 &#x2F;&#x2F;eg: 16-&gt;1 0000 int radix &#x3D; 1 &lt;&lt; shift; &#x2F;&#x2F;1 0000 - 1 -&gt; 1111 int mask &#x3D; radix - 1; &#x2F;&#x2F;当val非空且还有未读的位时 do&#123; &#x2F;&#x2F;将当前位置的值与掩码做比较，存下这一位的值 buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask]; &#x2F;&#x2F;下一位，val右移shif位 val &gt;&gt;&gt;&#x3D; shift; &#125;while(val !&#x3D; 0 &amp;&amp; charPos &gt; 0) return charPos;&#125;&#x2F;&#x2F;就是一个进制转换表final static char[] digits &#x3D; &#123; &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; , &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; , &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; , &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; , &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; , &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39; &#125;; 使用普通的： 123objectName.toString()return: className@地址 重写了hashCode的类，可能也会重写这个函数，这个函数主要还是根据哈希值来得到内容的。 refer： JDK源码阅读（一）：Object源码分析 说说如何重写Java的equals方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"2021年1月1日","slug":"2021年1月1日","date":"2021-01-01T16:14:30.000Z","updated":"2021-01-03T15:45:17.287Z","comments":true,"path":"2021/01/02/2021年1月1日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/2021%E5%B9%B41%E6%9C%881%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 年度计划（永远立不起来的flag） Java基础语法 过程中遇见的问题无，详情请见Java基础语法以及易忽略点总结 今日总结今天睡得很开心，中午也睡了午觉。任务太多了，完不成。所以决定调整计划，明天希望过得轻松一点。空调温度果然还是需要调高一点，下午20度真的冻死我了。（附：还是好想去自习室，元旦特惠没有了，有点可惜）。 明日规划flag永不倒！！！！ 找2个类学学 英语听力 leetcode-3个题 开题报告开题报告开题报告开题报告 剑指offer2个题 练字 明天一定是 不 咕 鸟🐦！！！","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Java基础语法以及易忽略点总结","slug":"Java基础语法以及易忽略点总结","date":"2021-01-01T16:09:10.000Z","updated":"2021-01-01T16:10:40.570Z","comments":true,"path":"2021/01/02/Java基础语法以及易忽略点总结/","link":"","permalink":"https://luoyongjia.github.io/2021/01/02/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"非常主观 非常主观 非常主观！ 类型基本类型： byte, short, int, long, float, double, char, boolean（low —— high）引用类型：类，接口，数组 类型转换在运算中，不同类型的数据都会先转化为较高的那一类，然后再进行运算 而由高转低 1((低类型) 变量名) 变量Java是一种强类型语言，也就是说每个东西都要有它明确的属性，不像Js、Python。 作用域个人jio得这个可以去康康我之前那篇由JVM内存划分与职能到值传递和引用传递。这里就做一个简单的描述。 静态变量：也就是类变量，当类加载时就存在的变量，只加载一次，不能改变。 实例变量：也就是成员变量，在类实例化时加载，存在那个实例里面。 局部变量：一次性变量，即用即删。生存周期同存在的方法时间相同。 数字里面可以带_，更容易理解，JDK新功能。 常量就是特殊的变量，在程序运行过程中保持不变。 1final Type name &#x3D; xxx; 命名不要以_或$开始或者结束。不要用拼音（除非国际通用的国内代名词）。 类名 开头大写的驼峰式。 方法名、参数名、成员变量、局部变量 同一使用开头小写的驼峰式。 常量 全部大写，单词之间用_隔开。 抽象类用Abstract或Base开头；异常类用Exception结尾；测试类用Test结尾。 运算符自增自减运算符a++ 先加，再拿a进行操作 ++a 先拿a进行操作，再加 — 同理 位运算符&amp; 将两个数字都转换为二进制后，两个数字在当位上都为1时此位为1，否则则为0 | 两个数字在当位上只需要有一个为1，则此位为1。 ^ 当两个数字当位上的数字不一样，则为1，相同则为0 ～ 当前数字二进制取逆 1234567A &#x3D; 0011 1001B &#x3D; 0000 0101A &amp; B &#x3D; 0000 0001A | B &#x3D; 0011 1101A ^ B &#x3D; 0011 1100~B &#x3D; 1111 1010 移位运算&lt;&lt; 向左移，高位溢出舍弃高位。补码啊…我都忘记了，等我机组学到这里再来补。负数无符号右移，用1填补。正数用0填补。 &gt;&gt; 向右移，同&lt;&lt; &gt;&gt;&gt; 无符号版本，都是补0 包机制导包： import 命名：通常用域名的倒置座位包名 12eg: www.baidu.com包的格式就为：com.baidu.www Java Doc生成文档，超级6。文档注释。首先来个Doc.java 123456789101112131415161718192021&#x2F;**** @author name* @ version 1.0* @since 1.8 *&#x2F;public class Doc&#123; String name; &#x2F;** * * @author xxx * @param name * @return * @throws Exception *&#x2F; public String test(String name)&#123; &#125;&#125; 方法中/**回车自动生成。 主要的有些： 123456@author@version@since jdk支持的最老版本@palam 参数名@return@throw 异常抛出 然后命令行当前路径 1javadoc -encoding UTF-8 -charaset UTF-8 Doc.java javadoc生成文档命令。 Scanner来自于java.util.Scanner的输入 Scanner对象的常用操作： 12345scanner.next() &#x2F;&#x2F;读取输入的字符，空格断开scanner.nextLine() &#x2F;&#x2F;读取当前行的输入scanner.hasNext() &#x2F;&#x2F;判断之后还有没有输入scanner.hasNextLine() &#x2F;&#x2F;判断是否还有下一行的输入&#x2F;&#x2F;next后还可以加基本类名，则限定输入的类 Scanner读取规则next() 要读到有效字符后的第一个空格或者换行符后结束。光标指向此空格之后 nextLine() 读完一行之后，光标指向下一行的开头 scanner.close()慎用！慎用！慎用！ 只要调用了这个函数后，之后新建的Scanner对象就无效了。但是也不能忘记在程序的结尾处，开了几个Scanner就关几个Scanner。 反编译VSCode还不知道怎么搞，坑先挖这儿吧。 重载就是名称相同，通过输入的参数的类型不同而调用不同的方法的功能。（写好几个相同名字的方法） 命令行参数你是否还记得： 1234...public static void main(String[] args)&#123;&#125; 中的args，这里就是用来实现命令行参数的，先在当前路径javac **.java编译。然后退到src文件夹（根文件夹）再 1java 此文件所在的相对位置.**.class 输入输入输入 可变参数在参数的最后， 1dataType ...a) 就可以输入多个这个类型的参数。 数组动态数组： 12dataType[] name &#x3D; new dataType[size];dataType[][] name1 &#x3D; new dataType[rowNum][colNum]; 初始化为0.. 静态数组： 12dataType[] name2 &#x3D; &#123;1, 2, 3, 4, 5&#125;;dataType[][] name3 &#x3D; &#123;&#123;1, 2&#125;,&#123;3, 4&#125;&#125;; 方法方法之间的调用当两个方法都为静态方法或者非静态方法的时候，它们之间可以相互调用，但一个静态一个非静态时，不可以相互调用。 构造器1public ClassName(); 当重写了构造器（有输入）之后需要重写一个没输入的才能实现继承。 多态假设现在这里有Father类，Son类继承Father类。假设他们都有eat()方法。 12345Father fater &#x3D; new Son();Son son &#x3D; new Son();father.eat(); &#x2F;&#x2F;执行的是son中的eatson.eat(); &#x2F;&#x2F;执行的是son中的eat Father类引用只能调用Father类中存在的方法，father不能调用Son中独有的方法。两个类都有的方法调用实例化那个类的方法。 instanceof类之间是否存在关系。父子ok，对象作实例化类来判断 1A instance of B 静态作用域执行顺序 1234567static&#123; &#x2F;&#x2F; 静态代码块&#125;&#123; &#x2F;&#x2F; 匿名代码块&#125;&#x2F;&#x2F;构造方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月31日","slug":"12月31日","date":"2020-12-31T16:37:41.000Z","updated":"2021-01-03T15:45:30.262Z","comments":true,"path":"2021/01/01/12月31日/","link":"","permalink":"https://luoyongjia.github.io/2021/01/01/12%E6%9C%8831%E6%97%A5/","excerpt":"","text":"今天干了些什么 英语听力 hexo上传图片问题 Java基础语法 过程中遇见的问题hexo上传本地图片在尝试调用url无效之后，开始打起了装插件的想法，没想到又是个大坑。不过终究是解决了。 Step 1修改根目录的_config.ym中的 1post_asset_folder:true Step 2 安装正确版本的插件注意注意注意，我直接安装hexo-asset-image出现了图片被多加了一个/的问题，再搜，发现是这个包的问题，尝试了改index.js，发现无效，所以就卸载了： 1npm unisntall -g hexo-asset-image 然后安装正确版本hexo-asset-image-0.0.5.git 1npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save Step 3 插入图片🎉1![1](文章名字对应文件夹&#x2F;图片名) Java内容明日再更新，之后再加链接到这里今日总结其实一上午都没有学习，因为起得晚，再🐟一下就到十点了，好像因为晚上睡得晚，导致早上也起不来…无解。有点想去自习室，但是爹妈就是不同意，不知道为什么。新的一年到来了，希望一切都能变得好起来。 明日规划 英语听力 Java基础过完 新年计划（今天真的太困了…只能咕） Java基础的blog总结一下 开题报告开题报告开题报告！ 练字 letcode-3题（or more） refer：hexo本地图片不显示","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"由JVM内存划分与职能到值传递和引用传递","slug":"由JVM内存划分与职能到值传递和引用传递","date":"2020-12-31T14:52:00.000Z","updated":"2021-01-01T03:43:56.656Z","comments":true,"path":"2020/12/31/由JVM内存划分与职能到值传递和引用传递/","link":"","permalink":"https://luoyongjia.github.io/2020/12/31/%E7%94%B1JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E8%81%8C%E8%83%BD%E5%88%B0%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"","text":"课程布置了一项小作业，让了解值传递和引用传递，于是去从网上搜，就找到了这篇写得非常清晰的文章，让我从JVM内存划分的基础角度了解了值传递和引用传递的区别。 JVM内存划分与职能在java第一课中我们认识到了java程序都是运行在jvm上的，那jvm里面到底干了些什么呢？这里给出一个更加详细的程序执行图 内存划分由图可以得出，当java代码被翻译成字节码后，jvm开辟了一片新的内存空间（运行时数据区），下面依次来介绍其中的功能。 虚拟机栈方法被执行的地方，虚拟基站中存放着栈帧，方法调用的过程对应着栈帧在虚拟机中入栈到出栈的过程。 栈时私有的，也就是线程之间栈是隔离的。当程序某个线程开始执行一个方法，就会创建一个栈帧并入栈（于栈顶），方法结束后，栈帧出栈 下图为Java栈的模型及栈帧的组成： 局部变量表：储存方法中的局部变量，变量为基本数据类型时，存储值，变量为引用类时，存储引用类对象的地址 操作数栈：Java虚拟机的解释执行引擎常被称为“基于栈的执行引擎”，其中的栈为这个操作栈 指向运行时常量池的引用：可能用到的常量的引用 方法返回地址：存储方法执行完之后的返回地址 堆存储对象本身和数组，JVM中只有一个堆，所以堆是被所有线程共享的。 方法区一块线程共享的内存逻辑区域，JVM中只有一个方法区，存放一些线程可共享的内容。它是线程安全的，多个线程访问一个内容时，只有一个线程装载其数据，其他线程等待。 本地方法栈本地方法栈和虚拟机栈功能大约相同，线程私有。它和虚拟机栈之间的差别在于它主要为本地方法服务而虚拟机栈为Java方法服务。 程序计数器线程私有。记录当前线程所执行的字节码（*.class）的行号和指示器。字节码解释器工作就是通过改变计数器的值来选去下一条需要执行的字节码指令。个人认为程序计数器实现了Java的解释型语言性质。 数据存储数据基础知识 基本类型：byte, short, int, long, float, double, char, boolean 引用类型：类，接口，数组 12345678910111213public class Example&#123; public static PI &#x3D; 3.14;&#x2F;&#x2F;静态变量 private int name; &#x2F;&#x2F;成员变量 public void static main(String[] args)&#123; int a; &#x2F;&#x2F;局部变量 &#125; public int sum(int num1, int num2)&#123; int sum &#x3D; 0; &#x2F;&#x2F;局部变量 sum &#x3D; num1 + num2; return sum &#125; 数据在内存中存储方法基本数据局部变量直接存储在内存中的栈上，也就是之前提到过的“虚拟机栈”。 所以当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 成员变量也就是class中的一些属性变量，这些变量的生命周期同对象是一致的。 静态变量当类开始纯在，静态变量就储存在了堆中，当类被消灭的时候，它们才会被消灭。 引用数据引用数据传入时，传入的是存放变量内容的地址。 值传递与引用传递值传递可以简单的理解为上面对于成员变量的定义，一次性的变量。 当我们给一个方法传入变量时，栈帧中拷贝了一份变量的值，并创建了一个副本来储存这个值，当方法结束时，栈帧被丢掉，这个副本也就被删了，原来变量的值也就没变。 引用传递很好理解，就是将存变量值的堆中的地址给传进方法了，所以方法中对于传入的变量的更改实质上就是更改那个地址中存储的内容，一改则全改。eg: 123456789101112131415161718192021public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 结果将会是： 123传入的person的name：小明方法内重新赋值后的name：小红方法执行后的name：小红 在那篇博客中还发现了一片很好玩的问题： 还是刚刚那段代码 1234567891011121314151617181920212223public class Person&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name &#x3D; name; &#125;&#125;public static void PersonCrossTest(Person person)&#123; System.out.println(&quot;传入的person的name：&quot;+person.getName()); &#x2F;&#x2F;改变的地方 person &#x3D; new Person(); person.setName(&quot;小红&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName()); &#125;public static void main(String[] args)&#123; Person p &#x3D; new Person(); p.setName(&quot;小明&quot;); PersonCrossTest(p); System.out.println(&quot;方法执行后的name: &quot; + p.getName());&#125; 这个地方在PersonCrossTest方法里，person由原来指向小明的地址1改为了在方法中new Person()创建的临时的一个Person对象的地址2，在PersonCrossTest方法结束时地址2就被删除了，地址1中的内容并没有改变。 所以说，这里的引用传递其实是一个虚假的引用传递，不过是在栈帧中创建了一个变量存储传进来变量的地址。 终于写完了，今天就只加个总结吧，Java基础内容明日再更。 refer:这一次，彻底解决Java的值传递和引用传递","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"我的Java第一课","slug":"我的JAVA第一课","date":"2020-12-30T15:31:50.000Z","updated":"2020-12-31T03:42:56.384Z","comments":true,"path":"2020/12/30/我的JAVA第一课/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%88%91%E7%9A%84JAVA%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"基础概念不同的javaJavaSE: 标准版，适用于桌面程序与控制台的开发 JavaME: 嵌入式开发 JavaEE: 企业级开发，如Web服务器 动态性、多线程 Write Once, Run Anywhere JDK、JRE、JVMJVM(Java Virtual Machine)简单的来说，就是一个虚拟机，java程序都是基于这个虚拟机来跑的。 正是这个虚拟机使得Java能够屏蔽底层的差异，实现跨平台开发 JRE(Java Runtime Environment)包，JRE提供了Java的类库，其中包含了JVM JDK(Java Development Kit)开发者需要的东西，其中包括了很多开发工具 所以综上所述，它们仨的关系可以用这个图来表示： 接下来就开始上机操作了 配置环境JDK袜，这个真的，也有一点坑，我在官网上找了好久才找到下载的地方。这里直接指路吧。选择自己相应的版本然后注册（登陆）oracle账号就👌。 然后配置环境变量（仅限mac）。打开终端 1open -e .bash_profile 然后输入： 123456JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk你的版本.jdk&#x2F;Contents&#x2F;HomePATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 最后用： 1java-version 看java版本是不是跟自己的jdk装的版本一样就🉑️了 JDK内部探秘因为课里面讲了一点，所以也记了一下。就几个主要的文件夹。 \\bin 可执行的程序，比如说java、javac的运行程序就在这里面 \\include 因为Java是基于C、C++的嘛，这里面就有调用的一些C、C++的包 \\jre 运行环境 \\lib Java的库 \\src 一些Java类 我感觉这一块儿还不是太懂，之后有更深入了解了再来补充与修改 Hello world文本编辑器版本创建Hello.java写入： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 然后命令行进入对应文件夹 12javac Hello.javajava Hello 这里就出现一个问题了，为什么要先javac，然后再java呢这就不得不说一下Java的运行机制了。Java是集编译型与解释型的语言。javac就是起编译器的作用。生成字节码Hello.class，然后再进行之后的操作 VSCode版本step 1 下载插件 Language Support for Java™ by Red Hat Debugger for Java Java Test Runner Maven for Java Java Dependency Viewer Java Extension Pack step 2Ctrl+Shift+P输入Java: Configure Java Runtime修改默认JDK版本与路径 step 3可以开始创建工程，输入代码，然后run辣 其中遇见了一个奇葩问题我看课程中使用IDEA写的，在project/src/pakageName中直接写代码就能跑，但是在VSCode中不一样，需要在*.java文件的开头添加package src.pakageName; 具体是什么原因我也不大清楚，先记下来吧。 Refer：Java JDK, JRE and JVM 太懒了，图片先不整了，有缘再整 图片调整好辣，今天晚上一定要记一下这个坑 配置就到这儿啦，希望明天能过完基础语法🤡","categories":[{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"2020年12月30日","slug":"12-30","date":"2020-12-30T14:31:54.000Z","updated":"2021-01-03T15:45:45.812Z","comments":true,"path":"2020/12/30/12-30/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-30/","excerpt":"","text":"今天干了些什么 昨天规划的大约的工作安排做了 git就只学会了初始化，上传这样子 Java环境搭建，以及写了个hello world 过程中遇见的问题git就是从一个空白项目怎么配置到本地这样子 先创建一个空白的文件夹，我习惯是创建一个同名的，然后进入此文件夹的目录 1234git initgit remote add origin git@github.com: ... &#x2F;&#x2F;...是项目的路径git add .git push -u origin master &#x2F;&#x2F;这里要注意此电脑是master 或者用这种方法，在git add .之后 12git branch -M maingit push -u origin main 这样子就是main路径了。 删除了user文件夹下初始化过的.gith文件夹，vscode的sourceControl终于不现实5k+ changes了，我就觉得肯定是因为有个.git的问题 Java开发相关的问题这个我想重新写一篇blog来更全面的描述。 今日总结今日没有出门学习，感觉在家果然还是有点🐟的。也还行吧，早上起来床了，任务也完成得七七八八。Java的课上着感觉有点简单，但是还是跟着上下去吧，熟悉的就2倍速，不熟悉的再仔细听，我怕出现那种像高数课一样，突然什么都听不懂了。还是希望明天能够更高效吧。搞这些整得我觉得手机都不好玩了，真好。明天想要写一个年度总结，不知道有没有时间，或许就同日记一起写了，但是我觉得这俩还是有挺大区别的，日记主要还是记一下当日遇见的问题以及解决的方法。 明日规划 英语听力 letcode中的3题 Java语法学完（这个任务视难度而调整） 剑指offer-2题 至少把自己的开题报告好好康康 练字练字练字！ 每天都要开心哦🥳","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"春招准备规划【实时更新】","slug":"春招准备规划【实时更新】","date":"2020-12-30T04:02:12.000Z","updated":"2020-12-30T06:04:17.838Z","comments":true,"path":"2020/12/30/春招准备规划【实时更新】/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%E8%A7%84%E5%88%92%E3%80%90%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E3%80%91/","excerpt":"","text":"春招准备规划【实时更新】第一阶段（12.30-1.31）基础：算法基础这里采用剑指offer中的题和算法面试题汇总结合，每天做一定量（2+3） 手写代码手写代码手写代码！ Java基础上网课同时实践 其他基础看书+练题 方法针对性，手写代码。 目标：历届的笔试面试题 通过小公司面试积累经验，先从小公司开始 说话能力 每日任务 3+2 算法题 网络一课 机组一课 英语听力 练字","categories":[{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"2020年12月29日","slug":"12-29日总结","date":"2020-12-29T16:44:36.000Z","updated":"2021-01-03T15:45:53.849Z","comments":true,"path":"2020/12/30/12-29日总结/","link":"","permalink":"https://luoyongjia.github.io/2020/12/30/12-29%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天干了些什么 大约将博客搭起来了 了解了毕设中期需要做一些什么 开了蓝灯 过程中遇见的问题搭建博客git在post的过程中出现帐号错误原因：当初作死，就想换个github帐号重新开始，导致电脑中默认的git帐号密码有问题 解决方法：不仅仅是说我使用 123git config -list \\\\查询信息git config --global user.namegit config --global user.email 就可以了的，在不同的系统下操作不同，我此仅代表mac用户。 还需要删除钥匙串访问中的github.com项 关于hexo pure主题配置的一堆破事所以在这里写下从头开始应该怎么配置pure主题，附上官方文档 修改基本信息基本信息 hexofolder\\themes\\hexo-theme-pure\\source\\images中替换头像的那张图片，然后在hexo-theme-pure\\_config.ym中配置 icon 删除了hexofolder\\themes\\hexo-theme-pure\\source\\中的favicon.png，然后在images文件夹下 添加了icon的图片，将hexofolder\\themes\\hexo-theme-pure\\_config.yml中favicon对应的路径改成了\\images\\favicon。这真的是一个大坑，因为在hexo创建新的文章后路径上会加上日期，所以使用相对路径就会找不到icon图标 comment 这部分肥肠简单，我选择的是valine。大约步骤如下 注册一个LeanCloud帐号 创建一个工程 在设置中找应用keys填进去 在安全中心添加blog的url 今日总结明明感觉自己做了很多事情，写起来又发现自己其实只做了一点点。毕设的中期答辩想要开始准备了，但是感觉还是无从下手。未来几个月怎么准备找工作的规划也还没做。可能是处理问题的速度太慢了。但是我也没有办法，只能慢慢来。 明日规划 做好找工作的整体安排，安排了当天就做点吧 写git的常用操作并实践 毕设的概要了解，工作量估计","categories":[{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-29T06:07:19.495Z","updated":"2020-12-29T06:07:19.495Z","comments":true,"path":"2020/12/29/hello-world/","link":"","permalink":"https://luoyongjia.github.io/2020/12/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"深度学习基础","slug":"深度学习基础","permalink":"https://luoyongjia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"},{"name":"基本操作","slug":"基本操作","permalink":"https://luoyongjia.github.io/categories/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"name":"Research","slug":"Research","permalink":"https://luoyongjia.github.io/categories/Research/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyongjia.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TOEFL","slug":"TOEFL","permalink":"https://luoyongjia.github.io/categories/TOEFL/"},{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/categories/leetcode/"},{"name":"日记","slug":"日记","permalink":"https://luoyongjia.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luoyongjia.github.io/categories/Java/"},{"name":"算法","slug":"算法","permalink":"https://luoyongjia.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"规划","slug":"规划","permalink":"https://luoyongjia.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Colab","slug":"Colab","permalink":"https://luoyongjia.github.io/tags/Colab/"},{"name":"hexo","slug":"hexo","permalink":"https://luoyongjia.github.io/tags/hexo/"},{"name":"latex","slug":"latex","permalink":"https://luoyongjia.github.io/tags/latex/"},{"name":"GPU","slug":"GPU","permalink":"https://luoyongjia.github.io/tags/GPU/"},{"name":"Linux","slug":"Linux","permalink":"https://luoyongjia.github.io/tags/Linux/"},{"name":"Nas","slug":"Nas","permalink":"https://luoyongjia.github.io/tags/Nas/"},{"name":"环境变量","slug":"环境变量","permalink":"https://luoyongjia.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"口语","slug":"口语","permalink":"https://luoyongjia.github.io/tags/%E5%8F%A3%E8%AF%AD/"},{"name":"单调栈","slug":"单调栈","permalink":"https://luoyongjia.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"随笔","slug":"随笔","permalink":"https://luoyongjia.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"常用类","slug":"常用类","permalink":"https://luoyongjia.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"},{"name":"leetcode","slug":"leetcode","permalink":"https://luoyongjia.github.io/tags/leetcode/"},{"name":"编程","slug":"编程","permalink":"https://luoyongjia.github.io/tags/%E7%BC%96%E7%A8%8B/"}]}